
add_executable(main
        ../lib/cJSON.c
        ../lib/cJSON.h
        library.c
        library.h
        log.c
        log.h
        ephemeral.c
        ephemeral.h
        scoreboard.c
        scoreboard.h
        concurrency.c
        concurrency.h
        tests.c
        tests.h
        main.c
)

target_link_libraries(main PRIVATE Threads::Threads)#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <errno.h>
#include "concurrency.h"
#include "ephemeral.h"
#include "log.h"

/* ---------------------------
   PROCESS INIT
   --------------------------- */
void init_process(process_t* p, unsigned long burst, int prio, unsigned long arrival, double weight){
    if(!p){
        log_error("init_process => Null pointer for process_t");
        return;
    }
    if(burst == 0){
        log_warn("init_process => burst=0. Process will complete instantly.");
    }
    if(prio < 0){
        log_warn("init_process => negative priority => continuing but check logic.");
    }
    if(weight <= 0.0){
        log_warn("init_process => nonpositive weight => forcing weight=1.0");
        weight = 1.0;
    }

    p->id             = 0;
    p->burst_time     = burst;
    p->priority       = prio;
    p->arrival_time   = arrival;
    p->remaining_time = burst;
    p->first_response = 0;
    p->end_time       = 0;
    p->responded      = false;
    p->weight         = weight;
    p->hpc_affinity   = -1;
    p->mlfq_level     = 0;
    p->was_preempted  = false;
}

/* ---------------------------
   READY QUEUE STRUCTURES
   --------------------------- */
typedef struct rq_node_s {
    process_t*        proc;
    struct rq_node_s* next;
} rq_node_t;

typedef struct {
    rq_node_t*       head;
    int              size;
    pthread_mutex_t  lock;
    pthread_cond_t   cond;
    scheduler_alg_t  alg;
    double           wfq_virtual_time; /* For Weighted Fair Queueing. */
} ready_queue_t;

/* ---------------------------
   HELPER: INIT / DESTROY RQ
   --------------------------- */
static void rq_init(ready_queue_t* rq, scheduler_alg_t alg){
    memset(rq, 0, sizeof(*rq));
    pthread_mutex_init(&rq->lock, NULL);
    pthread_cond_init(&rq->cond, NULL);
    rq->alg = alg;
    rq->wfq_virtual_time = 0.0;
}

static void rq_destroy(ready_queue_t* rq){
    if(!rq) return;
    rq_node_t* c = rq->head;
    while(c){
        rq_node_t* nx = c->next;
        free(c);
        c = nx;
    }
    pthread_mutex_destroy(&rq->lock);
    pthread_cond_destroy(&rq->cond);
    memset(rq, 0, sizeof(*rq));
}

/* Comparators for sorted insertion */
typedef int (*proc_cmp_fn)(const process_t* A, const process_t* B);

static int prio_asc_cmp(const process_t* A, const process_t* B){
    return (A->priority - B->priority); /* smaller => front */
}
static int burst_asc_cmp(const process_t* A, const process_t* B){
    if(A->burst_time < B->burst_time) return -1;
    if(A->burst_time > B->burst_time) return 1;
    return 0;
}

static void rq_insert_sorted(ready_queue_t* rq, process_t* p, proc_cmp_fn cmp){
    rq_node_t* n = (rq_node_t*)malloc(sizeof(rq_node_t));
    n->proc = p;
    n->next = NULL;

    if(!rq->head){
        rq->head = n;
        return;
    }
    if(!cmp){
        /* Insert at tail. */
        rq_node_t* c = rq->head;
        while(c->next) c = c->next;
        c->next = n;
        return;
    }
    /* Ascending sort insertion. */
    rq_node_t* c  = rq->head;
    rq_node_t* px = NULL;
    while(c){
        if(cmp(p, c->proc) < 0){
            if(px){
                px->next = n;
            } else {
                rq->head = n;
            }
            n->next = c;
            return;
        }
        px = c;
        c = c->next;
    }
    px->next = n;
}

/*
   Main push function
*/
static void rq_push(ready_queue_t* rq, process_t* p){
    rq_node_t* n = NULL;

    pthread_mutex_lock(&rq->lock);

    if(!p){
        /* termination marker => push front always. */
        n = (rq_node_t*)malloc(sizeof(rq_node_t));
        n->proc = NULL;
        n->next = rq->head;
        rq->head = n;
        rq->size++;
        pthread_cond_broadcast(&rq->cond);
        pthread_mutex_unlock(&rq->lock);
        return;
    }

    switch(rq->alg){
        case ALG_PRIORITY:
            /* Non-preemptive priority => ascending order by prio. */
            rq_insert_sorted(rq, p, prio_asc_cmp);
            break;
        case ALG_SJF:
            /* Insert by burst ascending. */
            rq_insert_sorted(rq, p, burst_asc_cmp);
            break;
        case ALG_HPC:
            /* HPC example => push front. */
            n = (rq_node_t*)malloc(sizeof(rq_node_t));
            n->proc = p;
            n->next = rq->head;
            rq->head = n;
            break;
        case ALG_PRIO_PREEMPT:
            /* Keep ascending order for preemptive priority. */
            rq_insert_sorted(rq, p, prio_asc_cmp);
            break;
        default:
            /* default => FIFO for RR, BFS, MLFQ, WFQ, etc. */
            rq_insert_sorted(rq, p, NULL);
            break;
    }

    rq->size++;
    pthread_cond_broadcast(&rq->cond);
    pthread_mutex_unlock(&rq->lock);
}

/*
   Weighted Fair Queueing pop => earliest finish time
   otherwise => pop head
*/
static process_t* rq_pop(ready_queue_t* rq, bool* got_termination_marker){
    *got_termination_marker = false;
    pthread_mutex_lock(&rq->lock);

    while(rq->size == 0){
        pthread_cond_wait(&rq->cond, &rq->lock);
    }

    process_t* ret = NULL;

    if(rq->alg == ALG_WFQ){
        rq_node_t* prev=NULL,* best_prev=NULL,* best_node=NULL;
        double best_val = 1e15;
        rq_node_t* cur = rq->head;
        while(cur){
            if(!cur->proc){
                /* termination marker => pick that immediately. */
                best_node = cur;
                break;
            }
            double finish = rq->wfq_virtual_time
                + ((double)cur->proc->remaining_time / cur->proc->weight);
            if(finish < best_val){
                best_val = finish;
                best_node = cur;
                best_prev = prev;
            }
            prev = cur;
            cur  = cur->next;
        }
        if(!best_node){
            pthread_mutex_unlock(&rq->lock);
            return NULL;
        }
        if(!best_node->proc){
            /* termination marker => end thread. */
            *got_termination_marker = true;
            if(best_node == rq->head){
                rq->head = best_node->next;
            } else if(best_prev){
                best_prev->next = best_node->next;
            }
            free(best_node);
            rq->size--;
            pthread_mutex_unlock(&rq->lock);
            return NULL;
        }
        ret = best_node->proc;
        if(best_node == rq->head){
            rq->head = best_node->next;
        } else if(best_prev){
            best_prev->next = best_node->next;
        }
        free(best_node);
        rq->size--;

        rq->wfq_virtual_time += (double)ret->remaining_time / ret->weight;
        pthread_mutex_unlock(&rq->lock);
        return ret;
    }
    else {
        /* Non-WFQ => pop head. */
        rq_node_t* h = rq->head;
        rq->head = h->next;
        rq->size--;
        ret = h->proc;
        if(!ret){
            *got_termination_marker = true;
        }
        free(h);
        pthread_mutex_unlock(&rq->lock);
        return ret;
    }
}

/*
   For preemptive priority: check if we need to forcibly preempt.
*/
static bool try_preempt_if_needed(ready_queue_t* rq, process_t* p){
    if(rq->alg != ALG_PRIO_PREEMPT || !p) return false;

    pthread_mutex_lock(&rq->lock);

    if(!rq->head || !rq->head->proc){
        pthread_mutex_unlock(&rq->lock);
        return false;
    }
    process_t* front = rq->head->proc;
    if(front->priority < p->priority){
        /* Preempt => put p back, pop the new highest. */
        p->was_preempted = true;
        rq_insert_sorted(rq, p, prio_asc_cmp);
        rq->size++;
        pthread_mutex_unlock(&rq->lock);
        return true;
    }
    pthread_mutex_unlock(&rq->lock);
    return false;
}

/* ---------------------------
   CONTAINER QUEUES
   --------------------------- */
typedef struct {
    ready_queue_t main_rq;
    ready_queue_t hpc_rq;
} container_queues_t;

/* ---------------------------
   TIMELINE
   --------------------------- */
static void record_timeline(container_t* c, int core_id, int proc_id,
                            unsigned long start_ms, unsigned long slice,
                            bool preempted)
{
    pthread_mutex_lock(&c->timeline_lock);
    if(c->timeline_count+1 >= c->timeline_cap){
        c->timeline_cap += 100;
        c->timeline = realloc(c->timeline, c->timeline_cap*sizeof(*c->timeline));
        if(!c->timeline){
            log_error("record_timeline => out of memory allocating timeline!");
            pthread_mutex_unlock(&c->timeline_lock);
            return;
        }
    }
    c->timeline[c->timeline_count].core_id         = core_id;
    c->timeline[c->timeline_count].proc_id         = proc_id;
    c->timeline[c->timeline_count].start_ms        = start_ms;
    c->timeline[c->timeline_count].length_ms       = slice;
    c->timeline[c->timeline_count].preempted_slice = preempted;
    c->timeline_count++;
    pthread_mutex_unlock(&c->timeline_lock);
}

/* CPU-bound simulation, scaled for demonstration. */
static void do_cpu_work(unsigned long ms){
    usleep((useconds_t)(ms * 3000U));
}

/*
   GET QUANTUM (PER ALGORITHM)
*/
static unsigned long get_quantum(scheduler_alg_t alg, process_t* p){
    if(!p) return 0;
    switch(alg){
        case ALG_RR:   return 2;
        case ALG_BFS:  return 4;
        case ALG_WFQ:  return 3;
        case ALG_MLFQ: {
            /* Example MLFQ: base 2 + 2 per level. */
            return (2 + p->mlfq_level*2);
        }
        case ALG_PRIO_PREEMPT:
            return 2;
        default:
            return 2; /* fallback for FIFO, SJF, PRIORITY, HPC. */
    }
}

/*
   SCHEDULING SLICE ROUTINE
*/
static void run_slice(container_t* c, process_t* p,
                      scheduler_alg_t alg, int core_id,
                      container_queues_t* qs,
                      unsigned long* used_ms)
{
    if(!p || p->remaining_time == 0){
        *used_ms = 0;
        return;
    }

    unsigned long quantum = get_quantum(alg, p);

    pthread_mutex_lock(&c->finish_lock);
    unsigned long start_ms = c->sim_time;
    if(!p->responded){
        p->responded = true;
        p->first_response = start_ms;
    }
    pthread_mutex_unlock(&c->finish_lock);

    unsigned long slice_used = 0;
    unsigned long slice_remaining = quantum;
    bool preempted_flag = false;

    while(slice_remaining > 0 && !c->time_exhausted && p->remaining_time > 0){
        unsigned long step = (slice_remaining < p->remaining_time)
                             ? slice_remaining : p->remaining_time;

        if(step > 0){
            do_cpu_work(step);
        }

        pthread_mutex_lock(&c->finish_lock);

        p->remaining_time -= step;
        c->accumulated_cpu += step;
        c->sim_time        += step;

        slice_used += step;
        slice_remaining -= step;

        if(p->remaining_time == 0){
            p->end_time = p->first_response + p->burst_time;
            c->remaining_count -= 1;
            if(c->remaining_count <= 0){
                c->time_exhausted = true;
            }
        }
        if(c->accumulated_cpu >= c->max_cpu_time_ms){
            c->time_exhausted = true;
        }
        pthread_mutex_unlock(&c->finish_lock);

        /* For preemptive priority, check arrivals or higher-priority arrivals. */
        if(alg == ALG_PRIO_PREEMPT){
            bool got_preempted = try_preempt_if_needed(&qs->main_rq, p);
            if(got_preempted){
                preempted_flag = true;
                break;
            }
        }

        if(c->time_exhausted){
            break;
        }
    }

    if(alg == ALG_MLFQ && p->remaining_time>0 && slice_used == quantum){
        /* MLFQ => demote if used entire quantum. */
        p->mlfq_level++;
    }

    *used_ms = slice_used;
    record_timeline(c, core_id, p->id, start_ms, slice_used, preempted_flag);
}

/* STOP + ARRIVAL CHECKS */
static bool is_time_exhausted(container_t* c){
    pthread_mutex_lock(&c->finish_lock);
    bool r = c->time_exhausted ||
             (c->accumulated_cpu >= c->max_cpu_time_ms);
    pthread_mutex_unlock(&c->finish_lock);
    return r;
}

static void force_stop(container_t* c, ready_queue_t* rq_main, ready_queue_t* rq_hpc){
    for(int i=0;i<c->nb_cores;i++){
        rq_push(rq_main, NULL);
    }
    for(int i=0;i<c->nb_hpc_threads;i++){
        rq_push(rq_hpc, NULL);
    }
}

static void check_main_arrivals(container_t* c, ready_queue_t* rq){
    pthread_mutex_lock(&c->finish_lock);
    unsigned long now = c->sim_time;
    pthread_mutex_unlock(&c->finish_lock);

    for(int i=0;i<c->main_count;i++){
        process_t* p = &c->main_procs[i];
        if(p->remaining_time>0 && p->arrival_time>0){
            if(p->arrival_time <= now){
                rq_push(rq, p);
                p->arrival_time = 0;
            }
        }
    }
}

static void check_hpc_arrivals(container_t* c, ready_queue_t* rq){
    pthread_mutex_lock(&c->finish_lock);
    unsigned long now = c->sim_time;
    pthread_mutex_unlock(&c->finish_lock);

    for(int i=0;i<c->hpc_count;i++){
        process_t* p = &c->hpc_procs[i];
        if(p->remaining_time>0 && p->arrival_time>0){
            if(p->arrival_time <= now){
                rq_push(rq, p);
                p->arrival_time = 0;
            }
        }
    }
}

/* PER-CORE THREAD */
typedef struct {
    container_t*       container;
    container_queues_t*qs;
    int                core_id;
} core_pack_t;

static void* main_core_thread(void* arg){
    core_pack_t* pack = (core_pack_t*)arg;
    container_t* c    = pack->container;
    container_queues_t* qs = pack->qs;
    int core_id       = pack->core_id;
    free(pack);

    while(!is_time_exhausted(c)){
        bool term_marker=false;
        process_t* p = rq_pop(&qs->main_rq, &term_marker);
        if(term_marker || !p){
            break;
        }
        unsigned long used=0;
        run_slice(c, p, c->main_alg, core_id, qs, &used);

        if(!is_time_exhausted(c) && p->remaining_time>0){
            rq_push(&qs->main_rq, p);
        }

        check_main_arrivals(c, &qs->main_rq);
        check_hpc_arrivals(c, &qs->hpc_rq);

        if(is_time_exhausted(c)){
            force_stop(c, &qs->main_rq, &qs->hpc_rq);
            break;
        }
    }
    return NULL;
}

/* HPC THREAD */
static void* hpc_thread(void* arg){
    core_pack_t* pack = (core_pack_t*)arg;
    container_t* c    = pack->container;
    container_queues_t* qs = pack->qs;
    int hpc_id = pack->core_id; /* negative ID for timeline. */
    free(pack);

    while(!is_time_exhausted(c)){
        bool term_marker=false;
        process_t* p = rq_pop(&qs->hpc_rq, &term_marker);
        if(term_marker || !p){
            break;
        }

        unsigned long used=0;
        run_slice(c, p, c->hpc_alg, hpc_id, qs, &used);

        if(!is_time_exhausted(c) && p->remaining_time>0){
            rq_push(&qs->hpc_rq, p);
        }

        /* HPC steal from main if allowed + HPC is empty? */
        if(c->allow_hpc_steal){
            pthread_mutex_lock(&qs->hpc_rq.lock);
            int hpc_size = qs->hpc_rq.size;
            pthread_mutex_unlock(&qs->hpc_rq.lock);
            if(hpc_size == 0){
                bool dummy=false;
                process_t* stolen = rq_pop(&qs->main_rq, &dummy);
                if(stolen && !dummy){
                    run_slice(c, stolen, c->main_alg, hpc_id, qs, &used);
                    if(!is_time_exhausted(c) && stolen->remaining_time>0){
                        rq_push(&qs->main_rq, stolen);
                    }
                }
            }
        }

        check_main_arrivals(c, &qs->main_rq);
        check_hpc_arrivals(c, &qs->hpc_rq);

        if(is_time_exhausted(c)){
            force_stop(c, &qs->main_rq, &qs->hpc_rq);
            break;
        }
    }
    return NULL;
}

/* PRINT TIMELINE */
static int compare_timeline(const void* a, const void* b){
    const typeof(((container_t*)0)->timeline[0]) *A = (const void*)a;
    const typeof(((container_t*)0)->timeline[0]) *B = (const void*)b;
    if(A->core_id < B->core_id) return -1;
    if(A->core_id > B->core_id) return 1;
    if(A->start_ms < B->start_ms) return -1;
    if(A->start_ms > B->start_ms) return 1;
    return 0;
}

static void print_container_timeline(container_t* c){
    if(c->timeline_count==0){
        printf("\n\033[1m\033[33mNo timeline for container.\n\033[0m");
        return;
    }
    qsort(c->timeline, c->timeline_count,
          sizeof(c->timeline[0]), compare_timeline);

    printf("\033[1m\033[36m\n--- Container Timeline ---\n\033[0m");
    int current_core = 999999999;
    for(int i=0;i<c->timeline_count;i++){
        int core_id = c->timeline[i].core_id;
        if(core_id != current_core){
            if(core_id >= 0){
                printf("\033[1m\033[32m\nMain Core %d:\n\033[0m", core_id);
            } else {
                int hpc_idx = (-1 - core_id);
                printf("\033[1m\033[35m\nHPC Thread %d:\n\033[0m", hpc_idx);
            }
            current_core = core_id;
        }
        unsigned long st = c->timeline[i].start_ms;
        unsigned long ln = c->timeline[i].length_ms;
        bool pre = c->timeline[i].preempted_slice;
        if(pre){
            printf("  T[%lu..%lu] => P%d \033[1m\033[33m[PREEMPT]\033[0m\n",
                   st, st+ln, c->timeline[i].proc_id);
        } else {
            printf("  T[%lu..%lu] => P%d\n", st, st+ln, c->timeline[i].proc_id);
        }
    }
}

/* CONTAINER RUN + INIT */
static void* container_run(void* arg){
    container_t* c = (container_t*)arg;
    if(!c){
        log_error("container_run => null container pointer?");
        return NULL;
    }

    c->ephemeral_path = ephemeral_create_container();
    if(!c->ephemeral_path){
        log_error("container_run => ephemeral creation failed. Will run anyway.");
    }

    /* Give IDs. HPC offset by 1000. */
    for(int i=0;i<c->main_count;i++){
        c->main_procs[i].id = i;
    }
    for(int i=0;i<c->hpc_count;i++){
        c->hpc_procs[i].id = 1000 + i;
    }

    /* Create local queues */
    container_queues_t qs;
    rq_init(&qs.main_rq, c->main_alg);
    rq_init(&qs.hpc_rq,  c->hpc_alg);

    /* Push immediate arrivals (arrival_time=0). */
    for(int i=0;i<c->main_count;i++){
        process_t* p = &c->main_procs[i];
        if(p->remaining_time>0 && p->arrival_time==0){
            rq_push(&qs.main_rq, p);
        }
    }
    for(int i=0;i<c->hpc_count;i++){
        process_t* p = &c->hpc_procs[i];
        if(p->remaining_time>0 && p->arrival_time==0){
            rq_push(&qs.hpc_rq, p);
        }
    }

    /* Start main core threads. */
    pthread_t* main_threads = (pthread_t*)calloc(c->nb_cores, sizeof(pthread_t));
    if(!main_threads){
        log_error("container_run => cannot allocate main_threads");
        return NULL;
    }
    for(int i=0;i<c->nb_cores;i++){
        core_pack_t* pack = (core_pack_t*)malloc(sizeof(core_pack_t));
        if(!pack){
            log_error("container_run => cannot allocate core_pack_t");
            continue;
        }
        pack->container = c;
        pack->qs        = &qs;
        pack->core_id   = i;
        pthread_create(&main_threads[i], NULL, main_core_thread, pack);
    }

    /* Start HPC threads. */
    pthread_t* hpc_threads = NULL;
    if(c->nb_hpc_threads>0){
        hpc_threads = (pthread_t*)calloc(c->nb_hpc_threads, sizeof(pthread_t));
        if(!hpc_threads){
            log_error("container_run => cannot allocate hpc_threads");
        } else {
            for(int i=0;i<c->nb_hpc_threads;i++){
                core_pack_t* pack = (core_pack_t*)malloc(sizeof(core_pack_t));
                if(!pack){
                    log_error("container_run => cannot allocate HPC core_pack_t");
                    continue;
                }
                pack->container = c;
                pack->qs        = &qs;
                pack->core_id   = -1 - i;
                pthread_create(&hpc_threads[i], NULL, hpc_thread, pack);
            }
        }
    }

    /* Join main threads. */
    for(int i=0;i<c->nb_cores;i++){
        pthread_join(main_threads[i], NULL);
    }
    free(main_threads);

    /* Join HPC threads. */
    if(c->nb_hpc_threads>0 && hpc_threads){
        for(int i=0;i<c->nb_hpc_threads;i++){
            pthread_join(hpc_threads[i], NULL);
        }
        free(hpc_threads);
    }

    /* Destroy queues */
    rq_destroy(&qs.main_rq);
    rq_destroy(&qs.hpc_rq);

    /* ephemeral remove */
    if(c->ephemeral_path){
        ephemeral_remove_container(c->ephemeral_path);
        free(c->ephemeral_path);
        c->ephemeral_path = NULL;
    }

    /* Print timeline */
    print_container_timeline(c);

    /* Clean up timeline array. */
    if(c->timeline){
        free(c->timeline);
        c->timeline = NULL;
    }
    pthread_mutex_destroy(&c->timeline_lock);
    pthread_mutex_destroy(&c->finish_lock);

    return NULL;
}

void container_init(container_t* c,
                    int nb_cores,
                    int nb_hpc_threads,
                    scheduler_alg_t main_alg,
                    scheduler_alg_t hpc_alg,
                    process_t* main_list,
                    int main_count,
                    process_t* hpc_list,
                    int hpc_count,
                    unsigned long max_cpu_ms)
{
    if(!c){
        log_error("container_init => container pointer is NULL");
        return;
    }
    memset(c, 0, sizeof(*c));

    if(nb_cores < 0 || nb_hpc_threads < 0){
        log_warn("container_init with negative core/hpc => forcing 0");
        if(nb_cores < 0)        nb_cores = 0;
        if(nb_hpc_threads < 0)  nb_hpc_threads = 0;
    }
    if(max_cpu_ms == 0){
        log_warn("container_init => max_cpu_ms=0 => forcing 100");
        max_cpu_ms = 100;
    }

    c->nb_cores        = nb_cores;
    c->nb_hpc_threads  = nb_hpc_threads;
    c->main_alg        = main_alg;
    c->hpc_alg         = hpc_alg;
    c->main_procs      = main_list;
    c->main_count      = main_count;
    c->hpc_procs       = hpc_list;
    c->hpc_count       = hpc_count;
    c->max_cpu_time_ms = max_cpu_ms;
    c->remaining_count = main_count + hpc_count;

    pthread_mutex_init(&c->finish_lock, NULL);
    pthread_mutex_init(&c->timeline_lock, NULL);

    c->timeline        = NULL;
    c->timeline_count  = 0;
    c->timeline_cap    = 0;
    c->time_exhausted  = false;
    c->accumulated_cpu = 0;
    c->sim_time        = 0;

    /* If we have 0 main cores but still have main processes,
       let HPC threads steal from main automatically to avoid deadlock. */
    if(nb_cores == 0 && main_count > 0){
        log_info("container_init => no main cores but main processes exist => enabling HPC steal");
        c->allow_hpc_steal = true;
    } else {
        c->allow_hpc_steal = false;
    }
}

void orchestrator_run(container_t* arr, int count){
    pthread_t* tids = (pthread_t*)calloc(count, sizeof(pthread_t));
    if(!tids){
        log_error("orchestrator_run => cannot allocate thread array");
        return;
    }
    for(int i=0;i<count;i++){
        pthread_create(&tids[i], NULL, container_run, &arr[i]);
    }
    for(int i=0;i<count;i++){
        pthread_join(tids[i], NULL);
    }
    free(tids);
}
#ifndef CONCURRENCY_H
#define CONCURRENCY_H

#include <pthread.h>
#include <stdbool.h>

/**
 * @brief Enumeration representing different scheduling algorithms.
 */
typedef enum {
    ALG_NONE=-1,
    ALG_FIFO=0,
    ALG_RR,
    ALG_SJF,
    ALG_PRIORITY,
    ALG_BFS,
    ALG_MLFQ,
    ALG_HPC,
    ALG_WFQ,           /* Weighted Fair Queueing demonstration */
    ALG_PRIO_PREEMPT   /* New: Preemptive Priority scheduling */
} scheduler_alg_t;

/**
 * @brief Represents a single process entity for scheduling.
 */
typedef struct {
    int           id;             /**< Unique ID for debugging/timeline */
    unsigned long burst_time;     /**< Original burst (execution) time */
    int           priority;       /**< Used by priority-based schedulers */
    unsigned long arrival_time;   /**< Arrival time for process */
    unsigned long remaining_time; /**< Remaining execution time */
    unsigned long first_response; /**< Timestamp of first scheduling response */
    unsigned long end_time;       /**< Timestamp when process completed */
    bool          responded;      /**< True if process has responded at least once */

    double        weight;         /**< Weight for Weighted Fair Queueing */

    int           hpc_affinity;   /**< HPC thread index if relevant */

    int           mlfq_level;     /**< MLFQ queue level for demonstration */

    bool          was_preempted;  /**< If forcibly preempted (for logging) */
} process_t;

/**
 * @brief A container that includes resources for:
 * - multiple CPU core threads
 * - multiple HPC (high-performance) threads
 * - separate scheduling algorithms for main vs HPC
 * - a timeline of scheduling events
 */
typedef struct container_s {
    int              nb_cores;         /**< Number of main cores */
    int              nb_hpc_threads;   /**< Number of HPC threads */
    scheduler_alg_t  main_alg;         /**< Algorithm for main queue */
    scheduler_alg_t  hpc_alg;          /**< Algorithm for HPC queue */

    process_t*       main_procs;       /**< Array of main processes */
    int              main_count;
    process_t*       hpc_procs;
    int              hpc_count;

    unsigned long    max_cpu_time_ms;  /**< Hard limit on CPU usage (simulation ends if exceeded) */
    unsigned long    accumulated_cpu;  /**< Sum of CPU time used so far */
    unsigned long    sim_time;         /**< "Current" simulation time */
    bool             time_exhausted;   /**< If we have ended the simulation */

    int              remaining_count;  /**< #processes not finished */

    pthread_mutex_t  timeline_lock;
    struct {
        int           core_id;    /* HPC ID if negative */
        int           proc_id;
        unsigned long start_ms;
        unsigned long length_ms;
        bool          preempted_slice;
    } *timeline;
    int   timeline_count;
    int   timeline_cap;

    char* ephemeral_path;

    pthread_mutex_t finish_lock;

    bool allow_hpc_steal; /**< HPC can steal from main if no HPC tasks. */
} container_t;


/**
 * @brief Initialize a single process struct.
 */
void init_process(process_t* p, unsigned long burst, int prio, unsigned long arrival, double weight);

/**
 * @brief Create + init a container for scheduling.
 */
void container_init(container_t* c,
                    int nb_cores,
                    int nb_hpc_threads,
                    scheduler_alg_t main_alg,
                    scheduler_alg_t hpc_alg,
                    process_t* main_list,
                    int main_count,
                    process_t* hpc_list,
                    int hpc_count,
                    unsigned long max_cpu_ms);

/**
 * @brief Start multiple containers in parallel.
 *        (Each container spawns threads internally.)
 */
void orchestrator_run(container_t* arr, int count);

#endif
#include "ephemeral.h"
#include "log.h"
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <sys/stat.h>
#include <dirent.h>

#define MAX_EPHEMERAL_PATH 256

/*
   If you want fully recursive removal,
   define EPHEMERAL_RM_RECURSIVE in the build.
*/
#ifdef EPHEMERAL_RM_RECURSIVE
static int remove_directory_recursive(const char* path){
    DIR* dir = opendir(path);
    if(!dir){
        return rmdir(path);
    }
    struct dirent* entry;
    int ret=0;
    while((entry = readdir(dir))){
        if(strcmp(entry->d_name, ".")==0 || strcmp(entry->d_name, "..")==0){
            continue;
        }
        char buf[512];
        snprintf(buf, sizeof(buf), "%s/%s", path, entry->d_name);

        struct stat st;
        if(stat(buf, &st)==0){
            if(S_ISDIR(st.st_mode)){
                ret = remove_directory_recursive(buf);
                if(ret!=0) break;
            } else {
                ret = unlink(buf);
                if(ret!=0) break;
            }
        }
    }
    closedir(dir);
    if(ret==0){
        ret = rmdir(path);
    }
    return ret;
}
#endif

char* ephemeral_create_container(void){
    char tmpl[] = "/tmp/container_XXXXXX";
    char* p = (char*)malloc(MAX_EPHEMERAL_PATH);
    if(!p){
        log_error("ephemeral_create_container mem fail");
        return NULL;
    }
    strcpy(p, tmpl);
    if(!mkdtemp(p)){
        log_error("mkdtemp fail %s => %s", p, strerror(errno));
        free(p);
        return NULL;
    }
    log_info("ephemeral created => %s", p);
    return p;
}

void ephemeral_remove_container(const char* path){
    if(!path) return;
#ifdef EPHEMERAL_RM_RECURSIVE
    int r = remove_directory_recursive(path);
#else
    int r = rmdir(path);
#endif
    if(r == 0){
        log_info("ephemeral removed => %s", path);
    } else {
        log_warn("ephemeral remove fail => %s : %s", path, strerror(errno));
    }
}
#ifndef EPHEMERAL_H
#define EPHEMERAL_H

/**
 * @brief Creates a temporary container folder (e.g. /tmp/container_XXXXXX).
 * @return A malloc'ed string with the folder path or NULL on failure.
 */
char* ephemeral_create_container(void);

/**
 * @brief Removes the ephemeral container folder created by ephemeral_create_container().
 *        By default attempts rmdir; optionally can remove contents if EPHEMERAL_RM_RECURSIVE is defined.
 * @param path Path to remove. If NULL, does nothing.
 */
void ephemeral_remove_container(const char* path);

#endif
#include "library.h"
#include "scoreboard.h"
#include "log.h"
#include <stdlib.h>
#include <signal.h>

static volatile sig_atomic_t g_skip_remaining_tests = 0;

int skip_remaining_tests_requested(void) {
    return (g_skip_remaining_tests != 0);
}

void set_skip_remaining_tests(const int val) {
    g_skip_remaining_tests = (val ? 1 : 0);
}

void handle_signal(const int signum){
    scoreboard_save();
    if(signum == SIGINT) {
        /* SIGINT => exit immediately, but save scoreboard + stats. */
        log_warn("Caught Signal to exit => exiting");
        exit(1);
    }

    if(signum == SIGTERM) {
        set_skip_remaining_tests(1); // volatile value make an action possible
    }
    log_warn("Caught signal to return to main menu => navigation activated");
}

// Usage : if (skip_remaining_tests_requested)#ifndef LIBRARY_H
#define LIBRARY_H
int skip_remaining_tests_requested(void);
void set_skip_remaining_tests(const int val);
void handle_signal(int signum);
#endif //LIBRARY_H
#include "log.h"
#include <stdarg.h>

static log_level_t g_log_level = LOG_LEVEL_INFO;

static void vlogf(log_level_t lvl, const char* prefix, const char* fmt, va_list ap){
    if(lvl < g_log_level) return;
    fprintf(stderr, "%s", prefix);
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, CLR_RESET "\n");
}

void set_log_level(log_level_t lvl){
    g_log_level = lvl;
}

void log_debug(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_DEBUG, CLR_BLUE"[DEBUG] "CLR_RESET, fmt, ap);
    va_end(ap);
}

void log_info(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_INFO, CLR_GREEN"[INFO]  "CLR_RESET, fmt, ap);
    va_end(ap);
}

void log_warn(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_WARN, CLR_YELLOW"[WARN]  "CLR_RESET, fmt, ap);
    va_end(ap);
}

void log_error(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_ERROR, CLR_RED"[ERROR] "CLR_RESET, fmt, ap);
    va_end(ap);
}
#ifndef LOG_H
#define LOG_H

#include <stdio.h>
#include <stdarg.h>

/* ======== ANSI COLORS ======== */
#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_RED     "\033[31m"
#define CLR_GREEN   "\033[32m"
#define CLR_YELLOW  "\033[33m"
#define CLR_BLUE    "\033[34m"
#define CLR_MAGENTA "\033[35m"
#define CLR_CYAN    "\033[36m"

typedef enum {
    LOG_LEVEL_DEBUG=0,
    LOG_LEVEL_INFO,
    LOG_LEVEL_WARN,
    LOG_LEVEL_ERROR
} log_level_t;

void set_log_level(log_level_t lvl);

void log_debug(const char* fmt, ...);
void log_info(const char* fmt, ...);
void log_warn(const char* fmt, ...);
void log_error(const char* fmt, ...);

#endif
#include <signal.h>
#include "log.h"
#include "scoreboard.h"
#include "tests.h"
#include "library.h"

/**
 * @brief Entry point:
 *  - Loads scoreboard
 *  - Runs all tests (with sub-process + timeout logic)
 *  - Shows final scoreboard
 *  - Returns final numeric score
 */
int main(void){
     /* Set desired log level. */
     set_log_level(LOG_LEVEL_INFO);

     /* Install signal handlers to save scoreboard on INT/TERM. */
     signal(SIGINT, handle_signal);
     signal(SIGTERM, handle_signal);

     /* Load scoreboard (if scoreboard.json exists). */
     scoreboard_load();
     /* Example: we set HPC bonus on by default. */
     scoreboard_set_sc_hpc(1);

     /* Run all tests. Each test logs PASS/FAIL and updates scoreboard. */
     run_all_tests();

     /* Show scoreboard + save it. */
     show_scoreboard();
     scoreboard_save();

     /* Return final integer score as the program exit code. */
     int final_score = scoreboard_get_final_score();
     log_info("Final Score = %d", final_score);
     return final_score;
}
#include "scoreboard.h"
#include "log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../lib/cJSON.h"

/* Our single scoreboard instance. */
static scoreboard_t gSB;

static double calc_percent(int total, int pass){
    if(total == 0) return 0.0;
    return 100.0 * ((double)pass / (double)total);
}

static void recompute(void){
    gSB.basic_percent        = calc_percent(gSB.basic_total,      gSB.basic_pass);
    gSB.normal_percent       = calc_percent(gSB.normal_total,     gSB.normal_pass);
    gSB.edge_percent         = calc_percent(gSB.edge_total,       gSB.edge_pass);
    gSB.hidden_percent       = calc_percent(gSB.hidden_total,     gSB.hidden_pass);
    gSB.wfq_percent          = calc_percent(gSB.wfq_total,        gSB.wfq_pass);
    gSB.multi_hpc_percent    = calc_percent(gSB.multi_hpc_total,  gSB.multi_hpc_pass);
    gSB.bfs_percent          = calc_percent(gSB.bfs_total,        gSB.bfs_pass);
    gSB.mlfq_percent         = calc_percent(gSB.mlfq_total,       gSB.mlfq_pass);
    gSB.prio_preempt_percent = calc_percent(gSB.prio_preempt_total, gSB.prio_preempt_pass);
    gSB.hpc_bfs_percent      = calc_percent(gSB.hpc_bfs_total,    gSB.hpc_bfs_pass);
}

/* Weighted final score example:
   BASIC=10%, NORMAL=10%, EDGE=10%, HIDDEN=10%,
   WFQ=10%, MULTI_HPC=10%, BFS=10%, MLFQ=10%,
   PRIO_PREEMPT=10%, HPC_BFS=10%.
   HPC bonus=+10 if sc_hpc=1, but capped at 100 total.
*/
int scoreboard_get_final_score(void){
    recompute();

    double b    = gSB.basic_percent         * 0.10;
    double n    = gSB.normal_percent        * 0.10;
    double e    = gSB.edge_percent          * 0.10;
    double hi   = gSB.hidden_percent        * 0.10;
    double wf   = gSB.wfq_percent           * 0.10;
    double mh   = gSB.multi_hpc_percent     * 0.10;
    double bf   = gSB.bfs_percent           * 0.10;
    double ml   = gSB.mlfq_percent          * 0.10;
    double pp   = gSB.prio_preempt_percent  * 0.10;
    double hb   = gSB.hpc_bfs_percent       * 0.10;

    double HPC  = (gSB.sc_hpc ? 10.0 : 0.0);

    double total = b + n + e + hi + wf + mh + bf + ml + pp + hb + HPC;
    if(total > 100.0) total = 100.0;

    return (int)(total + 0.5);
}

static void scoreboard_defaults(void){
    memset(&gSB, 0, sizeof(gSB));
    gSB.pass_threshold = 60.0;
}

void scoreboard_load(void){
    scoreboard_defaults();
    FILE* f = fopen("scoreboard.json", "rb");
    if(!f){
        log_warn("No scoreboard.json => defaults");
        return;
    }
    fseek(f, 0, SEEK_END);
    long sz = ftell(f);
    if(sz<0){
        fclose(f);
        return;
    }
    fseek(f, 0, SEEK_SET);
    char* buf = (char*)malloc(sz+1);
    if(!buf){
        fclose(f);
        return;
    }
    if(fread(buf,1,sz,f) != (size_t)sz){
        free(buf);
        fclose(f);
        return;
    }
    buf[sz] = '\0';
    fclose(f);

    cJSON* root = cJSON_Parse(buf);
    free(buf);
    if(!root){
        log_warn("scoreboard parse fail => defaults");
        return;
    }
    #define JGETINT(_o,_n,_v) do{ cJSON*_tmp=cJSON_GetObjectItemCaseSensitive(_o,_n);\
        if(_tmp && cJSON_IsNumber(_tmp)) (_v)=_tmp->valueint;}while(0)
    #define JGETDBL(_o,_n,_v) do{ cJSON*_tmp=cJSON_GetObjectItemCaseSensitive(_o,_n);\
        if(_tmp && cJSON_IsNumber(_tmp)) (_v)=_tmp->valuedouble;}while(0)

    JGETINT(root,"basic_total",           gSB.basic_total);
    JGETINT(root,"basic_pass",            gSB.basic_pass);
    JGETINT(root,"normal_total",          gSB.normal_total);
    JGETINT(root,"normal_pass",           gSB.normal_pass);
    JGETINT(root,"edge_total",            gSB.edge_total);
    JGETINT(root,"edge_pass",             gSB.edge_pass);
    JGETINT(root,"hidden_total",          gSB.hidden_total);
    JGETINT(root,"hidden_pass",           gSB.hidden_pass);
    JGETINT(root,"wfq_total",             gSB.wfq_total);
    JGETINT(root,"wfq_pass",              gSB.wfq_pass);
    JGETINT(root,"multi_hpc_total",       gSB.multi_hpc_total);
    JGETINT(root,"multi_hpc_pass",        gSB.multi_hpc_pass);
    JGETINT(root,"bfs_total",             gSB.bfs_total);
    JGETINT(root,"bfs_pass",              gSB.bfs_pass);
    JGETINT(root,"mlfq_total",            gSB.mlfq_total);
    JGETINT(root,"mlfq_pass",             gSB.mlfq_pass);
    JGETINT(root,"prio_preempt_total",    gSB.prio_preempt_total);
    JGETINT(root,"prio_preempt_pass",     gSB.prio_preempt_pass);
    JGETINT(root,"hpc_bfs_total",         gSB.hpc_bfs_total);
    JGETINT(root,"hpc_bfs_pass",          gSB.hpc_bfs_pass);

    JGETINT(root,"sc_hpc",                gSB.sc_hpc);
    JGETDBL(root,"pass_threshold",        gSB.pass_threshold);

    cJSON_Delete(root);
    log_info("Scoreboard loaded");
}

void scoreboard_save(void){
    cJSON* root = cJSON_CreateObject();
    #define JADDINT(_o,_n,_v) cJSON_AddNumberToObject(_o,_n,(double)(_v))
    #define JADDDBL(_o,_n,_v) cJSON_AddNumberToObject(_o,_n,(_v))

    JADDINT(root,"basic_total",        gSB.basic_total);
    JADDINT(root,"basic_pass",         gSB.basic_pass);
    JADDINT(root,"normal_total",       gSB.normal_total);
    JADDINT(root,"normal_pass",        gSB.normal_pass);
    JADDINT(root,"edge_total",         gSB.edge_total);
    JADDINT(root,"edge_pass",          gSB.edge_pass);
    JADDINT(root,"hidden_total",       gSB.hidden_total);
    JADDINT(root,"hidden_pass",        gSB.hidden_pass);
    JADDINT(root,"wfq_total",          gSB.wfq_total);
    JADDINT(root,"wfq_pass",           gSB.wfq_pass);
    JADDINT(root,"multi_hpc_total",    gSB.multi_hpc_total);
    JADDINT(root,"multi_hpc_pass",     gSB.multi_hpc_pass);
    JADDINT(root,"bfs_total",          gSB.bfs_total);
    JADDINT(root,"bfs_pass",           gSB.bfs_pass);
    JADDINT(root,"mlfq_total",         gSB.mlfq_total);
    JADDINT(root,"mlfq_pass",          gSB.mlfq_pass);
    JADDINT(root,"prio_preempt_total", gSB.prio_preempt_total);
    JADDINT(root,"prio_preempt_pass",  gSB.prio_preempt_pass);
    JADDINT(root,"hpc_bfs_total",      gSB.hpc_bfs_total);
    JADDINT(root,"hpc_bfs_pass",       gSB.hpc_bfs_pass);

    JADDINT(root,"sc_hpc",             gSB.sc_hpc);
    JADDDBL(root,"pass_threshold",     gSB.pass_threshold);

    char* out = cJSON_Print(root);
    cJSON_Delete(root);

    FILE* f = fopen("scoreboard.json","wb");
    if(!f){
        log_error("Cannot write scoreboard.json");
        free(out);
        return;
    }
    fwrite(out, 1, strlen(out), f);
    fclose(f);
    free(out);
    log_info("Scoreboard saved");
}

void scoreboard_clear(void){
    scoreboard_defaults();
    scoreboard_save();
}

void scoreboard_update_basic(int t,int p){
    gSB.basic_total += t;
    gSB.basic_pass  += p;
}
void scoreboard_update_normal(int t,int p){
    gSB.normal_total += t;
    gSB.normal_pass  += p;
}
void scoreboard_update_edge(int t,int p){
    gSB.edge_total  += t;
    gSB.edge_pass   += p;
}
void scoreboard_update_hidden(int t,int p){
    gSB.hidden_total += t;
    gSB.hidden_pass  += p;
}
void scoreboard_update_wfq(int t,int p){
    gSB.wfq_total += t;
    gSB.wfq_pass  += p;
}
void scoreboard_update_multi_hpc(int t,int p){
    gSB.multi_hpc_total += t;
    gSB.multi_hpc_pass  += p;
}
void scoreboard_update_bfs(int t,int p){
    gSB.bfs_total += t;
    gSB.bfs_pass  += p;
}
void scoreboard_update_mlfq(int t,int p){
    gSB.mlfq_total += t;
    gSB.mlfq_pass  += p;
}
void scoreboard_update_prio_preempt(int t,int p){
    gSB.prio_preempt_total += t;
    gSB.prio_preempt_pass  += p;
}
void scoreboard_update_hpc_bfs(int t,int p){
    gSB.hpc_bfs_total += t;
    gSB.hpc_bfs_pass  += p;
}

void scoreboard_set_sc_hpc(int v){
    gSB.sc_hpc = (v ? 1 : 0);
}

/*
   Unlock logic can be used if you want gating rules
   (not strictly used in the new design).
*/
int scoreboard_is_unlocked(scoreboard_suite_t s){
    recompute();
    const double T = gSB.pass_threshold;
    switch(s){
        case SUITE_BASIC:       return 1;
        case SUITE_NORMAL:      return (gSB.basic_percent >= T);
        case SUITE_EDGE:        return (gSB.normal_percent >= T);
        case SUITE_HIDDEN:      return (gSB.edge_percent >= T);
        case SUITE_WFQ:         return (gSB.hidden_percent >= T);
        case SUITE_MULTI_HPC:   return (gSB.wfq_percent   >= T);
        case SUITE_BFS:         return (gSB.normal_percent>= T);
        case SUITE_MLFQ:        return (gSB.normal_percent>= T);
        case SUITE_PRIO_PREEMPT:return (gSB.edge_percent  >= T);
        case SUITE_HPC_BFS:     return (gSB.hidden_percent>= T);
        default: return 0;
    }
}

void get_scoreboard(scoreboard_t* out){
    if(out) *out = gSB;
}

void show_scoreboard(void){
    scoreboard_t sb;
    get_scoreboard(&sb);
    int final = scoreboard_get_final_score();

    printf("\n===== SCOREBOARD =====\n");
    printf(" BASIC     => %d/%d => %.1f%%\n",
         sb.basic_pass, sb.basic_total, sb.basic_percent);
    printf(" NORMAL    => %d/%d => %.1f%%\n",
         sb.normal_pass, sb.normal_total, sb.normal_percent);
    printf(" EDGE      => %d/%d => %.1f%%\n",
         sb.edge_pass, sb.edge_total, sb.edge_percent);
    printf(" HIDDEN    => %d/%d => %.1f%%\n",
         sb.hidden_pass, sb.hidden_total, sb.hidden_percent);
    printf(" WFQ       => %d/%d => %.1f%%\n",
         sb.wfq_pass, sb.wfq_total, sb.wfq_percent);
    printf(" MULTI_HPC => %d/%d => %.1f%%\n",
         sb.multi_hpc_pass, sb.multi_hpc_total, sb.multi_hpc_percent);
    printf(" BFS       => %d/%d => %.1f%%\n",
         sb.bfs_pass, sb.bfs_total, sb.bfs_percent);
    printf(" MLFQ      => %d/%d => %.1f%%\n",
         sb.mlfq_pass, sb.mlfq_total, sb.mlfq_percent);
    printf(" PRIO_PREEMPT => %d/%d => %.1f%%\n",
         sb.prio_preempt_pass, sb.prio_preempt_total, sb.prio_preempt_percent);
    printf(" HPC_BFS   => %d/%d => %.1f%%\n",
         sb.hpc_bfs_pass, sb.hpc_bfs_total, sb.hpc_bfs_percent);
    printf(" HPC Bonus => %s\n", (sb.sc_hpc ? "YES" : "NO"));
    printf(" Final Weighted Score => %d\n", final);
    printf("=======================\n");
}
#ifndef SCOREBOARD_H
#define SCOREBOARD_H

typedef enum {
    SUITE_BASIC=1,
    SUITE_NORMAL,
    SUITE_EDGE,
    SUITE_HIDDEN,
    SUITE_WFQ,
    SUITE_MULTI_HPC,
    SUITE_BFS,
    SUITE_MLFQ,
    SUITE_PRIO_PREEMPT,
    SUITE_HPC_BFS
} scoreboard_suite_t;

typedef struct {
    int basic_total,      basic_pass;
    int normal_total,     normal_pass;
    int edge_total,       edge_pass;
    int hidden_total,     hidden_pass;
    int wfq_total,        wfq_pass;
    int multi_hpc_total,  multi_hpc_pass;
    int bfs_total,        bfs_pass;
    int mlfq_total,       mlfq_pass;
    int prio_preempt_total, prio_preempt_pass;
    int hpc_bfs_total,      hpc_bfs_pass;

    double basic_percent,
           normal_percent,
           edge_percent,
           hidden_percent,
           wfq_percent,
           multi_hpc_percent,
           bfs_percent,
           mlfq_percent,
           prio_preempt_percent,
           hpc_bfs_percent;

    double pass_threshold;
    int    sc_hpc;
} scoreboard_t;

/* Loading, saving, clearing scoreboard */
void scoreboard_load(void);
void scoreboard_save(void);
void scoreboard_clear(void);

/* Updating scoreboard from test results */
void scoreboard_update_basic(int t,int p);
void scoreboard_update_normal(int t,int p);
void scoreboard_update_edge(int t,int p);
void scoreboard_update_hidden(int t,int p);
void scoreboard_update_wfq(int t,int p);
void scoreboard_update_multi_hpc(int t,int p);
void scoreboard_update_bfs(int t,int p);
void scoreboard_update_mlfq(int t,int p);
void scoreboard_update_prio_preempt(int t,int p);
void scoreboard_update_hpc_bfs(int t,int p);

/* HPC bonus switch */
void scoreboard_set_sc_hpc(int v);

/* For gating logic (if you want to lock/unlock certain tests). */
int scoreboard_is_unlocked(scoreboard_suite_t s);

void get_scoreboard(scoreboard_t* out);
int  scoreboard_get_final_score(void);
void show_scoreboard(void);

#endif
#include "concurrency.h"
#include "tests.h"
#include "scoreboard.h"
#include "log.h"
#include <sys/wait.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

/*
  Each test is run in a child process with a TIMEOUT
  to avoid indefinite blocking. If the child times out,
  we kill it => test FAIL => move on.
*/

/* A small helper to wait up to N seconds for the child to finish. */
static bool do_wait_with_timeout(pid_t pid, int timeout_sec, int *exit_code){
    int status;
    for(int i=0; i < timeout_sec*10; i++){
        pid_t w = waitpid(pid, &status, WNOHANG);
        if(w == pid){
            if(WIFEXITED(status)){
                *exit_code = WEXITSTATUS(status);
                return true;
            } else {
                /* e.g. if child was killed by signal */
                *exit_code = 1; /* fail */
                return true;
            }
        }
        usleep(100000); /* 0.1s */
    }
    /* Timed out => kill child => test fail */
    kill(pid, SIGKILL);
    waitpid(pid, &status, 0);
    *exit_code = 1;
    return false;
}

/**
 * @brief Helper to run test_func() in a child with a timeout.
 *
 * @param test_name    name of the test (for logging)
 * @param test_func    function returning `bool` (true=pass, false=fail)
 * @param suite        scoreboard suite enum
 * @param timeout_sec  kill after these many seconds
 * @return true if pass, false if fail
 */
static bool run_test_in_subproc(
    const char* test_name,
    bool (*test_func)(void),
    scoreboard_suite_t suite,
    int timeout_sec)
{
    pid_t pid = fork();
    if(pid < 0){
        log_error("fork() failed => cannot run test %s", test_name);
        return false;
    }
    if(pid == 0){
        /* Child: just run the test function. */
        bool pass = test_func();
        _exit(pass ? 0 : 1);
    }

    /* Parent: wait up to timeout_sec for child to exit. */
    int exit_code = 1;
    bool finished = do_wait_with_timeout(pid, timeout_sec, &exit_code);

    bool pass = false;
    if(!finished){
        /* We had to kill it => TIMEOUT => fail. */
        log_error("%s => TIMEOUT => FAIL", test_name);
    } else {
        pass = (exit_code == 0);
        if(pass){
            log_info("%s PASS", test_name);
        } else {
            log_error("%s FAIL", test_name);
        }
    }

    /* Update scoreboard for this suite.
       We consider 1 test, pass or fail => (t=1, p=(pass?1:0)). */
    int t = 1, p = pass ? 1 : 0;
    switch(suite){
        case SUITE_BASIC:        scoreboard_update_basic(t,p);         break;
        case SUITE_NORMAL:       scoreboard_update_normal(t,p);        break;
        case SUITE_EDGE:         scoreboard_update_edge(t,p);          break;
        case SUITE_HIDDEN:       scoreboard_update_hidden(t,p);        break;
        case SUITE_WFQ:          scoreboard_update_wfq(t,p);           break;
        case SUITE_MULTI_HPC:    scoreboard_update_multi_hpc(t,p);     break;
        case SUITE_BFS:          scoreboard_update_bfs(t,p);           break;
        case SUITE_MLFQ:         scoreboard_update_mlfq(t,p);          break;
        case SUITE_PRIO_PREEMPT: scoreboard_update_prio_preempt(t,p);  break;
        case SUITE_HPC_BFS:      scoreboard_update_hpc_bfs(t,p);       break;
        default: break;
    }
    return pass;
}

/* Helper: check if all given processes are done. */
static bool all_done(const process_t* arr, int count){
    for(int i=0;i<count;i++){
        if(arr[i].remaining_time>0) return false;
    }
    return true;
}


/* ------------------------------------------------------------------------
   TEST IMPLEMENTATIONS (child side).
   They each return bool: true => pass, false => fail.

   We show them in a simpler manner.
   Some only check that the processes finish.
   Some can do extra timeline checks if you wish.
------------------------------------------------------------------------ */

/* 1) Basic FIFO test. */
static bool test_basic_fifo_impl(void){
    log_info("Running test_basic_fifo");
    process_t p[2];
    init_process(&p[0], 3, 5, 0, 1.0);
    init_process(&p[1], 5, 7, 2, 1.0);

    container_t c;
    container_init(&c, 1, 0, ALG_FIFO, ALG_NONE, p, 2, NULL, 0, 20);

    /* Run single container. */
    orchestrator_run(&c, 1);

    /* Check if all done. */
    return all_done(p, 2);
}

/* 2) Round Robin normal test. */
static bool test_normal_rr_impl(void){
    log_info("Running test_normal_rr");
    process_t p[2];
    init_process(&p[0], 4, 3, 0, 1.0);
    init_process(&p[1], 2, 2, 1, 1.0);

    container_t c;
    container_init(&c, 2, 0, ALG_RR, ALG_NONE, p, 2, NULL, 0, 20);

    orchestrator_run(&c, 1);
    return all_done(p,2);
}

/* 3) Priority scheduling (non-preemptive). */
static bool test_edge_priority_impl(void){
    log_info("Running test_edge_priority");
    process_t p[3];
    init_process(&p[0], 2, 1, 0, 1.0);
    init_process(&p[1], 4, 5, 0, 1.0);
    init_process(&p[2], 2, 2, 1, 1.0);

    container_t c;
    container_init(&c, 1, 0, ALG_PRIORITY, ALG_NONE, p, 3, NULL, 0, 30);

    orchestrator_run(&c, 1);
    return all_done(p,3);
}

/* 4) HPC hidden test => SJF + HPC. */
static bool test_hidden_hpc_impl(void){
    log_info("Running test_hidden_hpc");
    process_t mp[2];
    init_process(&mp[0], 5, 2, 0, 1.0);
    init_process(&mp[1], 5, 1, 2, 1.0);

    process_t hp[1];
    init_process(&hp[0], 6, 1, 1, 1.0);

    container_t c;
    container_init(&c, 1, 1, ALG_SJF, ALG_HPC, mp, 2, hp, 1, 30);

    orchestrator_run(&c, 1);
    return (all_done(mp,2) && all_done(hp,1));
}

/* 5) Weighted Fair Queueing test. */
static bool test_wfq_impl(void){
    log_info("Running test_wfq");
    process_t p[3];
    init_process(&p[0], 6, 0, 0, 2.0);
    init_process(&p[1], 4, 0, 0, 1.0);
    init_process(&p[2], 3, 0, 2, 3.0);

    container_t c;
    container_init(&c, 2, 0, ALG_WFQ, ALG_NONE, p, 3, NULL, 0, 40);

    orchestrator_run(&c, 1);
    return all_done(p,3);
}

/* 6) Multiple HPC threads. */
static bool test_multi_hpc_impl(void){
    log_info("Running test_multi_hpc");
    process_t mp[2];
    init_process(&mp[0], 5, 2, 0, 1.0);
    init_process(&mp[1], 5, 1, 0, 1.0);

    process_t hp[3];
    init_process(&hp[0], 3, 2, 0, 2.0);
    init_process(&hp[1], 4, 2, 1, 1.0);
    init_process(&hp[2], 5, 1, 2, 1.5);

    container_t c;
    container_init(&c, 2, 2, ALG_RR, ALG_HPC, mp, 2, hp, 3, 50);

    orchestrator_run(&c, 1);
    return (all_done(mp,2) && all_done(hp,3));
}

/* 7) BFS scheduling. */
static bool test_bfs_scheduling_impl(void){
    log_info("Running test_bfs_scheduling");
    process_t p[3];
    init_process(&p[0], 3, 0, 0, 1.0);
    init_process(&p[1], 8, 0, 0, 1.0);
    init_process(&p[2], 6, 0, 2, 1.0);

    container_t c;
    container_init(&c, 1, 0, ALG_BFS, ALG_NONE, p, 3, NULL, 0, 50);

    orchestrator_run(&c, 1);
    return all_done(p,3);
}

/* 8) MLFQ scheduling. */
static bool test_mlfq_scheduling_impl(void){
    log_info("Running test_mlfq_scheduling");
    process_t p[3];
    init_process(&p[0], 10, 0, 0, 1.0);
    init_process(&p[1], 5, 0, 0, 1.0);
    init_process(&p[2], 7, 0, 3, 1.0);

    container_t c;
    container_init(&c, 2, 0, ALG_MLFQ, ALG_NONE, p, 3, NULL, 0, 80);

    orchestrator_run(&c, 1);
    return all_done(p,3);
}

/* 9) Preemptive Priority scheduling. */
static bool test_preemptive_priority_impl(void){
    log_info("Running test_preemptive_priority");
    process_t p[3];
    init_process(&p[0], 8, 5, 0, 1.0);
    init_process(&p[1], 3, 1, 3, 1.0);
    init_process(&p[2], 2,10, 2, 1.0);

    container_t c;
    container_init(&c, 1, 0, ALG_PRIO_PREEMPT, ALG_NONE, p, 3, NULL, 0, 50);

    orchestrator_run(&c, 1);
    return all_done(p,3);
}

/* 10) HPC BFS test => HPC with BFS, 0 main cores + main processes => HPC steals them. */
static bool test_hpc_bfs_impl(void){
    log_info("Running test_hpc_bfs");
    process_t mainP[1];
    init_process(&mainP[0], 4, 0, 0, 1.0);

    process_t hpcP[2];
    init_process(&hpcP[0], 3, 0, 1, 1.0);
    init_process(&hpcP[1], 4, 0, 2, 1.0);

    container_t c;
    /* 0 main cores, 2 HPC threads => BFS on HPC side.
       container_init sees there's 1 main process but 0 cores => c->allow_hpc_steal=true
       => HPC BFS threads can run that main process.
    */
    container_init(&c, 0, 2, ALG_NONE, ALG_BFS, mainP, 1, hpcP, 2, 40);

    orchestrator_run(&c, 1);

    return (all_done(mainP,1) && all_done(hpcP,2));
}

/* ------------------------------------------------------------------------
   run_all_tests()
   Launch each test in a subproc with 5s timeout.
------------------------------------------------------------------------ */
void run_all_tests(void){
    run_test_in_subproc("test_basic_fifo",          test_basic_fifo_impl,         SUITE_BASIC,       5);
    run_test_in_subproc("test_normal_rr",           test_normal_rr_impl,          SUITE_NORMAL,      5);
    run_test_in_subproc("test_edge_priority",       test_edge_priority_impl,      SUITE_EDGE,        5);
    run_test_in_subproc("test_hidden_hpc",          test_hidden_hpc_impl,         SUITE_HIDDEN,      5);
    run_test_in_subproc("test_wfq",                 test_wfq_impl,                SUITE_WFQ,         5);
    run_test_in_subproc("test_multi_hpc",           test_multi_hpc_impl,          SUITE_MULTI_HPC,   5);
    run_test_in_subproc("test_bfs_scheduling",      test_bfs_scheduling_impl,     SUITE_BFS,         5);
    run_test_in_subproc("test_mlfq_scheduling",     test_mlfq_scheduling_impl,    SUITE_MLFQ,        5);
    run_test_in_subproc("test_preemptive_priority", test_preemptive_priority_impl,SUITE_PRIO_PREEMPT,5);
    run_test_in_subproc("test_hpc_bfs",             test_hpc_bfs_impl,            SUITE_HPC_BFS,     5);

    /* Each test logs pass/fail individually. The scoreboard is updated. */
}
#ifndef TESTS_H
#define TESTS_H

/**
 * @brief Run all test cases.
 */
void run_all_tests(void);

#endif
