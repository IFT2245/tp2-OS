#include <stdlib.h>
#include "safe_calls_library.h"

/* ----------------------------------------------------------------
   MAIN
   ----------------------------------------------------------------
*/
int main(const int argc, char** argv) {
    (void)argc;
    (void)argv;

    scoreboard_init();
    scoreboard_load();
    os_init();
    stats_init();

    /* Register signals */
    signal(SIGINT,  handle_signal);
    signal(SIGTERM, handle_signal);

    /* Enter the main menu loop (never returns unless user chooses Exit) */
    menu_main_loop();

    /* If we ever break out, do final cleanup. */
    const int fs = scoreboard_get_final_score();
    cleanup_and_exit(fs);
    /* No code below here is reachable. */
    return 0;
}
#include "menu.h"

/* ----------------------------------------------------------------
   SHARED UTILS
   ----------------------------------------------------------------
*/
void pause_enter(void) {
    printf(CLR_CYAN CLR_BOLD "\nPress ENTER to continue..." CLR_RESET);
    fflush(stdout);
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        /* discard leftover */
    }
}

ssize_t read_line(char *buf, const size_t sz) {
    if (os_concurrency_stop_requested()) {
        return 0;
    }

    if (buf == NULL || sz == 0 || sz > INT_MAX) {
        return 0;
    }

    if (fgets(buf, (int)sz, stdin) == NULL) {
        if (ferror(stdin)) {
            clearerr(stdin);
        }
        return 0;
    }

    size_t newline_pos = strcspn(buf, "\n");
    buf[newline_pos] = '\0';
    return 1;
}

/* Display scoreboard in a framed format. */
void menu_show_scoreboard(void) {
    scoreboard_t sb;
    get_scoreboard(&sb);

    printf(CLR_BOLD CLR_MAGENTA "╔════════════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_MAGENTA "║           ★ SCOREBOARD OVERVIEW ★          ║\n" CLR_RESET);
    printf("║--------------------------------------------║\n");

    /* Show each suite's pass% plus locked/unlocked. */
    int unlockedB      = scoreboard_is_unlocked(SUITE_BASIC);
    int unlockedN      = scoreboard_is_unlocked(SUITE_NORMAL);
    int unlockedExt    = scoreboard_is_unlocked(SUITE_EXTERNAL);
    int unlockedModes  = scoreboard_is_unlocked(SUITE_MODES);
    int unlockedEdge   = scoreboard_is_unlocked(SUITE_EDGE);
    int unlockedHidden = scoreboard_is_unlocked(SUITE_HIDDEN);

    printf("║ BASIC       => %.1f/100 => %s\n",
           sb.basic_percent,
           unlockedB ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ NORMAL      => %.1f/100 => %s\n",
           sb.normal_percent,
           unlockedN ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ EXTERNAL    => %.1f/100 => %s\n",
           sb.external_percent,
           unlockedExt ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ MODES       => %.1f/100 => %s\n",
           sb.modes_percent,
           unlockedModes ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ EDGE        => %.1f/100 => %s\n",
           sb.edge_percent,
           unlockedEdge ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ HIDDEN      => %.1f/100 => %s\n",
           sb.hidden_percent,
           unlockedHidden ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║--------------------------------------------║\n");
    printf("║  FIFO:%s RR:%s CFS:%s CFS-SRTF:%s BFS:%s\n",
           sb.sc_fifo? "✔":"✘",
           sb.sc_rr? "✔":"✘",
           sb.sc_cfs? "✔":"✘",
           sb.sc_cfs_srtf? "✔":"✘",
           sb.sc_bfs? "✔":"✘");
    printf("║  SJF:%s STRF:%s HRRN:%s HRRN-RT:%s PRIORITY:%s\n",
           sb.sc_sjf? "✔":"✘",
           sb.sc_strf? "✔":"✘",
           sb.sc_hrrn? "✔":"✘",
           sb.sc_hrrn_rt? "✔":"✘",
           sb.sc_priority? "✔":"✘");
    printf("║  HPC-OVER:%s MLFQ:%s\n",
           sb.sc_hpc_over? "✔":"✘",
           sb.sc_mlfq? "✔":"✘");
    printf("║--------------------------------------------║\n");

    /* final overall score with a progress bar. */
    const int final_score = scoreboard_get_final_score();
    printf("╠═" CLR_BOLD CLR_CYAN " Overall Score => " CLR_RESET CLR_BOLD CLR_RED "%d/100\n" CLR_RESET, final_score);
    printf("╠═" CLR_BOLD CLR_CYAN " Progress: " CLR_RESET);
    int barLength = final_score / 10;
    printf("[");
    for(int i=0; i<barLength; i++){
        printf("█");
    }
    for(int i=barLength; i<10; i++){
        printf(" ");
    }
    printf("]" CLR_RED "%d%%\n" CLR_RESET, final_score);

    printf("╚════════════════════════════════════════════╝\n");

    pause_enter();
}

void menu_clear_scoreboard(void) {
    scoreboard_clear();
    printf(CLR_BOLD CLR_CYAN "\n╔════════════════════════════════════════════╗\n");
    printf("║ Scoreboard cleared.                        ║\n");
    printf("╚════════════════════════════════════════════╝\n" CLR_RESET);
    pause_enter();
}

void menu_toggle_speed_mode(void) {
    int current = stats_get_speed_mode();
    int next    = (current == 0) ? 1 : 0;
    stats_set_speed_mode(next);

    printf(CLR_BOLD CLR_CYAN "\n╔═════════════════════════════════════╗\n");
    printf("║ Speed mode set to: %s\n", (next == 0) ? "NORMAL" : "FAST");
    printf("╚═════════════════════════════════════╝\n" CLR_RESET);

    pause_enter();
}

/*
   Submenu that asks user to pick a single test from a chosen suite
   => runs exactly that test.
*/
void submenu_run_single_test(void) {
    printf(CLR_BOLD CLR_CYAN "╔════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN "║ RUN SINGLE TEST - SUITE SELECTION  ║\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN "╚════════════════════════════════════╝\n" CLR_RESET);

    /* We'll hide locked ones (except BASIC which is always unlocked). */
    scoreboard_t sb;
    get_scoreboard(&sb);

    const int unlockedN      = scoreboard_is_unlocked(SUITE_NORMAL);
    const int unlockedExt    = scoreboard_is_unlocked(SUITE_EXTERNAL);
    const int unlockedModes  = scoreboard_is_unlocked(SUITE_MODES);
    const int unlockedEdge   = scoreboard_is_unlocked(SUITE_EDGE);
    const int unlockedHidden = scoreboard_is_unlocked(SUITE_HIDDEN);

    /* Build a list of possible choices for user. We'll do a simple numeric menu. */
    /* We'll store { "BASIC", SUITE_BASIC } first, always. Then conditionally others. */
    struct {
        char label[32];
        scoreboard_suite_t suite;
    } items[6];
    int count=0;

    /* 1) BASIC => always visible */
    strcpy(items[count].label, "Basic");
    items[count].suite = SUITE_BASIC;
    count++;

    /* 2) Normal => only if unlocked */
    if(unlockedN) {
        strcpy(items[count].label, "Normal");
        items[count].suite = SUITE_NORMAL;
        count++;
    }
    /* 3) External => only if unlocked */
    if(unlockedExt) {
        strcpy(items[count].label, "External");
        items[count].suite = SUITE_EXTERNAL;
        count++;
    }
    /* 4) Modes => only if unlocked */
    if(unlockedModes) {
        strcpy(items[count].label, "Modes");
        items[count].suite = SUITE_MODES;
        count++;
    }
    /* 5) Edge => only if unlocked */
    if(unlockedEdge) {
        strcpy(items[count].label, "Edge");
        items[count].suite = SUITE_EDGE;
        count++;
    }
    /* 6) Hidden => only if unlocked */
    if(unlockedHidden) {
        strcpy(items[count].label, "Hidden");
        items[count].suite = SUITE_HIDDEN;
        count++;
    }

    if(count==0) {
        printf(CLR_GREEN"\nNo suites are available\n"CLR_RESET);
        pause_enter();
        return;
    }

    printf(CLR_YELLOW"Choose which unlocked suite to run a single test:\n"CLR_RESET);
    for(int i=0; i<count; i++){
        printf(" %d) %s\n", i+1, items[i].label);
    }
    printf(CLR_YELLOW CLR_BOLD"Choice: "CLR_RESET);

    char buf[256];
    if(!read_line(buf, sizeof(buf))) return;
    int pick = parse_int_strtol(buf, -1);
    if(pick<1 || pick>count) {
        printf(CLR_RED"Invalid.\n"CLR_RESET);
        pause_enter();
        return;
    }

    scoreboard_suite_t chosen = items[pick-1].suite;

    /* Now we ask how many tests in that suite => ask user which single test => run. */
    run_single_test_in_suite(chosen); /* from old main.c logic, but we place in runner. */

    pause_enter();
}

/*
   "Run All Unlocked Test Suites" => skip re-running the ones already at 100%
   and skip locked ones.
   We stop if user sends SIGTERM.
*/
void submenu_run_tests(void) {
    /* We'll iterate over the chain in order: BASIC->NORMAL->EXTERNAL->MODES->EDGE->HIDDEN */
    scoreboard_t sb;
    get_scoreboard(&sb);

    printf(CLR_BOLD CLR_CYAN "╔═══════════════════════════════════════════╗\n");
    printf("║     Running all available tests \n");
    printf("╚═══════════════════════════════════════════╝\n" CLR_RESET);

    scoreboard_load(); /* refresh scoreboard just in case */

    scoreboard_suite_t chain[] = {
        SUITE_BASIC,
        SUITE_NORMAL,
        SUITE_EXTERNAL,
        SUITE_MODES,
        SUITE_EDGE,
        SUITE_HIDDEN
    };
    int chain_count = 6;

    for(int i=0; i<chain_count; i++){
        scoreboard_suite_t st = chain[i];
        if(!scoreboard_is_unlocked(st)) {
            /* skip locked */
            continue;
        }


        /* skip if that suite is already at 100% pass. */
        double suite_score=0.0;
        switch(st){
        case SUITE_BASIC:    suite_score = sb.basic_percent;    break;
        case SUITE_NORMAL:   suite_score = sb.normal_percent;   break;
        case SUITE_EXTERNAL: suite_score = sb.external_percent; break;
        case SUITE_MODES:    suite_score = sb.modes_percent;    break;
        case SUITE_EDGE:     suite_score = sb.edge_percent;     break;
        case SUITE_HIDDEN:   suite_score = sb.hidden_percent;   break;
        default: break;
        }
        if(suite_score>=100.0) {
            /* no need to re-run it */
            continue;
        }

        if(os_concurrency_stop_requested()) {
            printf(CLR_RED" caught SIGTERM => Leaving before next suite\n"CLR_RED);
            break;
        }

        /* run the entire suite now */
        run_entire_suite(st);

        /* check if user wants to do next suite if it got unlocked => handle in attempt_run_next_suite */
        /* But the instructions also say: "when basic mode is done or another level, user should be able to refuse next level."
           That logic is in attempt_run_next_suite internally. We also do it after each run.
        */
        scoreboard_load(); /* refresh scoreboard after the run */
        attempt_run_next_suite(st);
    }

    pause_enter();
}

/*
   Attempt to automatically run next suite if newly unlocked.
   We ask user "do you want to run the next suite immediately (y/n)?"
   If "n", we skip to next.
   If "y", we directly run that suite, then chain further if more is unlocked.
*/
void attempt_run_next_suite(scoreboard_suite_t currentSuite) {
    scoreboard_suite_t chain[] = {
        SUITE_BASIC,
        SUITE_NORMAL,
        SUITE_EXTERNAL,
        SUITE_MODES,
        SUITE_EDGE,
        SUITE_HIDDEN
    };
    int chain_count = 6;

    int found_idx = -1;
    for(int i=0; i<chain_count; i++){
        if(chain[i] == currentSuite){
            found_idx = i;
            break;
        }
    }
    if(found_idx<0 || found_idx==(chain_count-1)) {
        /* Not found, or last suite => no next. */
        return;
    }
    scoreboard_suite_t next = chain[found_idx+1];
    if(!scoreboard_is_unlocked(next)) {
        return; /* not unlocked => do nothing */
    }

    /* So the next suite *is* unlocked => ask user if they want to run it now. */
    printf(CLR_BOLD CLR_GREEN "\n┌───────────────────────────────────────────────────────────┐\n");
    printf("│" CLR_GREEN " Good job! Next suite is now unlocked" CLR_RESET "                │\n");
    printf("│" CLR_GREEN CLR_BOLD " Do you want to run the next suite immediately? (y/n)" CLR_RESET "      │\n");
    printf("└───────────────────────────────────────────────────────────┘\n" CLR_RESET);
    printf(CLR_YELLOW CLR_BOLD"Choice: "CLR_RESET);

    char buf[256];
    if(!read_line(buf, sizeof(buf))) {
        return;
    }
    if(buf[0] == 'y' || buf[0] == 'Y') {
        /* directly run that suite now. */
        run_entire_suite(next);
        /* that might unlock the suite after that => chain again. */
        attempt_run_next_suite(next);
    } else {
        /* skip to next. */
        menu_main_loop();
    }
}

/*
   Submenu for external concurrency (only if EXTERNAL suite is >= 60%).
*/
void menu_submenu_external_concurrency(void) {
    int unlockedExt = scoreboard_is_unlocked(SUITE_EXTERNAL);
    if(!unlockedExt) {
        printf(CLR_BOLD CLR_RED "\n[External Concurrency] is locked (need 60%% pass on EXTERNAL suite).\n" CLR_RESET);
        pause_enter();
        return;
    }

    printf(CLR_BOLD CLR_CYAN "\n╔════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "║  External Shell Concurrency Menu   ║\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "╚════════════════════════════════════╝\n" CLR_RESET);

    printf("1) Run concurrency with a SINGLE scheduling mode\n");
    printf("2) Run concurrency with ALL scheduling modes\n");
    printf("\nChoice: ");

    char buf[256];
    if(!read_line(buf, sizeof(buf))) return;
    int sub = parse_int_strtol(buf, -1);
    if(sub < 1 || sub > 2){
        printf("Invalid.\n");
        pause_enter();
        return;
    }

    printf("How many concurrent shells? ");
    if(!read_line(buf, sizeof(buf))) return;
    int n = parse_int_strtol(buf, 0);
    if(n<1){
        printf("Invalid number of shells.\n");
        pause_enter();
        return;
    }

    printf("How many CPU cores? ");
    if(!read_line(buf, sizeof(buf))) return;
    int c = parse_int_strtol(buf, 2);
    if(c<1) c=2;

    printf("\nChoose concurrency test style:\n");
    printf(" 1) Short test\n");
    printf(" 2) Medium test\n");
    printf(" 3) Stress test\n");
    printf("Choice: ");
    if(!read_line(buf,sizeof(buf))) return;
    int style = parse_int_strtol(buf,1);
    if(style<1 || style>3) style=1;

    char** lines = (char**)calloc(n, sizeof(char*));
    if(!lines) return;

    set_os_concurrency_stop_flag(0);

    int base=2;
    switch(style) {
        case 1: base=2;  break;  /* short */
        case 2: base=6;  break;  /* medium */
        case 3: base=30; break;  /* stress */
        default: base=2; break;
    }

    /* Build commands for each shell: "sleep X" */
    for(int i=0; i<n; i++){
        char tmp[64];
        if(sub == 1) {
            /* single mode => small differences in durations */
            snprintf(tmp, sizeof(tmp), "sleep %d", (i+1)*base);
        } else {
            /* all modes => short uniform sleeps */
            snprintf(tmp, sizeof(tmp), "sleep %d", (i+1)*2);
        }
        lines[i] = strdup(tmp);
    }

    if(sub==1){
        printf(CLR_BOLD CLR_YELLOW "0" CLR_RESET "=" CLR_CYAN "FIRST IN FIRST OUT\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "1" CLR_RESET "=" CLR_CYAN "ROUND ROBIN\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "2" CLR_RESET "=" CLR_CYAN "COMPLETELY FAIR SCHEDULER CFS\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "3" CLR_RESET "=" CLR_CYAN "CFS SHORTEST REMAINING TIME FIRST\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "4" CLR_RESET "=" CLR_CYAN "BRAIN FAIR SCHEDULER\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "5" CLR_RESET "=" CLR_CYAN "SHORTEST JOB FIRST\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "6" CLR_RESET "=" CLR_CYAN "SHORTEST TIME REMAINING FIRST\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "7" CLR_RESET "=" CLR_CYAN "HIGHEST RESPONSE RATIO NEXT\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "8" CLR_RESET "=" CLR_CYAN "HIGHEST RESPONSE RATIO NEXT WITH REMAINING TIME\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "9" CLR_RESET "=" CLR_CYAN "PRIORITY SCHEDULING\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "10" CLR_RESET "=" CLR_CYAN "HIGH PERFORMANCE COMPUTING OVERLAY\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "11" CLR_RESET "=" CLR_CYAN "MULTI-LEVEL FEEDBACK QUEUE\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW"Choice: "CLR_RESET);
        if(!read_line(buf,sizeof(buf))){
            pause_enter();
            for(int i=0;i<n;i++) free(lines[i]);
            free(lines);
            return;
        }
        const int mode = parse_int_strtol(buf, -1);
        if(mode<0 || mode>11){
            printf("Invalid mode.\n");
            pause_enter();
        } else {
            run_shell_commands_concurrently(n, lines, c, mode, 0);
        }
    } else {
        /* run with all modes => pass -1, allModes=1 */
        run_shell_commands_concurrently(n, lines, c, -1, 1);
    }

    for(int i=0; i<n; i++){
        free(lines[i]);
    }
    free(lines);

    pause_enter();
}

/*
   The menu option for external tests => only if EXTERNAL suite is unlocked.
*/
static void menu_run_external_tests(void) {
    if(!scoreboard_is_unlocked(SUITE_EXTERNAL)) {
        printf(CLR_RED"External tests locked\n"CLR_RESET);
        pause_enter();
        return;
    }
    printf(CLR_CYAN"\nRunning external tests\n"CLR_RESET);
    run_external_tests_menu(); /* from runner.c */
    scoreboard_save();
    pause_enter();
}

/*
   The main menu loop
*/
void menu_main_loop(void) {
    while(1){
        int sp = stats_get_speed_mode();
        const char* sp_text = (sp==0) ? "NORMAL" : "FAST";
        printf(CLR_BOLD CLR_YELLOW " ┌────────────────────────────────────────────┐\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " │             OS-SCHEDULING GAME             │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " └────────────────────────────────────────────┘\n" CLR_RESET);
        printf(CLR_RED "     A concurrency and scheduling trainer   \n" CLR_RESET);
        printf(CLR_BOLD CLR_RED "          [Current Speed Mode: %s]\n\n" CLR_RESET, sp_text);
        printf(CLR_BOLD CLR_YELLOW " ┌─── MAIN MENU ─────────────────────────────┐\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " │ 1) Run All Unlocked Test Suites           │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " │ 2) Exit                                   │\n" CLR_RESET);
        int unlockedExt = scoreboard_is_unlocked(SUITE_EXTERNAL);
        if(unlockedExt){
            printf(CLR_BOLD CLR_YELLOW " │ 3) External Shell Concurrency DEMO        │\n" CLR_RESET);
        } else {
            printf(CLR_BOLD CLR_GRAY   " │ 3) External Shell Concurrency DEMO (LOCK) │\n" CLR_RESET);
        }

        /* "Run External Tests" => only visible if EXTERNAL is unlocked. */
        if(unlockedExt){
            printf(CLR_BOLD CLR_YELLOW " │ 4) Run External Tests                     │\n" CLR_RESET);
        } else {
            printf(CLR_BOLD CLR_GRAY   " │ 4) Run External Tests (LOCK)              │\n" CLR_RESET);
        }

        printf(CLR_BOLD CLR_YELLOW " │ 5) Show Scoreboard                        │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " │ 6) Clear Scoreboard                       │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " │ 7) Toggle Speed Mode                      │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " │ 8) Run Single Test                        │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " └───────────────────────────────────────────┘\n\n" CLR_RESET);

        printf(CLR_BOLD CLR_YELLOW"Choice: "CLR_RESET);

        char input[256];
        if(!read_line(input, sizeof(input))){
            menu_main_loop();
        }

        int choice = parse_int_strtol(input, -1);

        switch(choice){
        case 1:
            submenu_run_tests();
            break;
        case 2: {
            /* Exit */
            const int fs = scoreboard_get_final_score();
            printf(CLR_GREEN"\nExiting with final score = %d.\n"CLR_RESET, fs);
            os_cleanup();
            scoreboard_save();
            scoreboard_close();
            stats_print_summary();
            exit(fs);
            break;
        }
        case 3:
            /* External concurrency => only if unlocked */
            if(unlockedExt){
                menu_submenu_external_concurrency();
            } else {
                printf(CLR_RED"Locked.\n"CLR_RESET);
                pause_enter();
            }
            break;
        case 4:
            /* Run external tests => only if unlocked */
            if(unlockedExt){
                menu_run_external_tests();
            } else {
                printf(CLR_RED"Locked.\n"CLR_RESET);
                pause_enter();
            }
            break;
        case 5:
            menu_show_scoreboard();
            break;
        case 6:
            menu_clear_scoreboard();
            break;
        case 7:
            menu_toggle_speed_mode();
            break;
        case 8:
            submenu_run_single_test();
            break;
        default:
            printf(CLR_RED"Invalid.\n"CLR_RESET);
            pause_enter();
            break;
        }
    }
}#ifndef MENU_H
#define MENU_H
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <sys/types.h>
#include "stats.h"
#include "scoreboard.h"
#include "runner.h"
#include "os.h"
#include "safe_calls_library.h"


/*
 * menu.h => The main user-interface menu system.
 *           Exposes just the function to start the main loop.
 */

/* Enters the main menu loop (blocking). Never returns unless user exits. */
void menu_main_loop(void);
static void attempt_run_next_suite(scoreboard_suite_t currentSuite);

/* Clears the terminal screen. */
void clear_screen(void);

/* Pauses until the user presses ENTER. */
void pause_enter(void);

/* Reads one line (up to sz-1 chars). Returns 1 if success, 0 if error/EOF. */
ssize_t read_line(char *buf, size_t sz);

/* Prints the ASCII art main menu header (includes speed mode info). */
void ascii_main_menu_header(void);

/* Submenu to run all unlocked tests (skipping already 100% passed). */
void submenu_run_tests(void);

/* Submenu to run exactly one test from a chosen suite. */
void submenu_run_single_test(void);

/* Shows the scoreboard in a "squared ASCII" format with progress bar. */
void menu_show_scoreboard(void);

/* Clears the scoreboard. */
void menu_clear_scoreboard(void);

/* Toggles speed mode: 0 => normal, 1 => fast. */
void menu_toggle_speed_mode(void);

/* External concurrency submenu. */
void menu_submenu_external_concurrency(void);
#endif
#include "os.h"
#include "stats.h"
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <pthread.h>
#include <sys/wait.h>
#include <time.h>
#include <string.h>

/*
  Global concurrency stop flag. If set, any concurrency loop stops early.
*/
static volatile sig_atomic_t g_concurrency_stop_flag = 0;

/* For measuring time since os_init() in real-time ms. */
static uint64_t g_start_ms = 0;

/* Up to 32 ephemeral containers. */
static int       g_container_count = 0;
static char      g_container_paths[32][256];

/* Returns monotonic current time in ms. */
static uint64_t now_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)(ts.tv_sec)*1000ULL + (ts.tv_nsec / 1000000ULL);
}

void set_os_concurrency_stop_flag(int val) {
    g_concurrency_stop_flag = (sig_atomic_t)val;
}

int os_concurrency_stop_requested(void) {
    return (int)g_concurrency_stop_flag;
}

/* ----------------------------------------------------------------
   Initialize "OS"
   ----------------------------------------------------------------
*/
void os_init(void) {
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
    g_start_ms = now_ms();
    g_container_count = 0;
    memset(g_container_paths, 0, sizeof(g_container_paths));
}

/* ----------------------------------------------------------------
   Cleanup: remove ephemeral containers, etc.
   ----------------------------------------------------------------
*/
void os_cleanup(void) {
    /* Remove all ephemeral containers in reverse order. */
    while (g_container_count > 0) {
        g_container_count--;
        const char* path = g_container_paths[g_container_count];
        if (path && path[0]) {
            rmdir(path);
            memset(g_container_paths[g_container_count], 0, sizeof(g_container_paths[g_container_count]));
            printf("\033[96m[-] Container removed (cleanup): %s\n\033[0m", path);
            stats_inc_containers_removed();
        }
    }
}

uint64_t os_time(void) {
    /* Return real-world elapsed ms since os_init(). */
    const uint64_t now = now_ms();
    if(now < g_start_ms) return 0ULL;
    return (now - g_start_ms);
}

/* Minimal logging with a small delay in normal mode only. */
void os_log(const char* msg) {
    if(!msg) return;
    if(stats_get_speed_mode() == 0) {
        printf("%s\n", msg);
        usleep(500000);
    }
}

/* ----------------------------------------------------------------
   Container creation
   ----------------------------------------------------------------
*/
void os_create_ephemeral_container(void) {
    if(g_container_count >= 32) return;
    char tmpl[] = "/tmp/os_cont_XXXXXX";
    if(mkdtemp(tmpl)) {
        strncpy(g_container_paths[g_container_count], tmpl, 255);
        g_container_count++;
        printf("\033[96m[+] Container created: %s (count=%d)\n\033[0m",
               tmpl, g_container_count);
        stats_inc_containers_created();
    }
}

/* Container removal (explicit). */
void os_remove_ephemeral_container(void) {
    if(g_container_count <= 0) return;
    g_container_count--;
    const char* path = g_container_paths[g_container_count];
    if(path[0]) {
        rmdir(path);
        memset(g_container_paths[g_container_count], 0, sizeof(g_container_paths[g_container_count]));
        printf("\033[96m[-] Container removed: %s (remaining=%d)\n\033[0m",
               path, g_container_count);
        stats_inc_containers_removed();
    }
}

/*
   HPC overshadow => spawns multiple CPU-bound threads to demonstrate concurrency.
   Now refined to choose a random number of threads between 4..8.
*/
static void* overshadow_thread(void* arg) {
    long *ret = (long*)arg;
    long sum = 0;
    for (long i=0; i<7000000; i++) {
        if(os_concurrency_stop_requested()) break;
        sum += (i % 17) + (i % 11);
    }
    *ret = sum;
    return NULL;
}

void os_run_hpc_overshadow(void) {
    if(os_concurrency_stop_requested()) {
        printf("\033[91m[OS] concurrency has to stop => HPC overshadow aborted\n\033[0m");
        return;
    }

    /* NEW/UPDATED: pick a random number of CPU-bound threads from 4..8. */
    srand((unsigned int)time(NULL));
    int n = 4 + (rand() % 5); /* range = [4..8]. */

    long* results = (long*)calloc(n, sizeof(long));
    pthread_t* th = (pthread_t*)malloc(n*sizeof(pthread_t));

    if(stats_get_speed_mode()==0){
        printf("\033[92m[HPC Overshadow] => spawning %d threads\n\033[0m", n);
        usleep(200000);
    }

    for (int i=0; i<n; i++) {
        pthread_create(&th[i], NULL, overshadow_thread, &results[i]);
        if(stats_get_speed_mode()==0){
            printf("\033[92m   HPC Overshadow Thread #%d => time=%llu ms => started.\n\033[0m",
                   i+1, (unsigned long long)os_time());
            usleep(150000);
        }
    }
    for (int i=0; i<n; i++) {
        pthread_join(th[i], NULL);
        if(stats_get_speed_mode()==0){
            printf("\033[92m   HPC Overshadow Thread #%d => time=%llu ms => finished.\n\033[0m",
                   i+1, (unsigned long long)os_time());
            usleep(100000);
        }
    }

    free(th);
    free(results);
    if (stats_get_speed_mode()==0) {
        printf("\033[92m   HPC Overshadow => time=%llu ms => END.\n\033[0m",
               (unsigned long long)os_time());
    }
}

/*
   HPC overlay => spawns a smaller random number of CPU-bound threads, e.g. [2..4].
*/
static void* overlay_thread(void* arg) {
    long *ret = (long*)arg;
    long sum = 0;
    for (long i=0; i<4000000; i++) {
        if(os_concurrency_stop_requested()) break;
        sum += (i % 19) + (i % 13);
    }
    *ret = sum;
    return NULL;
}

void os_run_hpc_overlay(void) {
    if(os_concurrency_stop_requested()) {
        printf("\033[91m[OS] concurrency stop => HPC overlay aborted\n\033[0m");
        return;
    }

    /* NEW/UPDATED: random number of threads in [2..4]. */
    srand((unsigned int)time(NULL));
    int n = 2 + (rand() % 3); /* range = [2..4]. */

    long* results = (long*)calloc(n, sizeof(long));
    pthread_t* th = (pthread_t*)malloc(n*sizeof(pthread_t));

    if(stats_get_speed_mode()==0){
        printf("\033[92m[HPC Overlay] => spawning %d threads\n\033[0m", n);
        usleep(200000);
    }

    for (int i=0; i<n; i++) {
        pthread_create(&th[i], NULL, overlay_thread, &results[i]);
        if(stats_get_speed_mode()==0){
            printf("\033[92m   HPC Overlay Thread #%d => time=%llu ms => started.\n\033[0m",
                   i+1, (unsigned long long)os_time());
            usleep(150000);
        }
    }
    for (int i=0; i<n; i++) {
        pthread_join(th[i], NULL);
        if(stats_get_speed_mode()==0){
            printf("\033[92m   HPC Overlay Thread #%d => time=%llu ms => finished.\n\033[0m",
                   i+1, (unsigned long long)os_time());
            usleep(100000);
        }
    }

    free(th);
    free(results);
    if (stats_get_speed_mode()==0) {
        printf("\033[92m   HPC Overlay => time=%llu ms => END.\n\033[0m",
               (unsigned long long)os_time());
    }
}

/*
   Pipeline example => now refined to create multiple child processes in series,
   simulating a multi-stage pipeline.
*/
void os_pipeline_example(void) {
    printf("\033[95m╔══════════════════════════════════════════════╗\n");
    printf("║             PIPELINE BLOCK START             ║\n");
    printf("╚══════════════════════════════════════════════╝\033[0m\n");

    if(os_concurrency_stop_requested()) {
        printf("\033[91m[OS] concurrency stop => skipping pipeline.\033[0m\n");
        return;
    }

    /* We'll do a 2-stage pipeline:
       stage1 child => does some "work"
       then pipe into stage2 child => does next "work"
       (in real shell code, you'd connect the outputs/inputs, but here we demonstrate the concept.)
    */
    int pipefd[2];
    if(pipe(pipefd) == -1) {
        perror("pipe");
        return;
    }

    pid_t c1 = fork();
    if(c1==0) {
        /* Child1 => simulate pipeline stage #1 */
        close(pipefd[0]);
        if(stats_get_speed_mode()==0){
            printf("\033[92m   [Pipeline child1 => start => time=%llu ms]\033[0m\n",
                   (unsigned long long)os_time());
            usleep(100000);
        }
        /* write some data to pipe to pass to next stage. */
        const char* data="Hello from stage1";
        write(pipefd[1], data, strlen(data)+1);
        close(pipefd[1]);

        if(stats_get_speed_mode()==0){
            printf("\033[92m   [Pipeline child1 => end => time=%llu ms]\033[0m\n",
                   (unsigned long long)os_time());
        }
        _exit(0);
    } else if(c1>0) {
        /* parent => spawn stage2 */
        pid_t c2 = fork();
        if(c2==0) {
            close(pipefd[1]);
            /* read data from stage1. */
            char buf[128];
            memset(buf,0,sizeof(buf));
            read(pipefd[0], buf, sizeof(buf)-1);
            if(stats_get_speed_mode()==0){
                printf("\033[92m   [Pipeline child2 => got data=\"%s\" => time=%llu ms]\033[0m\n",
                       buf, (unsigned long long)os_time());
                usleep(150000);
            }
            close(pipefd[0]);
            _exit(0);
        } else if(c2>0) {
            /* parent => wait for both. */
            close(pipefd[0]);
            close(pipefd[1]);
            waitpid(c1,NULL,0);
            waitpid(c2,NULL,0);
        }
    }

    printf("\033[96m╔══════════════════════════════════════════════╗\n");
    printf("║             PIPELINE BLOCK END               ║\n");
    printf("╚══════════════════════════════════════════════╝\033[0m\n");

    if(stats_get_speed_mode()==0){
        usleep(200000);
    }
}

/*
   Distributed example => we fork multiple HPC overshadow tasks in parallel
   to simulate "remote nodes" doing CPU-bound HPC overshadow.
*/
void os_run_distributed_example(void) {
    printf("\033[95m╔══════════════════════════════════════════════╗\n");
    printf("║          DISTRIBUTED BLOCK START             ║\n");
    printf("╚══════════════════════════════════════════════╝\033[0m\n");

    if(os_concurrency_stop_requested()) {
        printf("\033[93m[OS] concurrency stop => skipping distributed.\033[0m\n");
        return;
    }

    /* We'll spawn 2 HPC overshadow children, each doing overshadow. */
    for(int i=0; i<2; i++) {
        if(os_concurrency_stop_requested()) {
            break;
        }
        pid_t c = fork();
        if (c == 0) {
            if(stats_get_speed_mode()==0){
                printf("\033[92m   [Distributed child => HPC overshadow => time=%llu ms]\033[0m\n",
                       (unsigned long long)os_time());
                usleep(200000);
            }
            os_run_hpc_overshadow();
            _exit(0);
        } else if (c > 0) {
            /* parent just moves on to spawn the next or wait. */
        }
    }
    /* Wait for them all. In real code we'd track pids, but let's do a simple approach. */
    for(int i=0; i<2; i++) {
        wait(NULL);
    }

    printf("\033[96m╔══════════════════════════════════════════════╗\n");
    printf("║           DISTRIBUTED BLOCK END              ║\n");
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef OS_H
#define OS_H

#include <stdint.h>

/*
  OS-level stubs and abstractions:
   - ephemeral containers
   - HPC overshadow
   - HPC overlay (newly added)
   - pipeline
   - distributed example
   - time logging for user display logs
   - concurrency stop check
*/

/* Sets the concurrency stop flag (e.g. after SIGTERM). */
void set_os_concurrency_stop_flag(int val);

/* Returns if concurrency stop was requested. */
int os_concurrency_stop_requested(void);

/* Initialize OS environment (buffers, times, etc.). */
void os_init(void);

/* Cleanup OS environment (remove ephemeral containers, etc.). */
void os_cleanup(void);

/* Returns real-world time in ms since os_init(). */
uint64_t os_time(void);

/* Optionally log a message with a short delay for user-friendly pacing in normal mode. */
void os_log(const char* msg);

/* Ephemeral container operations. */
void os_create_ephemeral_container(void);
void os_remove_ephemeral_container(void);

/* HPC overshadow => spawns multiple (4) CPU-bound threads to demonstrate concurrency. */
void os_run_hpc_overshadow(void);

/* HPC overlay => spawns fewer (2) CPU-bound threads, a different HPC demonstration. */
void os_run_hpc_overlay(void);

/* Pipeline example => fork a child, show pipeline start/end with ASCII. */
void os_pipeline_example(void);

/* Distributed example => fork a child that itself runs HPC overshadow. */
void os_run_distributed_example(void);

#endif
#include <stdlib.h>
#include <string.h>
#include "safe_calls_library.h"
#include "process.h"

/* Initialize a process with given burst, priority, arrival_time. */
void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival) {
    if (!p) return;
    memset(p, 0, sizeof(*p));
    p->burst_time     = burst;
    p->remaining_time = burst;
    p->priority       = priority;
    p->arrival_time   = arrival;
    p->times_owning_core = 0;
}

/* OPTIONAL new function: reset a process so it can be reused. */
void reset_process(process_t* p, uint64_t new_burst, int new_priority, uint64_t new_arrival) {
    if(!p) return;
    p->burst_time     = new_burst;
    p->remaining_time = new_burst;
    p->priority       = new_priority;
    p->arrival_time   = new_arrival;
    p->vruntime       = 0;
    p->start_time     = 0;
    p->end_time       = 0;
    p->first_response = 0;
    p->responded      = 0;
    p->mlfq_level     = 0;
    p->times_owning_core = 0;
}
#ifndef PROCESS_H
#define PROCESS_H

#include <stdint.h>

/*
  Single "process" (or "task") structure for scheduling.
  Fields:
   - burst_time
   - priority
   - vruntime
   - arrival_time
   - remaining_time
   - stats (start_time, end_time, first_response, responded)
   - MLFQ queue level
   - times_owning_core
*/

typedef struct process_s {
    uint64_t burst_time;       /* total CPU time needed (ms) */
    int      priority;         /* smaller => higher priority (for some algs) */
    uint64_t vruntime;         /* used by CFS / CFS-SRTF */
    uint64_t arrival_time;     /* simulation "arrival" time */
    uint64_t remaining_time;   /* how many ms remain for this process */

    /* Additional fields to track stats: */
    uint64_t start_time;
    uint64_t end_time;
    uint64_t first_response;
    int      responded;
    int      mlfq_level;
    int      times_owning_core;
} process_t;

/* Initialize a process with the given burst, priority, arrival_time. */
void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival);

#endif
#include "ready_queue.h"
#include "scheduler.h"
#include "process.h"

#include <pthread.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

/* We'll keep up to 10 MLFQ levels. */
#define MLFQ_MAX_QUEUES 10

/*
   We implement optional *aging* for MLFQ:
   If a process remains in a lower queue for more than MLFQ_AGING_MS
   (in simulated time), we promote it up one level.
*/
#define MLFQ_AGING_MS  10

/*
   A single node in our queue/linked-list.
   If proc == NULL, it is a "sentinel" node that signals termination.
*/
typedef struct node_s {
    process_t*       proc;
    uint64_t         enqueued_sim_time;
    struct node_s*   next;
} node_t;

/*
   The global queue structure with:
   - sentinel for normal single-queue algorithms
   - ml_queues[] for MLFQ
   - size
   - chosen alg
   - locks/conds
*/
static struct {
    node_t           sentinel;
    size_t           size;
    pthread_mutex_t  m;
    pthread_cond_t   c;
    scheduler_alg_t  alg;
    /* The MLFQ queues (0=highest priority, MLFQ_MAX_QUEUES-1=lowest) */
    node_t           ml_queues[MLFQ_MAX_QUEUES];
} gQ;

/* Helper for mutex/cond. */
static pthread_mutex_t* pm(void) { return &gQ.m; }
static pthread_cond_t*  pc(void) { return &gQ.c; }

/* ---------- Linked-list queue basics ---------- */
static process_t* pop_head(void) {
    node_t* head = gQ.sentinel.next;
    if (!head) return NULL;
    gQ.sentinel.next = head->next;
    gQ.size--;

    /* If this is a sentinel node => return NULL so the thread can exit. */
    process_t* p = head->proc;
    free(head);
    return p;
}

static void push_tail(process_t* p) {
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->enqueued_sim_time = get_global_sim_time();
    n->next = NULL;
    node_t* cur = &gQ.sentinel;
    while (cur->next) {
        cur = cur->next;
    }
    cur->next = n;
    gQ.size++;
}

/* For priority-based insertion. */
static void push_priority(process_t* p) {
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->enqueued_sim_time = get_global_sim_time();
    n->next = NULL;

    node_t* cur = &gQ.sentinel;
    /* smaller priority => earlier in the list */
    while (cur->next && (p->priority >= cur->next->proc->priority)) {
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

/* For CFS => insert by ascending vruntime. */
static void push_cfs(process_t* p) {
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->enqueued_sim_time = get_global_sim_time();
    n->next = NULL;

    node_t* cur = &gQ.sentinel;
    while (cur->next && (p->vruntime >= cur->next->proc->vruntime)) {
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

/* For SJF => insert by ascending burst_time. */
static void push_sjf(process_t* p) {
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->enqueued_sim_time = get_global_sim_time();
    n->next = NULL;

    node_t* cur = &gQ.sentinel;
    while (cur->next && (p->burst_time >= cur->next->proc->burst_time)) {
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

/* Helper for HRRN ratio: (wait + remain). Higher => schedule first. */
static uint64_t hrrn_val(process_t* p, uint64_t now) {
    uint64_t wait   = (now > p->arrival_time) ? (now - p->arrival_time) : 0ULL;
    uint64_t remain = (p->remaining_time > 0) ? p->remaining_time : 1ULL;
    return (wait + remain);
}

static void push_hrrn(process_t* p, int preemptive) {
    (void)preemptive; /* same insertion logic; preemption is handled in scheduling loop */
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->enqueued_sim_time = get_global_sim_time();
    n->next = NULL;

    uint64_t now = get_global_sim_time();
    uint64_t new_ratio = hrrn_val(p, now);

    node_t* cur = &gQ.sentinel;
    while (cur->next && cur->next->proc != NULL) {
        uint64_t c_ratio = hrrn_val(cur->next->proc, now);
        if (new_ratio > c_ratio) {
            break;
        }
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

/* ---------- MLFQ ---------- */
static process_t* pop_mlfq(void) {
    for (int i = 0; i < MLFQ_MAX_QUEUES; i++) {
        if (gQ.ml_queues[i].next) {
            node_t* n = gQ.ml_queues[i].next;
            gQ.ml_queues[i].next = n->next;
            gQ.size--;

            /* If it's a sentinel node => return NULL so the core thread ends. */
            process_t* p = n->proc;
            free(n);
            return p;
        }
    }
    return NULL;
}

static void push_mlfq(process_t* p) {
    /* If the process is actually the sentinel => put it in queue 0 so it can pop easily. */
    int level = (p ? p->mlfq_level : 0);
    if (level < 0) level = 0;
    if (level >= MLFQ_MAX_QUEUES) level = MLFQ_MAX_QUEUES - 1;

    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->enqueued_sim_time = get_global_sim_time();
    n->next = NULL;

    node_t* cur = &gQ.ml_queues[level];
    while (cur->next) {
        cur = cur->next;
    }
    cur->next = n;
    gQ.size++;
}

/*
   Each time we pop in MLFQ, we do a quick pass to check
   if any process in a lower queue has waited >= MLFQ_AGING_MS
   => promote it up one level.
*/
static void mlfq_promote_aged_processes(void) {
    uint64_t now = get_global_sim_time();
    for(int level = 1; level < MLFQ_MAX_QUEUES; level++) {
        node_t* head = &gQ.ml_queues[level];
        node_t* cur  = head;
        while(cur->next) {
            node_t* nxt = cur->next;
            if(nxt->proc == NULL) {
                /* skip sentinel nodes if any ended up here */
                cur = cur->next;
                continue;
            }
            uint64_t waited = (now > nxt->enqueued_sim_time)
                               ? (now - nxt->enqueued_sim_time)
                               : 0ULL;
            if(waited >= MLFQ_AGING_MS) {
                /* remove from current queue */
                cur->next = nxt->next;
                gQ.size--;

                /* promote up one level */
                int newLevel = level - 1;
                if(newLevel<0) newLevel=0;
                nxt->proc->mlfq_level = newLevel;
                nxt->enqueued_sim_time = now;

                /* push it to the newLevel queue at the tail */
                node_t* tail = &gQ.ml_queues[newLevel];
                while(tail->next) {
                    tail = tail->next;
                }
                tail->next = nxt;
                nxt->next  = NULL;
                gQ.size++;

                /* do not advance cur => we removed nxt from chain. */
            } else {
                cur = cur->next;
            }
        }
    }
}

/* ---------- Public interface ---------- */

void ready_queue_init_policy(scheduler_alg_t alg) {
    memset(&gQ, 0, sizeof(gQ));
    pthread_mutex_init(pm(), NULL);
    pthread_cond_init(pc(), NULL);
    gQ.alg = alg;
}

/* We leave the function pointers approach inlined to keep code simpler. */

void ready_queue_destroy(void) {
    pthread_cond_destroy(pc());
    pthread_mutex_destroy(pm());
    memset(&gQ, 0, sizeof(gQ));
}

/*
   FIX: If p==NULL => we still push a *sentinel node*
   so that waiting threads can pop it and exit.
*/
void ready_queue_push(process_t* p) {
    pthread_mutex_lock(pm());

    /* If 'p' is NULL => push sentinel node so pop() can return NULL. */
    if(!p) {
        node_t* n = (node_t*)malloc(sizeof(node_t));
        n->proc = NULL; /* sentinel */
        n->enqueued_sim_time = get_global_sim_time();
        n->next = NULL;

        /* For MLFQ, place sentinel in queue 0 so it can be seen immediately. */
        if(gQ.alg == ALG_MLFQ) {
            node_t* cur = &gQ.ml_queues[0];
            while(cur->next) {
                cur = cur->next;
            }
            cur->next = n;
            gQ.size++;
        } else {
            /* For single-queue algs => put it in the main sentinel list. */
            node_t* cur = &gQ.sentinel;
            while(cur->next) {
                cur = cur->next;
            }
            cur->next = n;
            gQ.size++;
        }
        /* Wake up any waiting threads. */
        pthread_cond_broadcast(pc());
        pthread_mutex_unlock(pm());
        return;
    }

    /* If it's HRRN: */
    if (gQ.alg == ALG_HRRN || gQ.alg == ALG_HRRN_RT) {
        uint64_t now = get_global_sim_time();
        uint64_t new_ratio = hrrn_val(p, now);

        node_t* n = (node_t*)malloc(sizeof(node_t));
        n->proc = p;
        n->enqueued_sim_time = now;
        n->next = NULL;

        node_t* cur = &gQ.sentinel;
        while (cur->next && cur->next->proc != NULL) {
            uint64_t c_ratio = hrrn_val(cur->next->proc, now);
            if (new_ratio > c_ratio) break;
            cur = cur->next;
        }
        n->next = cur->next;
        cur->next = n;
        gQ.size++;
    }
    else if(gQ.alg == ALG_MLFQ) {
        push_mlfq(p);
    }
    else {
        /* For simpler algs => do insertion logic depending on which one it is. */
        /* We can detect it from gQ.alg if we want the original approach. */
        switch(gQ.alg) {
            case ALG_FIFO:
            case ALG_RR:
            case ALG_BFS:
                push_tail(p);
                break;
            case ALG_PRIORITY:
                push_priority(p);
                break;
            case ALG_CFS:
            case ALG_CFS_SRTF:
                push_cfs(p);
                break;
            case ALG_SJF:
            case ALG_STRF:
                push_sjf(p);
                break;
            default:
                push_tail(p);
                break;
        }
    }

    pthread_cond_broadcast(pc());
    pthread_mutex_unlock(pm());
}

/*
   The caller blocks here if the queue is empty.
   If we see a sentinel node => return NULL, causing the scheduling thread to exit.
*/
process_t* ready_queue_pop(void) {
    pthread_mutex_lock(pm());
    while(1) {
        if (gQ.size > 0) {
            if(gQ.alg == ALG_MLFQ) {
                /* MLFQ: do a quick check for aging before we pop. */
                mlfq_promote_aged_processes();
                process_t* p = pop_mlfq();
                pthread_mutex_unlock(pm());

                /* If sentinel => return NULL => thread exit. */
                if(!p) {
                    return NULL;
                }
                return p;
            }
            else {
                /* Single queue approach. Check if the front is sentinel. */
                node_t* front = gQ.sentinel.next;
                if(front && front->proc == NULL) {
                    /* pop the sentinel => return NULL => exit. */
                    gQ.sentinel.next = front->next;
                    gQ.size--;
                    free(front);
                    pthread_mutex_unlock(pm());
                    return NULL;
                }
                /* Otherwise pop normally. */
                process_t* p = pop_head();
                pthread_mutex_unlock(pm());
                return p;
            }
        }
        /* If empty => wait. */
        pthread_cond_wait(pc(), pm());
    }
    /* unreachable */
    pthread_mutex_unlock(pm());
    return NULL;
}

size_t ready_queue_size(void) {
    pthread_mutex_lock(pm());
    size_t s = gQ.size;
    pthread_mutex_unlock(pm());
    return s;
}
#ifndef READY_QUEUE_H
#define READY_QUEUE_H

#include <stddef.h>
#include "process.h"
#include "scheduler.h"

/*
  "ready_queue" data structure, with policy determined by scheduler_alg_t.
  Thread-safe with mutex + cond.
*/

/* Initialize the ready queue with a given scheduling algorithm. */
void ready_queue_init_policy(scheduler_alg_t alg);

/* Destroy the ready queue, freeing resources. */
void ready_queue_destroy(void);

/* Push a process into the queue. (thread-safe) */
void ready_queue_push(process_t* proc);

/* Pop a process from the queue. (thread-safe, blocks if empty).
   Returns NULL if a sentinel is pushed or if the queue is ended. */
process_t* ready_queue_pop(void);

/* Returns the current size. (thread-safe) */
size_t ready_queue_size(void);

#endif
#include "runner.h"
#include "scoreboard.h"
#include "stats.h"
#include "safe_calls_library.h"
#include "os.h"
#include "scheduler.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

/*
  We'll maintain a lookup for scheduler_alg_t => string name
  to produce "SCHEDULE BLOCK => <Name>" in concurrency logs, if needed.
*/
static const char* scheduler_alg_to_str(scheduler_alg_t alg) {
    switch(alg) {
        case ALG_FIFO:          return "FIFO";
        case ALG_RR:            return "Round Robin";
        case ALG_CFS:           return "CFS";
        case ALG_CFS_SRTF:      return "CFS-SRTF";
        case ALG_BFS:           return "BFS";
        case ALG_SJF:           return "SJF";
        case ALG_STRF:          return "STRF";
        case ALG_HRRN:          return "HRRN";
        case ALG_HRRN_RT:       return "HRRN-RT";
        case ALG_PRIORITY:      return "PRIORITY";
        case ALG_HPC_OVERSHADOW:return "HPC-OVER";
        case ALG_MLFQ:          return "MLFQ";
        default:                return "Unknown";
    }
}

/* forward declarations for test suite runners */
extern void run_basic_tests(int* total,int* passed);
extern void run_normal_tests(int* total,int* passed);
extern void run_modes_tests(int* total,int* passed);
extern void run_edge_tests(int* total,int* passed);
extern void run_hidden_tests(int* total,int* passed);

/* new external tests approach: */
extern void run_external_tests(int* total,int* passed);

/* single-test extern: */
extern int basic_test_count(void);
extern void basic_test_run_single(int idx, int* pass_out);

extern int normal_test_count(void);
extern void normal_test_run_single(int idx, int* pass_out);

extern int modes_test_count(void);
extern void modes_test_run_single(int idx, int* pass_out);

extern int edge_test_count(void);
extern void edge_test_run_single(int idx, int* pass_out);

extern int hidden_test_count(void);
extern void hidden_test_run_single(int idx, int* pass_out);

extern int external_test_count(void);
extern void external_test_run_single(int idx,int* pass_out);


/* ----------------------------------------------------------------
   run_entire_suite => same pattern for each suite
   Then scoreboard_update_* after we get total/passed.
---------------------------------------------------------------- */
void run_entire_suite(scoreboard_suite_t suite) {
    switch(suite) {
    case SUITE_BASIC: {
        int t=0, p=0;
        printf("\n[Running BASIC suite...]\n");
        run_basic_tests(&t,&p);
        scoreboard_update_basic(t,p);
        scoreboard_save();
        break;
    }
    case SUITE_NORMAL: {
        int t=0, p=0;
        printf("\n[Running NORMAL suite...]\n");
        run_normal_tests(&t,&p);
        scoreboard_update_normal(t,p);
        scoreboard_save();
        break;
    }
    case SUITE_EXTERNAL: {
        int t=0, p=0;
        printf("\n[Running EXTERNAL suite...]\n");
        run_external_tests(&t, &p);
        scoreboard_update_external(t,p);
        scoreboard_save();
        break;
    }
    case SUITE_MODES: {
        int t=0, p=0;
        printf("\n[Running MODES suite...]\n");
        run_modes_tests(&t,&p);
        scoreboard_update_modes(t,p);
        scoreboard_save();
        break;
    }
    case SUITE_EDGE: {
        int t=0, p=0;
        printf("\n[Running EDGE suite...]\n");
        run_edge_tests(&t,&p);
        scoreboard_update_edge(t,p);
        scoreboard_save();
        break;
    }
    case SUITE_HIDDEN: {
        int t=0, p=0;
        printf("\n[Running HIDDEN suite...]\n");
        run_hidden_tests(&t,&p);
        scoreboard_update_hidden(t,p);
        scoreboard_save();
        break;
    }
    default:
        break;
    }
}

/*
   run_external_tests_menu => original code had "run_external_tests()",
   but now we don't store results here, we do that in run_entire_suite(SUITE_EXTERNAL).
   If the menu just wants to run external suite, it can either call run_entire_suite or
   do partial logic. We'll keep a function to run it "on-demand," though.
*/
void run_external_tests_menu(void) {
    int t=0, p=0;
    run_external_tests(&t, &p);
    scoreboard_update_external(t,p);
    scoreboard_save();
}

/*
   run_single_test_in_suite => used by the "Run Single Test" menu item
*/
void run_single_test_in_suite(scoreboard_suite_t chosen) {
    int count = 0;
    switch(chosen) {
        case SUITE_BASIC:   count = basic_test_count();   break;
        case SUITE_NORMAL:  count = normal_test_count();  break;
        case SUITE_MODES:   count = modes_test_count();   break;
        case SUITE_EDGE:    count = edge_test_count();    break;
        case SUITE_HIDDEN:  count = hidden_test_count();  break;
        case SUITE_EXTERNAL:count = external_test_count();break;
        default: break;
    }
    if(count<=0) {
        printf("No tests found in that suite or suite missing.\n");
        return;
    }

    printf("\nWhich single test do you want to run (1..%d)? ", count);
    char buf[256];
    if(!fgets(buf, sizeof(buf), stdin)) {
        return;
    }
    buf[strcspn(buf, "\n")] = '\0';
    int pick = parse_int_strtol(buf, -1);
    if(pick<1 || pick>count) {
        printf("Invalid test index.\n");
        return;
    }

    int passResult = 0; /* 0 => fail, 1 => pass */
    switch(chosen){
        case SUITE_BASIC:
            basic_test_run_single(pick-1, &passResult);
            scoreboard_update_basic(1, passResult);
            scoreboard_save();
            break;
        case SUITE_NORMAL:
            normal_test_run_single(pick-1, &passResult);
            scoreboard_update_normal(1, passResult);
            scoreboard_save();
            break;
        case SUITE_MODES:
            modes_test_run_single(pick-1, &passResult);
            scoreboard_update_modes(1, passResult);
            scoreboard_save();
            break;
        case SUITE_EDGE:
            edge_test_run_single(pick-1, &passResult);
            scoreboard_update_edge(1, passResult);
            scoreboard_save();
            break;
        case SUITE_HIDDEN:
            hidden_test_run_single(pick-1, &passResult);
            scoreboard_update_hidden(1, passResult);
            scoreboard_save();
            break;
        case SUITE_EXTERNAL:
            external_test_run_single(pick-1, &passResult);
            scoreboard_update_external(1, passResult);
            scoreboard_save();
            break;
        default:
            break;
    }
}

/* ----------------------------------------------------------------
   Shell concurrency logic
   If speed=FAST => skip block prints, else show them.
   If mode=-1 => run all from 0..11, else single mode.
---------------------------------------------------------------- */
static const char* scheduler_alg_to_str2(int mode) {
    switch(mode) {
        case 0:  return "FIFO";
        case 1:  return "Round Robin";
        case 2:  return "CFS";
        case 3:  return "CFS-SRTF";
        case 4:  return "BFS";
        case 5:  return "SJF";
        case 6:  return "STRF";
        case 7:  return "HRRN";
        case 8:  return "HRRN-RT";
        case 9:  return "PRIORITY";
        case 10: return "HPC-OVER";
        case 11: return "MLFQ";
        default: return "UNKNOWN";
    }
}

static void concurrency_log(const char* fmt, ...) __attribute__((format(printf,1,2)));
static void concurrency_log(const char* fmt, ...)
{
    if(stats_get_speed_mode()==1) {
        /* FAST => skip printing */
        return;
    }
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
}

static int check_shell_binary(void) {
    if(access("../../shell-tp1-implementation", X_OK) != 0){
        printf(CLR_RED "\n╔══════════════════════════════════════════════╗\n");
        printf("║shell-tp1-implementation NOT FOUND in .       ║\n");
        printf("║External concurrency test cannot run.         ║\n");
        printf("╚══════════════════════════════════════════════╝\n" CLR_RESET);
        return 0;
    }
    return 1;
}

void run_shell_commands_concurrently(int count,
                                     char** lines,
                                     int coreCount,
                                     int mode,
                                     int allModes)
{
    if(count<=0 || !lines) return;
    if(!check_shell_binary()) {
        /* if missing => just fail quietly or print the message above => done */
        return;
    }

    stats_inc_concurrency_runs();

    if(stats_get_speed_mode()==0) {
        printf(CLR_MAGENTA "\n╔═══════════════════════════════════════════════════════════════╗\n");
        printf(             "║        Shell Commands SCHEDULE BLOCK (EXTERNAL)               ║\n");
        printf(             "╚═══════════════════════════════════════════════════════════════╝\n" CLR_RESET);
    }

    int from=0, to=11;
    if(!allModes) {
        if(mode<0 || mode>11) {
            concurrency_log("\n[Invalid scheduling mode => skipping concurrency.]\n");
            return;
        }
        from = mode;
        to   = mode;
    }

    for(int m=from; m<=to; m++){
        if(os_concurrency_stop_requested()) {
            concurrency_log("\n[Concurrency STOP => returning.]\n");
            break;
        }
        const char* alg_name = scheduler_alg_to_str2(m);

        if(stats_get_speed_mode()==0) {
            concurrency_log(CLR_MAGENTA "\n╔═════════════════════════════════════════════════════════════╗\n");
            concurrency_log("║ SCHEDULE BLOCK START => %s\n", alg_name);
            concurrency_log("╚═════════════════════════════════════════════════════════════╝\n" CLR_RESET);
        }

        pid_t* pids = (pid_t*)calloc(count, sizeof(pid_t));
        if(!pids) return;
        stats_inc_concurrency_commands(count);

        for(int i=0; i<count; i++){
            if(os_concurrency_stop_requested()){
                concurrency_log("[STOP => skip spawn child#%d]\n", i+1);
                break;
            }
            concurrency_log(CLR_GREEN "[time=%llu ms] core=%d => Launch child#%d cmd=\"%s\"\n" CLR_RESET,
                            (unsigned long long)os_time(),
                            (i % coreCount), i+1,
                            lines[i]?lines[i]:"");
            /* We'll do a simple fork + send command to shell's stdin,
               as a minimal approach. */
            int pipefd[2];
            if(pipe(pipefd)==-1) {
                perror("pipe");
                continue;
            }
            pid_t c = fork();
            if(c<0) {
                perror("fork");
                close(pipefd[0]);
                close(pipefd[1]);
                continue;
            }
            else if(c==0){
                /* child => read from pipefd[0] as STDIN, then execl the shell. */
                close(pipefd[1]);
                dup2(pipefd[0], STDIN_FILENO);
                close(pipefd[0]);
                execl("./shell-tp1-implementation",
                      "shell-tp1-implementation", (char*)NULL);
                _exit(1);
            }
            else {
                /* parent */
                pids[i]=c;
                close(pipefd[0]);
                dprintf(pipefd[1], "%s\nexit\n", lines[i]?lines[i]:"");
                close(pipefd[1]);
            }
        }

        /* wait for them */
        for(int i=0; i<count; i++){
            if(!pids[i]) continue;
            if(os_concurrency_stop_requested()){
                concurrency_log("[STOP => kill child pid=%d]\n", pids[i]);
                kill(pids[i], SIGKILL);
                continue;
            }
            waitpid(pids[i], NULL, 0);
            concurrency_log(CLR_YELLOW "[time=%llu ms] => Child#%d ended => cmd=\"%s\"\n" CLR_RESET,
                            (unsigned long long)os_time(),
                            i+1,
                            lines[i]?lines[i]:"");
        }
        free(pids);

        if(stats_get_speed_mode()==0){
            concurrency_log(CLR_MAGENTA "╔═════════════════════════════════════════════════════════════╗\n");
            concurrency_log("║ SCHEDULE BLOCK END => %s\n", alg_name);
            concurrency_log("╚═════════════════════════════════════════════════════════════╝\n" CLR_RESET);
        }
    }

    if(stats_get_speed_mode()==0){
        printf(CLR_MAGENTA "\n╔═══════════════════════════════════════════════════════════════╗\n");
        printf(             "║      END CONCURRENCY SCHEDULE BLOCK (EXTERNAL)                ║\n");
        printf(             "╚═══════════════════════════════════════════════════════════════╝\n" CLR_RESET);
    }
    set_os_concurrency_stop_flag(0);
}
#ifndef RUNNER_H
#define RUNNER_H

#include "scoreboard.h"

/*
  runner.h => concurrency logic & test-suites runner utilities
*/

/* Runs the entire suite (all tests in that suite) and updates scoreboard. */
void run_entire_suite(scoreboard_suite_t suite);

/* Runs external tests (if unlocked) -> updates scoreboard. */
void run_external_tests_menu(void);

/*
  Runs a single test from a chosen suite index => scoreboard updated with +1 test, +1 pass if success.
*/
void run_single_test_in_suite(scoreboard_suite_t suite);

/*
  Concurrency function: run shell commands concurrently under a single or all scheduling modes.
   - count, lines => list of commands
   - coreCount => how many CPU cores
   - mode => which single scheduling mode or -1 for all
   - allModes => 1 => do all from 0..11, 0 => do just 'mode'
*/
void run_shell_commands_concurrently(int count,
                                     char** lines,
                                     int coreCount,
                                     int mode,
                                     int allModes);

#endif
#include "safe_calls_library.h"

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <string.h>

int parse_int_strtol(const char* in, int fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    long v = strtol(in, &e, 10);
    if(e==in || errno==ERANGE || v<INT_MIN || v>INT_MAX) return fb;
    return (int)v;
}

long parse_long_strtol(const char* in, long fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    long v = strtol(in, &e, 10);
    if(e==in || errno==ERANGE) return fb;
    return v;
}

float parse_float_strtof(const char* in, float fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    float v = strtof(in, &e);
    if(e==in || errno==ERANGE) return fb;
    return v;
}

double parse_double_strtod(const char* in, double fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    double v = strtod(in, &e);
    if(e==in || errno==ERANGE) return fb;
    return v;
}

/* ----------------------------------------------------------------
   SIGNAL HANDLER
   ----------------------------------------------------------------
*/
void handle_signal(int signum) {
    if(signum == SIGINT) {
        /* SIGINT => exit immediately, but save scoreboard + stats. */
        stats_inc_signal_sigint();
        printf("\nCaught SIGINT => Exiting.\n");
        const int fs = scoreboard_get_final_score();
        cleanup_and_exit(fs);
    }
    else if(signum == SIGTERM) {
        /* SIGTERM => stop concurrency/tests => return to menu. */
        stats_inc_signal_sigterm();
        printf(CLR_RED "\nCaught SIGTERM => Trying to return to menu\n" CLR_RESET);
        set_os_concurrency_stop_flag(1);
        /* Return to menu (the user can then choose to Exit or continue). */
        menu_main_loop();
    }
    else {
        /* For completeness, track any other signals. */
        stats_inc_signal_other();
    }
}

/* ----------------------------------------------------------------
   CLEANUP AND EXIT
   ----------------------------------------------------------------
   Consolidate all final shutdown tasks in one function.
*/
void cleanup_and_exit(int code) {
    os_cleanup();
    scoreboard_save();
    scoreboard_close();
    stats_print_summary();
    exit(code);
}#ifndef SAFE_CALLS_LIBRARY_H
#define SAFE_CALLS_LIBRARY_H
#include <stddef.h>
#include <signal.h>
#include "os.h"
#include "scoreboard.h"
#include "stats.h"
#include "menu.h"
#include "limits.h"

#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GREEN   "\033[92m"
#define CLR_GRAY    "\033[90m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

/* parse integer via strtol; returns fallback if invalid */
int    parse_int_strtol(const char* input, int fallback);

/* parse long via strtol; returns fallback if invalid */
long   parse_long_strtol(const char* input, long fallback);

/* parse float via strtof; returns fallback if invalid */
float  parse_float_strtof(const char* input, float fallback);

/* parse double via strtod; returns fallback if invalid */
double parse_double_strtod(const char* input, double fallback);

/* Cleanup function that saves scoreboard, prints stats, and exits the program. */
void cleanup_and_exit(int code);

/* Signal handler for SIGINT, SIGTERM, etc. */
void handle_signal(int signum);
#endif
#include "scheduler.h"
#include "ready_queue.h"
#include "worker.h"
#include "os.h"
#include "stats.h"

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* We'll assume max of 4 cores for BFS/MLFQ demonstration. */
#ifndef MAX_CORES
#define MAX_CORES 4
#endif

/* ---------- Global scheduling states ---------- */
static scheduler_alg_t  g_current_alg = ALG_CFS;
static int              g_num_cores   = 1;
static int              g_running     = 0;

/*
   The global simulated time in "ms" (not real ms, but a time-step
   that increments with each partial slice).
*/
static uint64_t         g_sim_time    = 0;
static pthread_mutex_t  g_sim_time_lock = PTHREAD_MUTEX_INITIALIZER;

/* track final stats in a single structure. */
static schedule_stats_t g_stats;

/* We keep a pointer to the list of processes used in the run. */
static process_t* g_process_list = NULL;
static int        g_list_count   = 0;

/*
   BFS quantum is stored so BFS tests can see what BFS used.
   This is set in get_dynamic_quantum() if BFS is selected.
*/
static unsigned long g_bfs_quantum = 4; /* default fallback */

/* Provide BFS quantum to BFS tests. */
unsigned long scheduler_get_bfs_quantum(void) {
    return g_bfs_quantum;
}

/* Access global sim time (used by ready_queue for e.g. HRRN, MLFQ) */
uint64_t get_global_sim_time(void) {
    pthread_mutex_lock(&g_sim_time_lock);
    uint64_t t = g_sim_time;
    pthread_mutex_unlock(&g_sim_time_lock);
    return t;
}

/* Resets scheduling stats & sim time at run start. */
static void reset_schedule_stats(void) {
    memset(&g_stats, 0, sizeof(g_stats));
    g_sim_time = 0;
}

/* Compute final stats after all processes finish. */
static void finalize_stats(void) {
    for(int i=0; i<g_list_count; i++) {
        process_t* P = &g_process_list[i];
        uint64_t at  = P->arrival_time;
        uint64_t st  = P->first_response;
        uint64_t et  = P->end_time;

        uint64_t wait = (st > at) ? (st - at) : 0ULL;
        uint64_t tat  = (et > at) ? (et - at) : 0ULL;
        uint64_t resp = wait;

        g_stats.total_wait += wait;
        g_stats.total_tat  += tat;
        g_stats.total_resp += resp;
    }
    g_stats.total_count = g_list_count;

    if(g_stats.total_count > 0) {
        g_stats.avg_wait       = (double)g_stats.total_wait / (double)g_stats.total_count;
        g_stats.avg_turnaround = (double)g_stats.total_tat  / (double)g_stats.total_count;
        g_stats.avg_response   = (double)g_stats.total_resp / (double)g_stats.total_count;
    }
    g_stats.preemptions  = g_stats.total_preempts;
    g_stats.total_procs   = g_stats.total_count;
}

/*
   Returns a dynamic quantum for each preemptive scheduling mode.
   BFS => store in g_bfs_quantum, so BFS test can see the actual timeslice.
*/
static unsigned long get_dynamic_quantum(scheduler_alg_t alg) {
    size_t rq_size = ready_queue_size();
    switch(alg) {
        case ALG_RR: {
            /* Example dynamic approach for RR. */
            const unsigned long baseQuantum = 2;
            unsigned long dynamic_part = (unsigned long)(rq_size / 2);
            return baseQuantum + dynamic_part;
        }
        case ALG_BFS:
            /*
               BFS => choose base slice=4, maybe +1 if queue is big.
               This is just an example. You can do what you want here.
            */
            g_bfs_quantum = 4 + (rq_size > 5 ? 1 : 0);
            return g_bfs_quantum;

        case ALG_CFS_SRTF:
        case ALG_STRF:
        case ALG_HRRN_RT:
        case ALG_MLFQ:
            /* short fixed slice => 2 ms. */
            return 2;

        default:
            /* Non-preemptive => run to completion => quantum=0 => no preemption. */
            return 0;
    }
}

/*
   The scheduling loop for each core:
   - pop from ready_queue
   - run partial timeslice
   - if remain>0 => requeue => preempt
*/
static void* core_thread_func(void* arg) {
    long core_id = (long)arg;

    while(g_running) {
        if(os_concurrency_stop_requested()) {
            break;
        }

        process_t* p = ready_queue_pop();
        if(!g_running || !p) {
            /* if queue empty or sentinel => skip */
            continue;
        }

        uint64_t real_t = os_time();
        if(stats_get_speed_mode() == 0) {
            printf("\033[93m[time=%llu ms] => container=1 core=%ld => scheduling process=%p\n"
                   "   => burst_time=%lu, prio=%d, vruntime=%llu, remain=%llu, timesScheduled=%d\n\033[0m",
                   (unsigned long long)real_t,
                   core_id, (void*)p,
                   (unsigned long)p->burst_time,
                   p->priority,
                   (unsigned long long)p->vruntime,
                   (unsigned long long)p->remaining_time,
                   p->times_owning_core);
            usleep(300000);
        }

        if(!p->responded) {
            p->responded       = 1;
            p->first_response  = get_global_sim_time();
        }
        p->times_owning_core++;

        /* Decide if preemptive => choose quantum. */
        unsigned long q = get_dynamic_quantum(g_current_alg);
        int preemptive = (q > 0) ? 1 : 0;

        /* slice = min(q, remaining_time) if preemptive, else entire remain. */
        unsigned long slice = preemptive
                              ? ( (p->remaining_time > q) ? q : p->remaining_time )
                              : p->remaining_time;

        /* run partial. */
        simulate_process_partial(p, slice, (int)core_id);

        /* update global simulated time. */
        pthread_mutex_lock(&g_sim_time_lock);
        g_sim_time += slice;
        uint64_t now_sim = g_sim_time;
        pthread_mutex_unlock(&g_sim_time_lock);

        p->remaining_time -= slice;

        /* If using CFS or CFS-SRTF => update vruntime. */
        if(g_current_alg == ALG_CFS || g_current_alg == ALG_CFS_SRTF) {
            p->vruntime += slice;
        }

        /* still not finished => requeue => preempt++ */
        if(preemptive && p->remaining_time > 0) {
            __sync_fetch_and_add(&g_stats.total_preempts, 1ULL);

            if(stats_get_speed_mode()==0) {
                printf("\033[94m   => PREEMPT => process=%p => new remain=%llu => preemptions=%llu\n\033[0m",
                       (void*)p,
                       (unsigned long long)p->remaining_time,
                       (unsigned long long)g_stats.total_preempts);
                usleep(300000);
            }

            /* degrade to next queue if MLFQ */
            if(g_current_alg == ALG_MLFQ) {
                p->mlfq_level++;
            }
            ready_queue_push(p);
        }
        else {
            /* The process is done. */
            p->end_time = now_sim;
            if(stats_get_speed_mode()==0) {
                printf("\033[92m   => FINISH => process=%p => total CPU used=%lu ms => time=%llu ms\n\033[0m",
                       (void*)p,
                       (unsigned long)slice,
                       (unsigned long long)os_time());
                usleep(300000);
            }
        }
    }
    return NULL;
}

/* ---------- Public Functions ---------- */

void scheduler_select_algorithm(scheduler_alg_t a) {
    g_current_alg = a;
}

void scheduler_run(process_t* list, int count) {
    reset_schedule_stats();
    if(!list || count<=0) return;

    /* HPC overshadow/overlay => special handling. */
    if(g_current_alg == ALG_HPC_OVERSHADOW) {
        g_stats.HPC_over_mode = 1;
        if(stats_get_speed_mode()==0) {
            printf("\n\033[95m╔══════════════════════════════════════════════╗\n");
            printf(         "║   SCHEDULE => HPC-OVERSHADOW (special mode)   ║\n");
            printf(         "╚══════════════════════════════════════════════╝\033[0m\n");
            usleep(300000);
        }
        os_run_hpc_overshadow();
        return;
    }
    else if(g_current_alg == ALG_HPC_OVERLAY) {
        g_stats.HPC_overlay_mode = 1;
        if(stats_get_speed_mode()==0) {
            printf("\n\033[95m╔══════════════════════════════════════════════╗\n");
            printf(         "║    SCHEDULE => HPC-OVERLAY (special mode)     ║\n");
            printf(         "╚══════════════════════════════════════════════╝\033[0m\n");
            usleep(300000);
        }
        os_run_hpc_overlay();
        return;
    }

    /* BFS or MLFQ => 2 cores, else 1. */
    if(g_current_alg == ALG_BFS || g_current_alg == ALG_MLFQ) {
        g_num_cores = 2;
    } else {
        g_num_cores = 1;
    }

    if(stats_get_speed_mode()==0) {
        printf("\n\033[95m╔══════════════════════════════════════════════╗\n");
        printf(       "║   SCHEDULE => alg=%d => #processes=%d          \n", g_current_alg, count);
        printf(       "║   RealTime start => %llu ms                   \n", (unsigned long long)os_time());
        printf(       "╚══════════════════════════════════════════════╝\033[0m\n");
        usleep(300000);
    }

    ready_queue_init_policy(g_current_alg);

    g_process_list = list;
    g_list_count   = count;
    g_running      = 1;

    /* push all processes into the queue. */
    for(int i=0; i<count; i++) {
        ready_queue_push(&list[i]);
    }

    pthread_t tid[MAX_CORES];
    int n = (g_num_cores > MAX_CORES) ? MAX_CORES : g_num_cores;

    /* spawn each core thread. */
    for(int i=0; i<n; i++) {
        pthread_create(&tid[i], NULL, core_thread_func, (void*)(long)i);
    }

    /* wait while queue is not empty */
    while(ready_queue_size() > 0) {
        usleep(200000);
        if(os_concurrency_stop_requested()) {
            break;
        }
    }

    /* end scheduling => push sentinel => join threads */
    g_running = 0;
    for(int i=0; i<n; i++) {
        ready_queue_push(NULL);
    }
    for(int i=0; i<n; i++) {
        pthread_join(tid[i], NULL);
    }

    ready_queue_destroy();
    finalize_stats();

    if(stats_get_speed_mode()==0) {
        uint64_t total_time = get_global_sim_time();
        printf("\033[96m╔══════════════════════════════════════════════╗\n");
        printf(       "║ SCHEDULE END => alg=%d => totalTime=%llums    \n",
                      g_current_alg, (unsigned long long)total_time);
        printf(       "║ Stats: preemptions=%llu, totalProcs=%llu     \n",
                      (unsigned long long)g_stats.total_preempts, (unsigned long long)g_stats.total_procs);
        printf(       "║ AvgWait=%.2f, AvgTAT=%.2f, AvgResp=%.2f       \n",
                      g_stats.avg_wait, g_stats.avg_turnaround, g_stats.avg_response);
        printf(       "╚══════════════════════════════════════════════╝\033[0m\n");
        usleep(300000);
    }

    g_process_list = NULL;
    g_list_count   = 0;
}

void scheduler_fetch_report(sched_report_t* out) {
    if(!out) return;
    /* HPC overshadow/overlay => zero normal stats. */
    if(g_stats.HPC_over_mode || g_stats.HPC_overlay_mode) {
        out->avg_wait       = 0.0;
        out->avg_turnaround = 0.0;
        out->avg_response   = 0.0;
        out->preemptions    = 0ULL;
        out->total_procs    = 0ULL;
    } else {
        out->avg_wait       = g_stats.avg_wait;
        out->avg_turnaround = g_stats.avg_turnaround;
        out->avg_response   = g_stats.avg_response;
        out->preemptions    = g_stats.preemptions;
        out->total_procs    = g_stats.total_procs;
    }
}
#ifndef SCHEDULER_H
#define SCHEDULER_H

#include <stdint.h>
#include "process.h"

/*
  Recognized scheduling algorithms
*/
typedef enum {
    ALG_CFS = 0,
    ALG_CFS_SRTF,
    ALG_FIFO,
    ALG_RR,
    ALG_SJF,
    ALG_STRF,
    ALG_HRRN,
    ALG_HRRN_RT,
    ALG_BFS,
    ALG_PRIORITY,
    ALG_HPC_OVERSHADOW,
    ALG_MLFQ,
    ALG_HPC_OVERLAY
} scheduler_alg_t;

/*
   We store final results of scheduling in a schedule_stats_t.
   This helps keep track of average times, preemptions, HPC modes, etc.
*/
typedef struct {
    double avg_wait;
    double avg_turnaround;
    double avg_response;
    unsigned long long preemptions;
    unsigned long long total_procs;

    /* Internal aggregator: sums for final stats. */
    uint64_t total_wait;
    uint64_t total_tat;
    uint64_t total_resp;
    unsigned long long total_preempts;
    int total_count;

    /* If HPC overshadow/overlay => skip normal stats. */
    int HPC_over_mode;
    int HPC_overlay_mode;
} schedule_stats_t;

/*
  A simpler struct to retrieve final scheduling stats
  after a call to scheduler_run().
*/
typedef struct {
    double avg_wait;
    double avg_turnaround;
    double avg_response;
    unsigned long long preemptions;
    unsigned long long total_procs;
} sched_report_t;

/* Select an algorithm. */
void scheduler_select_algorithm(scheduler_alg_t a);

/* Run the scheduling simulation on an array of processes. */
void scheduler_run(process_t* list, int count);

/* Retrieve final stats from last run. */
void scheduler_fetch_report(sched_report_t* out);

/* Access global sim time. Used by ready_queue (e.g. HRRN, MLFQ). */
uint64_t get_global_sim_time(void);

/*
  Provide BFS quantum to the BFS test if BFS is selected.
  If BFS wasn't used, may return leftover or default value.
*/
unsigned long scheduler_get_bfs_quantum(void);

#endif
#include "scoreboard.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

/*
 * scoreboard.c => Implementation with new weighting:
 *   BASIC      => 25%
 *   NORMAL     => 25%
 *   MODES      => 10%
 *   EDGE       => 10%
 *   HIDDEN     => 10%
 *   EXTERNAL   => 10%
 *   SCHED MAST => 10%
 *
 * The sum is 100% across 7 categories.
 * Scheduling mastery is scored from up to 15 points, scaled to 0..100,
 * then that result is multiplied by 10% (0.10) for final contribution.
 */

/* Global scoreboard structure */
static scoreboard_t gSB = {
    /* test totals and passes: */
    0,0, 0,0, 0,0, 0,0, 0,0, 0,0,
    /* scheduling mastery flags: */
    0,0,0,0,0, 0,0,0,0,0,0,0,
    /* computed percentages for each suite: */
    0.0,0.0,0.0,0.0,0.0,0.0,
    /* pass threshold (e.g. 60.0) */
    60.0
};

/* Utility: read entire file into memory */
static char* read_file_all(const char* path) {
    FILE* f = fopen(path, "rb");
    if(!f) return NULL;
    fseek(f, 0, SEEK_END);
    long sz = ftell(f);
    if(sz < 0) {
        fclose(f);
        return NULL;
    }
    fseek(f, 0, SEEK_SET);

    char* buf = (char*)malloc((size_t)sz + 1);
    if(!buf) {
        fclose(f);
        return NULL;
    }
    if(fread(buf, 1, (size_t)sz, f) != (size_t)sz) {
        fclose(f);
        free(buf);
        return NULL;
    }
    buf[sz] = '\0';
    fclose(f);
    return buf;
}

/* Simple JSON parse helper for int */
static int parse_json_int(const char* json, const char* key, int def) {
    if(!json || !key) return def;
    char pattern[128];
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    char* found = strstr(json, pattern);
    if(!found) return def;
    char* colon = strstr(found, ":");
    if(!colon) return def;
    colon++;
    while(*colon==' '||*colon=='\t') colon++;
    int val = def;
    sscanf(colon, "%d", &val);
    return val;
}

/* Simple JSON parse helper for double */
static double parse_json_double(const char* json, const char* key, double def) {
    if(!json || !key) return def;
    char pattern[128];
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    char* found = strstr(json, pattern);
    if(!found) return def;
    char* colon = strstr(found, ":");
    if(!colon) return def;
    colon++;
    while(*colon==' '||*colon=='\t') colon++;
    double val = def;
    sscanf(colon, "%lf", &val);
    return val;
}

/* Write scoreboard to scoreboard.json */
static void write_scoreboard_json(const scoreboard_t* sb) {
    FILE* f = fopen("scoreboard.json", "w");
    if(!f) return;

    fprintf(f, "{\n");
    /* test totals + passes */
    fprintf(f, "  \"basic_total\": %d,\n",    sb->basic_total);
    fprintf(f, "  \"basic_pass\": %d,\n",     sb->basic_pass);
    fprintf(f, "  \"normal_total\": %d,\n",   sb->normal_total);
    fprintf(f, "  \"normal_pass\": %d,\n",    sb->normal_pass);
    fprintf(f, "  \"external_total\": %d,\n", sb->external_total);
    fprintf(f, "  \"external_pass\": %d,\n",  sb->external_pass);
    fprintf(f, "  \"modes_total\": %d,\n",    sb->modes_total);
    fprintf(f, "  \"modes_pass\": %d,\n",     sb->modes_pass);
    fprintf(f, "  \"edge_total\": %d,\n",     sb->edge_total);
    fprintf(f, "  \"edge_pass\": %d,\n",      sb->edge_pass);
    fprintf(f, "  \"hidden_total\": %d,\n",   sb->hidden_total);
    fprintf(f, "  \"hidden_pass\": %d,\n",    sb->hidden_pass);

    /* schedule mastery flags */
    fprintf(f, "  \"sc_fifo\": %d,\n",      sb->sc_fifo);
    fprintf(f, "  \"sc_rr\": %d,\n",        sb->sc_rr);
    fprintf(f, "  \"sc_cfs\": %d,\n",       sb->sc_cfs);
    fprintf(f, "  \"sc_cfs_srtf\": %d,\n",  sb->sc_cfs_srtf);
    fprintf(f, "  \"sc_bfs\": %d,\n",       sb->sc_bfs);
    fprintf(f, "  \"sc_sjf\": %d,\n",       sb->sc_sjf);
    fprintf(f, "  \"sc_strf\": %d,\n",      sb->sc_strf);
    fprintf(f, "  \"sc_hrrn\": %d,\n",      sb->sc_hrrn);
    fprintf(f, "  \"sc_hrrn_rt\": %d,\n",   sb->sc_hrrn_rt);
    fprintf(f, "  \"sc_priority\": %d,\n",  sb->sc_priority);
    fprintf(f, "  \"sc_hpc_over\": %d,\n",  sb->sc_hpc_over);
    fprintf(f, "  \"sc_mlfq\": %d,\n",      sb->sc_mlfq);

    /* percentages */
    fprintf(f, "  \"basic_percent\": %.3f,\n",    sb->basic_percent);
    fprintf(f, "  \"normal_percent\": %.3f,\n",   sb->normal_percent);
    fprintf(f, "  \"external_percent\": %.3f,\n", sb->external_percent);
    fprintf(f, "  \"modes_percent\": %.3f,\n",    sb->modes_percent);
    fprintf(f, "  \"edge_percent\": %.3f,\n",     sb->edge_percent);
    fprintf(f, "  \"hidden_percent\": %.3f,\n",   sb->hidden_percent);

    /* pass threshold */
    fprintf(f, "  \"pass_threshold\": %.1f\n",    sb->pass_threshold);
    fprintf(f, "}\n");

    fclose(f);
}

/* scoreboard_init() / scoreboard_close() => no-op */
void scoreboard_init(void) {}
void scoreboard_close(void) {}

/* Load from scoreboard.json */
void scoreboard_load(void) {
    char* json = read_file_all("scoreboard.json");
    if(!json) return;

    gSB.basic_total    = parse_json_int(json,"basic_total",    gSB.basic_total);
    gSB.basic_pass     = parse_json_int(json,"basic_pass",     gSB.basic_pass);
    gSB.normal_total   = parse_json_int(json,"normal_total",   gSB.normal_total);
    gSB.normal_pass    = parse_json_int(json,"normal_pass",    gSB.normal_pass);
    gSB.external_total = parse_json_int(json,"external_total", gSB.external_total);
    gSB.external_pass  = parse_json_int(json,"external_pass",  gSB.external_pass);
    gSB.modes_total    = parse_json_int(json,"modes_total",    gSB.modes_total);
    gSB.modes_pass     = parse_json_int(json,"modes_pass",     gSB.modes_pass);
    gSB.edge_total     = parse_json_int(json,"edge_total",     gSB.edge_total);
    gSB.edge_pass      = parse_json_int(json,"edge_pass",      gSB.edge_pass);
    gSB.hidden_total   = parse_json_int(json,"hidden_total",   gSB.hidden_total);
    gSB.hidden_pass    = parse_json_int(json,"hidden_pass",    gSB.hidden_pass);

    gSB.sc_fifo     = parse_json_int(json,"sc_fifo",     gSB.sc_fifo);
    gSB.sc_rr       = parse_json_int(json,"sc_rr",       gSB.sc_rr);
    gSB.sc_cfs      = parse_json_int(json,"sc_cfs",      gSB.sc_cfs);
    gSB.sc_cfs_srtf = parse_json_int(json,"sc_cfs_srtf", gSB.sc_cfs_srtf);
    gSB.sc_bfs      = parse_json_int(json,"sc_bfs",      gSB.sc_bfs);
    gSB.sc_sjf      = parse_json_int(json,"sc_sjf",      gSB.sc_sjf);
    gSB.sc_strf     = parse_json_int(json,"sc_strf",     gSB.sc_strf);
    gSB.sc_hrrn     = parse_json_int(json,"sc_hrrn",     gSB.sc_hrrn);
    gSB.sc_hrrn_rt  = parse_json_int(json,"sc_hrrn_rt",  gSB.sc_hrrn_rt);
    gSB.sc_priority = parse_json_int(json,"sc_priority", gSB.sc_priority);
    gSB.sc_hpc_over = parse_json_int(json,"sc_hpc_over", gSB.sc_hpc_over);
    gSB.sc_mlfq     = parse_json_int(json,"sc_mlfq",     gSB.sc_mlfq);

    gSB.basic_percent    = parse_json_double(json,"basic_percent",    gSB.basic_percent);
    gSB.normal_percent   = parse_json_double(json,"normal_percent",   gSB.normal_percent);
    gSB.external_percent = parse_json_double(json,"external_percent", gSB.external_percent);
    gSB.modes_percent    = parse_json_double(json,"modes_percent",    gSB.modes_percent);
    gSB.edge_percent     = parse_json_double(json,"edge_percent",     gSB.edge_percent);
    gSB.hidden_percent   = parse_json_double(json,"hidden_percent",   gSB.hidden_percent);

    gSB.pass_threshold   = parse_json_double(json,"pass_threshold",   gSB.pass_threshold);

    free(json);
}

/* Recompute pass% from total/pass counts */
static void recompute_pass_percents(void) {
    if(gSB.basic_total > 0)
        gSB.basic_percent = (100.0 * (double)gSB.basic_pass) / (double)gSB.basic_total;
    else
        gSB.basic_percent = 0.0;

    if(gSB.normal_total > 0)
        gSB.normal_percent = (100.0 * (double)gSB.normal_pass) / (double)gSB.normal_total;
    else
        gSB.normal_percent = 0.0;

    if(gSB.external_total > 0)
        gSB.external_percent = (100.0 * (double)gSB.external_pass) / (double)gSB.external_total;
    else
        gSB.external_percent = 0.0;

    if(gSB.modes_total > 0)
        gSB.modes_percent = (100.0 * (double)gSB.modes_pass) / (double)gSB.modes_total;
    else
        gSB.modes_percent = 0.0;

    if(gSB.edge_total > 0)
        gSB.edge_percent = (100.0 * (double)gSB.edge_pass) / (double)gSB.edge_total;
    else
        gSB.edge_percent = 0.0;

    if(gSB.hidden_total > 0)
        gSB.hidden_percent = (100.0 * (double)gSB.hidden_pass) / (double)gSB.hidden_total;
    else
        gSB.hidden_percent = 0.0;
}

/*
  The chain unlocking logic:
    BASIC => always unlocked
    NORMAL => unlocked if BASIC >= pass_threshold
    EXTERNAL => unlocked if NORMAL >= pass_threshold
    MODES => unlocked if EXTERNAL >= pass_threshold
    EDGE => unlocked if MODES >= pass_threshold
    HIDDEN => unlocked if EDGE >= pass_threshold
*/
static int is_suite_unlocked(scoreboard_suite_t suite) {
    if(suite == SUITE_BASIC) {
        return 1;
    }
    double T = gSB.pass_threshold;
    switch(suite) {
        case SUITE_NORMAL:
            return (gSB.basic_percent >= T) ? 1 : 0;
        case SUITE_EXTERNAL:
            return (gSB.normal_percent >= T) ? 1 : 0;
        case SUITE_MODES:
            return (gSB.normal_percent >= T) ? 1 : 0;
        case SUITE_EDGE:
            return (gSB.modes_percent >= T) ? 1 : 0;
        case SUITE_HIDDEN:
            return (gSB.edge_percent >= T) ? 1 : 0;
        default:
            return 0;
    }
}

/* BFS=2, HPC=2, MLFQ=2, others=1 => up to 15 points */
static int get_scheduler_points(void) {
    int points = 0;
    if(gSB.sc_fifo)         points += 2;
    if(gSB.sc_rr)           points += 2;
    if(gSB.sc_cfs)          points += 1;
    if(gSB.sc_cfs_srtf)     points += 1;
    if(gSB.sc_bfs)          points += 1;
    if(gSB.sc_sjf)          points += 2;
    if(gSB.sc_strf)         points += 1;
    if(gSB.sc_hrrn)         points += 1;
    if(gSB.sc_hrrn_rt)      points += 1;
    if(gSB.sc_priority)     points += 1;
    if(gSB.sc_hpc_over)     points += 1;
    if(gSB.sc_mlfq)         points += 1;
    return points;
}

/* Save scoreboard => JSON after recomputing percentages */
void scoreboard_save(void) {
    recompute_pass_percents();
    write_scoreboard_json(&gSB);
}

/* Clear scoreboard entirely and set pass_threshold=60.0 default */
void scoreboard_clear(void) {
    memset(&gSB, 0, sizeof(gSB));
    gSB.pass_threshold = 60.0;
    scoreboard_save();
}

/* Return a copy of the scoreboard struct */
void get_scoreboard(scoreboard_t* out) {
    if(out) {
        *out = gSB;
    }
}

/*
  Weighted final score => integer from 0..100
   - BASIC:    25%
   - NORMAL:   25%
   - MODES:    10%
   - EDGE:     10%
   - HIDDEN:   10%
   - EXTERNAL: 10%
   - SCHEDULING MASTERY: 10%
*/
int scoreboard_get_final_score(void) {
    recompute_pass_percents();

    double b  = gSB.basic_percent    * 0.25;  /* 25%  */
    double n  = gSB.normal_percent   * 0.25;  /* 25%  */
    double mo = gSB.modes_percent    * 0.10;  /* 10%  */
    double ed = gSB.edge_percent     * 0.10;  /* 10%  */
    double hi = gSB.hidden_percent   * 0.10;  /* 10%  */
    double ex = gSB.external_percent * 0.10;  /* 10%  */

    /* scheduling mastery => 10% portion */
    int sched_pts = get_scheduler_points();  /* up to 15 => map to 0..100 => scaled => then 10% portion */
    double sched_percent = ((double)sched_pts / 15.0) * 100.0;
    double s = sched_percent * 0.10;

    double total = b + n + mo + ed + hi + ex + s;
    if(total > 100.0) total=100.0;
    if(total < 0.0)   total=0.0;
    return (int)(total + 0.5);
}

/* Return whether the given suite is unlocked */
int scoreboard_is_unlocked(scoreboard_suite_t suite) {
    recompute_pass_percents();
    return is_suite_unlocked(suite);
}

/* Mark an algorithm as "mastered" => for scheduling mastery points */
void scoreboard_set_sc_mastered(scheduler_alg_t alg) {
    switch(alg) {
        case ALG_FIFO:          gSB.sc_fifo      = 1; break;
        case ALG_RR:            gSB.sc_rr        = 1; break;
        case ALG_CFS:           gSB.sc_cfs       = 1; break;
        case ALG_CFS_SRTF:      gSB.sc_cfs_srtf  = 1; break;
        case ALG_BFS:           gSB.sc_bfs       = 1; break;
        case ALG_SJF:           gSB.sc_sjf       = 1; break;
        case ALG_STRF:          gSB.sc_strf      = 1; break;
        case ALG_HRRN:          gSB.sc_hrrn      = 1; break;
        case ALG_HRRN_RT:       gSB.sc_hrrn_rt   = 1; break;
        case ALG_PRIORITY:      gSB.sc_priority  = 1; break;
        case ALG_HPC_OVERSHADOW:gSB.sc_hpc_over  = 1; break;
        case ALG_MLFQ:          gSB.sc_mlfq      = 1; break;
        default:
            break;
    }
}

/* Increment basic test stats */
void scoreboard_update_basic(int total, int pass) {
    gSB.basic_total += total;
    gSB.basic_pass  += pass;
}

/* Increment normal test stats */
void scoreboard_update_normal(int total, int pass) {
    gSB.normal_total += total;
    gSB.normal_pass  += pass;
}

/* Increment external test stats */
void scoreboard_update_external(int total, int pass) {
    gSB.external_total += total;
    gSB.external_pass  += pass;
}

/* Increment modes test stats */
void scoreboard_update_modes(int total, int pass) {
    gSB.modes_total += total;
    gSB.modes_pass  += pass;
}

/* Increment edge test stats */
void scoreboard_update_edge(int total, int pass) {
    gSB.edge_total += total;
    gSB.edge_pass  += pass;
}

/* Increment hidden test stats */
void scoreboard_update_hidden(int total, int pass) {
    gSB.hidden_total += total;
    gSB.hidden_pass  += pass;
}
#ifndef SCOREBOARD_H
#define SCOREBOARD_H

#include "scheduler.h"

/* Enum to identify a test suite. */
typedef enum {
    SUITE_BASIC = 1,
    SUITE_NORMAL,
    SUITE_EXTERNAL,
    SUITE_MODES,
    SUITE_EDGE,
    SUITE_HIDDEN,
    SUITE_COUNT
} scoreboard_suite_t;

/*
  Structure for scoreboard data.
*/
typedef struct {
    int basic_total,    basic_pass;
    int normal_total,   normal_pass;
    int external_total, external_pass;
    int modes_total,    modes_pass;
    int edge_total,     edge_pass;
    int hidden_total,   hidden_pass;

    /* Mastery flags for scheduling algorithms. */
    int sc_fifo, sc_rr, sc_cfs, sc_cfs_srtf, sc_bfs;
    int sc_sjf, sc_strf, sc_hrrn, sc_hrrn_rt, sc_priority;
    int sc_hpc_over, sc_mlfq;

    double basic_percent;
    double normal_percent;
    double external_percent;
    double modes_percent;
    double edge_percent;
    double hidden_percent;

    /* Passing threshold for unlocking next suite. */
    double pass_threshold;
} scoreboard_t;

/* Initialize scoreboard (no-op). */
void scoreboard_init(void);

/* Close scoreboard (no-op). */
void scoreboard_close(void);

/* Load from scoreboard.json -> internal scoreboard. */
void scoreboard_load(void);

/* Save scoreboard -> scoreboard.json. */
void scoreboard_save(void);

/* Clear scoreboard entirely. */
void scoreboard_clear(void);

/* Retrieve scoreboard snapshot. */
void get_scoreboard(scoreboard_t* out);

/* Returns final overall score (0..100). */
int  scoreboard_get_final_score(void);

/* Mark that we have "mastered" a scheduling algorithm. */
void scoreboard_set_sc_mastered(scheduler_alg_t alg);

/* Update raw counts for each test suite. */
void scoreboard_update_basic(int total, int pass);
void scoreboard_update_normal(int total, int pass);
void scoreboard_update_external(int total,int pass);
void scoreboard_update_modes(int total,int pass);
void scoreboard_update_edge(int total,int pass);
void scoreboard_update_hidden(int total,int pass);

/* Check if suite is unlocked. (Basic is always unlocked at game start.) */
int scoreboard_is_unlocked(scoreboard_suite_t suite);

#endif
#include "stats.h"
#include <stdio.h>
#include <string.h>
#include "safe_calls_library.h"

/* Global stats object. */
static stats_t g_stats;

void stats_init(void) {
    memset(&g_stats, 0, sizeof(g_stats));
    g_stats.speed_mode = 0; /* default => normal speed */
}

void stats_get(stats_t* out) {
    if(out) {
        *out = g_stats;
    }
}

void stats_set_speed_mode(int mode) {
    g_stats.speed_mode = (mode != 0) ? 1 : 0;
}

int stats_get_speed_mode(void) {
    return g_stats.speed_mode;
}

void stats_inc_signal_sigint(void) {
    g_stats.signals_received_sigint++;
}
void stats_inc_signal_sigterm(void) {
    g_stats.signals_received_sigterm++;
}
void stats_inc_signal_other(void) {
    g_stats.signals_received_others++;
}
void stats_inc_concurrency_runs(void) {
    g_stats.concurrency_runs++;
}
void stats_inc_processes_spawned(void) {
    g_stats.processes_spawned++;
}
void stats_inc_containers_created(void) {
    g_stats.containers_created++;
}
void stats_inc_containers_removed(void) {
    g_stats.containers_removed++;
}
void stats_inc_tests_passed(int count) {
    g_stats.tests_passed += count;
}
void stats_inc_tests_failed(int count) {
    g_stats.tests_failed += count;
}
void stats_inc_concurrency_commands(int n) {
    g_stats.concurrency_commands_run += n;
}

/*
  Print final stats with nice ASCII box.
*/
void stats_print_summary(void) {
    printf(CLR_BOLD CLR_CYAN "\n╔═══════════════════ FINAL STATS ═════════════════╗\n");
    printf("║ Speed Mode            : %s\n", g_stats.speed_mode ? "FAST" : "NORMAL");
    printf("║ Signals (SIGINT)      : %d\n", g_stats.signals_received_sigint);
    printf("║ Signals (SIGTERM)     : %d\n", g_stats.signals_received_sigterm);
    printf("║ Signals (Others)      : %d\n", g_stats.signals_received_others);
    printf("║ Concurrency Runs      : %d\n", g_stats.concurrency_runs);
    printf("║ Processes Spawned     : %d\n", g_stats.processes_spawned);
    printf("║ Containers Created    : %d\n", g_stats.containers_created);
    printf("║ Containers Removed    : %d\n", g_stats.containers_removed);
    printf("║ Tests Passed          : %d\n", g_stats.tests_passed);
    printf("║ Tests Failed          : %d\n", g_stats.tests_failed);
    printf("║ Concurrency Cmds Run  : %d\n", g_stats.concurrency_commands_run);
    printf("╚═════════════════════════════════════════════════╝\n" CLR_RESET);
}
#ifndef STATS_H
#define STATS_H

/*
   stats.h => a global struct tracking concurrency usage, signals, tests, etc.
   Also color macros for convenient printing.
*/

typedef struct {
    int signals_received_sigint;
    int signals_received_sigterm;
    int signals_received_others;

    int concurrency_runs;
    int processes_spawned;
    int containers_created;
    int containers_removed;

    int tests_passed;
    int tests_failed;

    /* speed_mode: 0 => normal, 1 => fast */
    int speed_mode;

    /* track total concurrency commands issued in runner. */
    int concurrency_commands_run;

} stats_t;

/* Initialize global stats. */
void stats_init(void);

/* Get the global stats. */
void stats_get(stats_t* out);

/* set speed_mode (0 or 1). */
void stats_set_speed_mode(int mode);

/* get speed_mode. */
int stats_get_speed_mode(void);

/* increments for various tracked fields. */
void stats_inc_signal_sigint(void);
void stats_inc_signal_sigterm(void);
void stats_inc_signal_other(void);
void stats_inc_concurrency_runs(void);
void stats_inc_processes_spawned(void);
void stats_inc_containers_created(void);
void stats_inc_containers_removed(void);
void stats_inc_tests_passed(int count);
void stats_inc_tests_failed(int count);
void stats_inc_concurrency_commands(int n);

/* Print them in a block at program end. */
void stats_print_summary(void);

#endif
#include "worker.h"
#include "stats.h"
#include <stdio.h>
#include <unistd.h>

/*
  We drastically reduce real-time sleeps to ensure that
  in FAST mode, all tests can finish under ~5 seconds total.

  We'll define a new scaling:
    - In NORMAL mode: usleep(slice_ms * 20000)
    - In FAST mode:   usleep(slice_ms * 2000)
  This is a ~10x difference. That should keep normal mode somewhat slow
  and fast mode quite quick.
*/

void simulate_process_partial(process_t* p, unsigned long slice_ms, int core_id) {
    if (!p || slice_ms == 0) return;

    if(stats_get_speed_mode() == 0) {
        /* NORMAL mode => bigger sleep for user-friendly pacing */
        usleep((useconds_t)(slice_ms * 20000U));
    } else {
        /* FAST mode => short sleep to finish quickly slice_ms = 1/50 */
        usleep((useconds_t)(slice_ms * 2000U));
    }
}
#ifndef WORKER_H
#define WORKER_H

#include "process.h"

/*
  Worker simulation => runs a process for some (partial) timeslice
  by sleeping that many ms in real-time (scaled for concurrency).
*/

/* Simulate a partial run of 'p' for slice_ms. */
void simulate_process_partial(process_t* p, unsigned long slice_ms, int core_id);

#endif
#include "basic-test.h"
#include "test_common.h"

#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include "../src/worker.h"

#include <stdio.h>
#include <math.h>

/* Global counters for run_basic_tests() usage: */
static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

/* Helper: approximate float eq */
static int almost_equal(double a, double b, double eps) {
    return (fabs(a - b) < eps);
}

/* ---------- Actual test functions ---------- */
static bool test_fifo(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 1, 0);
    init_process(&p[1], 5, 1, 0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.5, t=5.5, r=1.5;
    if (!almost_equal(rep.avg_wait, w, 0.1) ||
        !almost_equal(rep.avg_turnaround, t, 0.1) ||
        !almost_equal(rep.avg_response, r, 0.1) ||
        rep.preemptions != 0ULL)
    {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_fifo => mismatch, got W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_FIFO);
    return true;
}

static bool test_rr(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0], 2, 1, 0);
    init_process(&p[1], 2, 1, 0);

    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.0, t=3.0, r=1.0;
    if (!almost_equal(rep.avg_wait, w, 0.2) ||
        !almost_equal(rep.avg_turnaround, t, 0.2) ||
        !almost_equal(rep.avg_response, r, 0.2) ||
        rep.preemptions != 0ULL)
    {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_rr => mismatch, got W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_RR);
    return true;
}

static bool test_cfs(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 0, 0);
    init_process(&p[1], 4, 0, 0);

    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.5, t=5.0, r=1.5;
    if (!almost_equal(rep.avg_wait, w, 0.2) ||
        !almost_equal(rep.avg_turnaround, t, 0.3) ||
        !almost_equal(rep.avg_response, r, 0.2) ||
        rep.preemptions != 0ULL)
    {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_cfs => mismatch => W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS);
    return true;
}

/*
   BFS test => disallow zero preemptions.
   We do a "dummy run" to set BFS quantum, then run a big process => must see preemptions>=1.
*/
static bool test_bfs(void) {
    g_tests_run++;
    os_init();

    /* 1) Dummy BFS run with small process => BFS sets quantum. */
    process_t dummy[1];
    init_process(&dummy[0], 1, 1, 0); /* burst=1 */
    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(dummy, 1);

    unsigned long q = scheduler_get_bfs_quantum();

    /* 2) Real BFS test => one big process => burst=(q+2). BFS must do at least one preemption. */
    process_t bigP[1];
    init_process(&bigP[0], q+2, 1, 0); /* bigger than BFS quantum => must preempt */

    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(bigP, 1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.preemptions < 1) {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_bfs => zero preemption is NOT fine => BFS quantum=%lu => single burst=%lu => preempts=%llu => FAIL",
                 q, (unsigned long)(q+2), (unsigned long long)rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }

    /* If we get here => BFS had at least 1 preemption => pass. */
    scoreboard_set_sc_mastered(ALG_BFS);
    return true;
}

static bool test_pipeline(void) {
    g_tests_run++;
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}

static bool test_distributed(void) {
    g_tests_run++;
    os_init();
    os_run_distributed_example();
    os_cleanup();
    return true;
}

static bool test_fifo_strict(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 10, 0);
    init_process(&p[1], 4, 20, 0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.preemptions != 0ULL) {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_fifo_strict => mismatch => preempt=%llu",
                 rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

/* Array of all basic tests so we can run them individually or in bulk */
typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} basic_tests[] = {
    { "fifo",           test_fifo },
    { "rr",             test_rr },
    { "cfs",            test_cfs },
    { "bfs",            test_bfs },
    { "pipeline",       test_pipeline },
    { "distributed",    test_distributed },
    { "fifo_strict",    test_fifo_strict },
};
static const int BASIC_COUNT = sizeof(basic_tests)/sizeof(basic_tests[0]);

/* Public API: get number of tests in Basic suite */
int basic_test_count(void) {
    return BASIC_COUNT;
}

/* Public API: get name of ith test in Basic suite */
const char* basic_test_name(int i) {
    if(i<0 || i>=BASIC_COUNT) return NULL;
    return basic_tests[i].name;
}

/* Public API: run the ith single test in Basic suite.
   pass_out=1 if test passed, else 0.
*/
void basic_test_run_single(int i, int* pass_out) {
    if(!pass_out) return;
    if(i<0 || i>=BASIC_COUNT) {
        *pass_out=0;
        return;
    }
    /* reset counters for single test run */
    g_tests_run=0;
    g_tests_failed=0;
    memset(g_fail_reason,0,sizeof(g_fail_reason));

    /* run it */
    bool ok = basic_tests[i].func();
    if(!ok) {
        *pass_out=0;
        return;
    }
    /* if not failed => pass */
    *pass_out = (g_tests_failed==0) ? 1 : 0;
}

/* Public API: run all Basic tests in a row */
void run_basic_tests(int* total, int* passed){
    g_tests_run=0;
    g_tests_failed=0;
    memset(g_fail_reason,0,sizeof(g_fail_reason));

    printf("\n" CLR_BOLD CLR_YELLOW "╔════════════ BASIC TESTS START ═════════════╗" CLR_RESET "\n");
    for(int i=0; i<BASIC_COUNT; i++){
        bool ok = basic_tests[i].func();
        if(ok) {
            printf("  PASS: %s\n", basic_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n",
                   basic_tests[i].name,
                   test_get_fail_reason());
        }
    }

    *total  = g_tests_run;
    *passed = g_tests_run - g_tests_failed;

    printf(CLR_BOLD CLR_YELLOW "╔══════════════════════════════════════════════╗\n");
    printf("║       BASIC TESTS RESULTS: %d / %d passed      ║\n", *passed, *total);
    if(*passed < *total) {
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\n" CLR_RESET);
}
#ifndef BASIC_TEST_H
#define BASIC_TEST_H

/*
  Basic tests: FIFO, RR, CFS, BFS, pipeline, distributed, etc.
  We also provide single-test picking if needed.
*/

void run_basic_tests(int* total,int* passed);
int basic_test_count(void);
void basic_test_run_single(int i, int* pass_out);

#endif
#include "edge-test.h"
#include "test_common.h"

#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

static int almost_equal(double a, double b, double eps) {
    return (fabs(a - b) < eps);
}

static bool test_extreme_long(void) {
    g_tests_run++;
    os_init();
    process_t p[1];
    init_process(&p[0],50,2,0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=1 || rep.preemptions!=0ULL) {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_extreme_long => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    /* partial check of W/T */
    if(!almost_equal(rep.avg_wait,0.0,0.9) ||
       !almost_equal(rep.avg_turnaround,50.0,5.0))
    {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_extreme_long => stats mismatch => W=%.2f,T=%.2f",
                 rep.avg_wait, rep.avg_turnaround);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_extreme_short(void) {
    g_tests_run++;
    os_init();
    process_t p[1];
    init_process(&p[0],1,2,0);

    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=1 || rep.preemptions!=0ULL) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_extreme_short => mismatch => procs=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    if(!almost_equal(rep.avg_wait, 0.0, 0.5) ||
       !almost_equal(rep.avg_turnaround,1.0,0.5))
    {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_extreme_short => mismatch => W=%.2f,T=%.2f",
                 rep.avg_wait, rep.avg_turnaround);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_high_load(void) {
    g_tests_run++;
    os_init();
    process_t arr[10];
    for(int i=0;i<10;i++){
        init_process(&arr[i],3+(i%3), 1, 0);
    }
    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(arr,10);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs != 10) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_high_load => mismatch => total=%llu",
                 rep.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_hpc_under_load(void) {
    g_tests_run++;
    os_init();
    os_run_hpc_overshadow();
    os_cleanup();
    return true;
}

static bool test_container_spam(void) {
    g_tests_run++;
    os_init();
    for (int i=0;i<3;i++){
        os_create_ephemeral_container();
    }
    for (int i=0;i<3;i++){
        os_remove_ephemeral_container();
    }
    os_cleanup();
    return true;
}

static bool test_pipeline_edge(void) {
    g_tests_run++;
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}

static bool test_multi_distrib(void) {
    g_tests_run++;
    os_init();
    for(int i=0;i<3;i++){
        os_run_distributed_example();
    }
    os_cleanup();
    return true;
}

typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} edge_tests[] = {
    {"extreme_long",   test_extreme_long},
    {"extreme_short",  test_extreme_short},
    {"high_load",      test_high_load},
    {"hpc_under_load", test_hpc_under_load},
    {"container_spam", test_container_spam},
    {"pipeline_edge",  test_pipeline_edge},
    {"multi_distrib",  test_multi_distrib}
};
static const int EDGE_COUNT = sizeof(edge_tests)/sizeof(edge_tests[0]);

int edge_test_count(void){ return EDGE_COUNT; }
const char* edge_test_name(int i){
    if(i<0||i>=EDGE_COUNT) return NULL;
    return edge_tests[i].name;
}

void edge_test_run_single(int i,int* pass_out){
    if(!pass_out) return;
    if(i<0||i>=EDGE_COUNT){
        *pass_out=0;
        return;
    }
    g_tests_run=0;
    g_tests_failed=0;
    bool ok = edge_tests[i].func();
    *pass_out = (ok && g_tests_failed==0) ? 1 : 0;
}

void run_edge_tests(int* total,int* passed){
    g_tests_run=0;
    g_tests_failed=0;

    printf("\n\033[1m\033[93m╔════════════ EDGE TESTS START ═══════════╗\033[0m\n");
    for(int i=0;i<EDGE_COUNT;i++){
        bool ok = edge_tests[i].func();
        if(ok){
            printf("  PASS: %s\n", edge_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n", edge_tests[i].name, test_get_fail_reason());
        }
    }

    *total = g_tests_run;
    *passed= (g_tests_run - g_tests_failed);

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║      EDGE TESTS RESULTS: %d / %d passed        ║\n", *passed, *total);
    if(*passed < *total){
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef EDGE_TEST_H
#define EDGE_TEST_H

/* Edge tests: extreme bursts, HPC under load, container spam, pipeline, etc. */

void run_edge_tests(int* total,int* passed);
int edge_test_count(void);
void edge_test_run_single(int i, int* pass_out);

#endif
#include "external-test.h"

#include "../src/runner.h"    // for run_shell_commands_concurrently()
#include "../src/safe_calls_library.h"
#include "../src/stats.h"
#include "../src/os.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/wait.h>

/*
  We'll define 12 external tests, each one tries to run the external shell
  with a small concurrency scenario under scheduling mode i.

  If the external shell binary is not found, all fail with a message.
*/

static int g_tests_run_ext    = 0;
static int g_tests_failed_ext = 0;
static char g_fail_reason[256] = {0};

/* We want to check presence of "shell-tp1-implementation". */
static int check_shell_binary(void) {
    if(access("../../shell-tp1-implementation", X_OK) != 0) {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "shell-tp1-implementation NOT FOUND => all tests fail");
        return 0;
    }
    return 1;
}

/* A small helper that actually does the concurrency run for schedule mode `m`. */
static int do_external_test_for_mode(int m) {
    // We'll do a short concurrency scenario: 2 shell commands, 1 core.
    // The "sleep" commands must be typed into the shell.
    // run_shell_commands_concurrently(count=2, lines=..., coreCount=1, mode=m, allModes=0)
    // If it runs without error or SIGTERM, we consider it "pass".
    // We'll also do HPC-OVER (mode=10), which just spawns HPC overshadow.
    // The underlying runner checks if the shell is missing or not.
    // We'll interpret "pass" if we do not forcibly SIGKILL or error out.

    // We'll create 2 lines:
    char* lines[2];
    lines[0] = strdup("sleep 1");
    lines[1] = strdup("sleep 2");

    // Clear concurrency stop flag first
    set_os_concurrency_stop_flag(0);

    // We'll run it. If the shell is missing, the code prints an error,
    // but we won't directly have a runtime "error" code. We'll assume we can detect that in check_shell_binary() above.
    run_shell_commands_concurrently(2, lines, /*coreCount=*/1, m, /*allModes=*/0);

    free(lines[0]);
    free(lines[1]);

    // We do not have a perfect "success/fail" signal from run_shell_commands_concurrently,
    // but if we didn't see that the shell was missing (check_shell_binary()) and didn't forcibly SIGTERM,
    // let's consider it "pass".
    return 1;
}

/*
  We define each of the 12 test functions:
*/
static int test_schedule_mode_0_fifo(void)          { return do_external_test_for_mode(0); }
static int test_schedule_mode_1_rr(void)            { return do_external_test_for_mode(1); }
static int test_schedule_mode_2_cfs(void)           { return do_external_test_for_mode(2); }
static int test_schedule_mode_3_cfs_srtf(void)      { return do_external_test_for_mode(3); }
static int test_schedule_mode_4_bfs(void)           { return do_external_test_for_mode(4); }
static int test_schedule_mode_5_sjf(void)           { return do_external_test_for_mode(5); }
static int test_schedule_mode_6_strf(void)          { return do_external_test_for_mode(6); }
static int test_schedule_mode_7_hrrn(void)          { return do_external_test_for_mode(7); }
static int test_schedule_mode_8_hrrn_rt(void)       { return do_external_test_for_mode(8); }
static int test_schedule_mode_9_priority(void)      { return do_external_test_for_mode(9); }
static int test_schedule_mode_10_hpc_over(void)     { return do_external_test_for_mode(10); }
static int test_schedule_mode_11_mlfq(void)         { return do_external_test_for_mode(11); }

/* We'll store them in an array for convenience. */
typedef int (*ext_test_fn)(void);
static ext_test_fn external_test_fns[12] = {
    test_schedule_mode_0_fifo,
    test_schedule_mode_1_rr,
    test_schedule_mode_2_cfs,
    test_schedule_mode_3_cfs_srtf,
    test_schedule_mode_4_bfs,
    test_schedule_mode_5_sjf,
    test_schedule_mode_6_strf,
    test_schedule_mode_7_hrrn,
    test_schedule_mode_8_hrrn_rt,
    test_schedule_mode_9_priority,
    test_schedule_mode_10_hpc_over,
    test_schedule_mode_11_mlfq
};

static const char* external_test_names[12] = {
    "FIFO",
    "RR",
    "CFS",
    "CFS-SRTF",
    "BFS",
    "SJF",
    "STRF",
    "HRRN",
    "HRRN-RT",
    "PRIORITY",
    "HPC-OVER",
    "MLFQ"
};

/* We expose external_test_count=12. */
int external_test_count(void) {
    return 12;
}

/* Single test run => i in [0..11]. */
void external_test_run_single(int i, int* pass_out) {
    if(!pass_out) return;
    if(i<0 || i>=12) {
        *pass_out=0;
        return;
    }

    // Start from no fail reason:
    g_fail_reason[0] = '\0';

    g_tests_run_ext++;
    if(!check_shell_binary()) {
        // If the shell is missing, test fails
        g_tests_failed_ext++;
        *pass_out = 0;
        return;
    }
    int ok = external_test_fns[i]();
    if(!ok) {
        g_tests_failed_ext++;
        *pass_out=0;
    } else {
        *pass_out=1;
    }
}

/*
   run_external_tests(&total, &passed) => runs all 12 tests in a row,
   printing pass/fail lines, then prints final summary.
*/
void run_external_tests(int* total, int* passed) {
    if(!total || !passed) return;

    // reset counters
    g_tests_run_ext    = 0;
    g_tests_failed_ext = 0;
    g_fail_reason[0]   = '\0';

    printf("\n" CLR_BOLD CLR_YELLOW "╔════════════ EXTERNAL TESTS START ═══════════╗" CLR_RESET "\n");

    // For i=0..11
    int count = external_test_count();
    for(int i=0; i<count; i++){
        int pass = 0;
        external_test_run_single(i, &pass);
        const char* name = external_test_names[i];
        if(pass) {
            printf("  PASS: %s\n", name);
        } else {
            printf("  FAIL: %s", name);
            if(g_fail_reason[0]) {
                printf(" => %s", g_fail_reason);
            }
            printf("\n");
        }
    }

    // finalize
    *total  = g_tests_run_ext;
    *passed = g_tests_run_ext - g_tests_failed_ext;

    printf(CLR_BOLD CLR_YELLOW "╔══════════════════════════════════════════════╗\n");
    printf("║   EXTERNAL TESTS RESULTS: %d / %d passed       ║\n", *passed, *total);
    if(*passed < *total) {
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\n" CLR_RESET);
}
#ifndef EXTERNAL_TEST_H
#define EXTERNAL_TEST_H

/*
  EXTERNAL TEST SUITE:
   - 12 tests total, one for each scheduling mode:
       0=FIFO,1=RR,2=CFS,3=CFS-SRTF,4=BFS,
       5=SJF,6=STRF,7=HRRN,8=HRRN-RT,
       9=PRIORITY,10=HPC-OVER,11=MLFQ
   - If the external shell binary is missing, all tests fail.
   - Each test spawns shell-tp1-implementation with a small "sleep" concurrency scenario
     via stdin, ensuring the external scheduling is tested.
*/

void run_external_tests(int* total, int* passed);

/* Number of external tests (12). */
int  external_test_count(void);

/* Runs exactly one external test with index i (0..11). pass_out=1 if pass, else 0. */
void external_test_run_single(int i, int* pass_out);

#endif
#include "hidden-test.h"
#include "test_common.h"

#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

static bool test_distrib_heavy(void) {
    g_tests_run++;
    os_init();
    for(int i=0;i<4;i++){
        os_run_distributed_example();
    }
    os_cleanup();
    return true;
}

static bool test_hpc_heavy(void) {
    g_tests_run++;
    os_init();
    process_t dummy[1];
    init_process(&dummy[0],0,0,0);

    for(int i=0;i<2;i++){
        scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
        scheduler_run(dummy,1);
        sched_report_t rep;
        scheduler_fetch_report(&rep);
        if(rep.total_procs!=0){
            snprintf(g_fail_reason,sizeof(g_fail_reason),
                     "test_hpc_heavy => overshadow => got total_procs=%llu, expected=0",
                     rep.total_procs);
            test_set_fail_reason(g_fail_reason);
            g_tests_failed++;
            os_cleanup();
            return false;
        }
    }
    os_cleanup();
    return true;
}

static bool test_container_combo(void) {
    g_tests_run++;
    os_init();
    os_create_ephemeral_container();
    os_run_distributed_example();
    os_run_hpc_overshadow();
    os_remove_ephemeral_container();
    os_cleanup();
    return true;
}

static bool test_scheduling_variety(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    /* SJF first */
    init_process(&p[0],2,1,0);
    init_process(&p[1],6,2,0);
    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs!=2){
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_scheduling_variety => SJF => mismatch => total=%llu",
                 r1.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        os_cleanup();
        return false;
    }

    /* Priority next */
    init_process(&p[0],2,3,0);
    init_process(&p[1],6,1,0);
    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,2);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    os_cleanup();

    if(r2.total_procs!=2){
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_scheduling_variety => Priority => mismatch => total=%llu",
                 r2.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_auto_logic(void) {
    g_tests_run++;
    /* always pass */
    return true;
}

static bool test_final_integration(void) {
    g_tests_run++;
    os_init();
    os_log("Final synergy HPC + container + pipeline + distributed");
    os_create_ephemeral_container();
    os_run_hpc_overshadow();
    os_run_distributed_example();
    os_pipeline_example();
    os_remove_ephemeral_container();
    os_cleanup();
    return true;
}

static bool test_multi_stage_distributed(void) {
    g_tests_run++;
    os_init();
    os_run_distributed_example();

    process_t dummy[1];
    init_process(&dummy[0],0,0,0);
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs!=0){
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_multi_stage_distributed => overshadow #1 => got %llu procs,expected=0",
                 r1.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        os_cleanup();
        return false;
    }

    os_run_distributed_example();
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    os_cleanup();
    if(r2.total_procs!=0){
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_multi_stage_distributed => overshadow #2 => got %llu procs,expected=0",
                 r2.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} hidden_tests[] = {
    {"distrib_heavy",        test_distrib_heavy},
    {"hpc_heavy",            test_hpc_heavy},
    {"container_combo",      test_container_combo},
    {"scheduling_variety",   test_scheduling_variety},
    {"auto_logic",           test_auto_logic},
    {"final_integration",    test_final_integration},
    {"multi_stage_distributed", test_multi_stage_distributed}
};
static const int HIDDEN_COUNT = sizeof(hidden_tests)/sizeof(hidden_tests[0]);

int hidden_test_count(void){ return HIDDEN_COUNT; }
const char* hidden_test_name(int i){
    if(i<0||i>=HIDDEN_COUNT) return NULL;
    return hidden_tests[i].name;
}
void hidden_test_run_single(int i,int* pass_out){
    if(!pass_out) return;
    if(i<0||i>=HIDDEN_COUNT){
        *pass_out=0;
        return;
    }
    g_tests_run=0;
    g_tests_failed=0;
    bool ok = hidden_tests[i].func();
    *pass_out = (ok && g_tests_failed==0)?1:0;
}

void run_hidden_tests(int* total,int* passed){
    g_tests_run=0;
    g_tests_failed=0;

    printf("\n\033[1m\033[93m╔══════════ HIDDEN TESTS START ══════════╗\033[0m\n");
    for(int i=0;i<HIDDEN_COUNT;i++){
        bool ok = hidden_tests[i].func();
        if(ok){
            printf("  PASS: %s\n", hidden_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n", hidden_tests[i].name, test_get_fail_reason());
        }
    }

    *total = g_tests_run;
    *passed= (g_tests_run - g_tests_failed);

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║      HIDDEN TESTS RESULTS: %d / %d passed      ║\n", *passed, *total);
    if(*passed < *total){
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef HIDDEN_TEST_H
#define HIDDEN_TEST_H

/* Hidden tests: synergy HPC + containers + distributed, advanced scheduling variety, etc. */

void run_hidden_tests(int* total,int* passed);
int hidden_test_count(void);
void hidden_test_run_single(int i, int* pass_out);
#endif
#include "modes-test.h"
#include "test_common.h"

#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/process.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

static int almost_equal(double a, double b, double eps) {
    return (fabs(a - b) < eps);
}

/* HPC overshadow */
static bool test_hpc_over(void) {
    g_tests_run++;
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy, 1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=0 || rep.preemptions!=0ULL) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_hpc_over => mismatch => procs=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HPC_OVERSHADOW);
    return true;
}

static bool test_multi_containers(void) {
    g_tests_run++;
    os_init();
    for(int i=0;i<2;i++){
        os_create_ephemeral_container();
    }
    for(int i=0;i<2;i++){
        os_remove_ephemeral_container();
    }
    os_cleanup();
    return true;
}

static bool test_multi_distrib(void) {
    g_tests_run++;
    os_init();
    os_run_distributed_example();
    os_run_distributed_example();
    os_cleanup();
    return true;
}

static bool test_pipeline_modes(void) {
    g_tests_run++;
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}

static bool test_mix_algos(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);
    sched_report_t r1;
    scheduler_fetch_report(&r1);

    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,2);
    sched_report_t r2;
    scheduler_fetch_report(&r2);

    os_cleanup();
    if(r1.total_procs!=2 || r2.total_procs!=2) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_mix_algos => mismatch => r1procs=%llu, r2procs=%llu",
                 r1.total_procs, r2.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_double_hpc(void) {
    g_tests_run++;
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r1;
    scheduler_fetch_report(&r1);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r2;
    scheduler_fetch_report(&r2);

    os_cleanup();

    if(r1.total_procs!=0 || r2.total_procs!=0) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_double_hpc => mismatch => r1=%llu, r2=%llu",
                 r1.total_procs, r2.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_mlfq_check(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0],2,10,0);
    init_process(&p[1],3,20,0);
    init_process(&p[2],4,30,0);

    scheduler_select_algorithm(ALG_MLFQ);
    scheduler_run(p,3);

    sched_report_t r;
    scheduler_fetch_report(&r);
    os_cleanup();

    if(r.total_procs!=3 || r.preemptions<1) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_mlfq_check => mismatch => procs=%llu, preempts=%llu",
                 r.total_procs, r.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_MLFQ);
    return true;
}

/* array of all modes tests */
typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} modes_tests[] = {
    {"hpc_over",        test_hpc_over},
    {"multi_containers",test_multi_containers},
    {"multi_distrib",   test_multi_distrib},
    {"pipeline_modes",  test_pipeline_modes},
    {"mix_algos",       test_mix_algos},
    {"double_hpc",      test_double_hpc},
    {"mlfq_check",      test_mlfq_check}
};
static const int MODES_COUNT = sizeof(modes_tests)/sizeof(modes_tests[0]);

int modes_test_count(void){ return MODES_COUNT; }
const char* modes_test_name(int i){
    if(i<0 || i>=MODES_COUNT) return NULL;
    return modes_tests[i].name;
}
void modes_test_run_single(int i, int* pass_out){
    if(!pass_out) return;
    if(i<0 || i>=MODES_COUNT) {
        *pass_out=0;
        return;
    }
    g_tests_run=0;
    g_tests_failed=0;
    bool ok = modes_tests[i].func();
    *pass_out = (ok && g_tests_failed==0) ? 1 : 0;
}

void run_modes_tests(int* total, int* passed) {
    g_tests_run=0;
    g_tests_failed=0;

    printf("\n\033[1m\033[93m╔══════════ MODES TESTS START ══════════╗\033[0m\n");
    for(int i=0; i<MODES_COUNT; i++){
        bool ok = modes_tests[i].func();
        if(ok){
            printf("  PASS: %s\n", modes_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n", modes_tests[i].name, test_get_fail_reason());
        }
    }

    *total  = g_tests_run;
    *passed = (g_tests_run - g_tests_failed);

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║       MODES TESTS RESULTS: %d / %d passed       ║\n", *passed, *total);
    if(*passed < *total){
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef MODES_TEST_H
#define MODES_TEST_H

/* Modes test: HPC overshadow, BFS, MLFQ, pipeline, containers, etc.*/

void run_modes_tests(int* total,int* passed);
int modes_test_count(void);
void modes_test_run_single(int i, int* pass_out);

#endif
#include "normal-test.h"
#include "test_common.h"

#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/os.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

static int almost_equal(double a, double b, double eps) {
    return (fabs(a-b) < eps);
}

/* Test functions */
static bool test_sjf(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0],1,1,0);
    init_process(&p[1],5,1,0);
    init_process(&p[2],2,1,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(!(almost_equal(rep.avg_wait, 1.33, 0.5) &&
         almost_equal(rep.avg_turnaround, 4.0, 0.5) &&
         almost_equal(rep.avg_response, 1.33, 0.5) &&
         rep.preemptions==0ULL))
    {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
            "test_sjf => mismatch => W=%.2f,T=%.2f,R=%.2f, pre=%llu",
            rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_SJF);
    return true;
}

static bool test_strf(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0],4,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_STRF);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=2 || rep.preemptions<1) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_strf => mismatch => procs=%llu, preempts=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_STRF);
    return true;
}

static bool test_hrrn(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    init_process(&p[2],4,1,0);

    scheduler_select_algorithm(ALG_HRRN);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=3 || rep.preemptions!=0ULL) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_hrrn => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN);
    return true;
}

static bool test_hrrn_rt(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,0);
    init_process(&p[1],4,1,0);

    scheduler_select_algorithm(ALG_HRRN_RT);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=2 || rep.preemptions<1) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_hrrn_rt => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN_RT);
    return true;
}

static bool test_priority(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0],2,3,0);
    init_process(&p[1],2,1,0);
    init_process(&p[2],2,2,0);

    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* just approximate check. expect no preemptions, some wait~2, TAT~4 */
    if(rep.preemptions!=0ULL ||
       !almost_equal(rep.avg_wait, 2.0, 1.0) ||
       !almost_equal(rep.avg_turnaround,4.0,1.0))
    {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_priority => mismatch => W=%.2f,T=%.2f,R=%.2f,pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_PRIORITY);
    return true;
}

static bool test_cfs_srtf(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0],2,1,0);
    init_process(&p[1],4,1,0);
    init_process(&p[2],6,1,0);

    scheduler_select_algorithm(ALG_CFS_SRTF);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=3 || rep.preemptions<1) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_cfs_srtf => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS_SRTF);
    return true;
}

static bool test_sjf_strict(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0],2,10,0);
    init_process(&p[1],5,20,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.preemptions!=0ULL) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_sjf_strict => mismatch => preempt=%llu",
                 rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

/* Array of all normal tests */
typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} normal_tests[] = {
    {"sjf",       test_sjf},
    {"strf",      test_strf},
    {"hrrn",      test_hrrn},
    {"hrrn_rt",   test_hrrn_rt},
    {"priority",  test_priority},
    {"cfs_srtf",  test_cfs_srtf},
    {"sjf_strict",test_sjf_strict}
};
static const int NORMAL_COUNT = sizeof(normal_tests)/sizeof(normal_tests[0]);

int normal_test_count(void) {
    return NORMAL_COUNT;
}
const char* normal_test_name(int i) {
    if(i<0 || i>=NORMAL_COUNT) return NULL;
    return normal_tests[i].name;
}

void normal_test_run_single(int i, int* pass_out) {
    if(!pass_out) return;
    if(i<0 || i>=NORMAL_COUNT) {
        *pass_out=0;
        return;
    }
    g_tests_run=0;
    g_tests_failed=0;
    memset(g_fail_reason,0,sizeof(g_fail_reason));

    bool ok = normal_tests[i].func();
    *pass_out = (ok && g_tests_failed==0) ? 1 : 0;
}

void run_normal_tests(int* total,int* passed) {
    g_tests_run=0;
    g_tests_failed=0;
    memset(g_fail_reason,0,sizeof(g_fail_reason));

    printf("\n\033[1m\033[93m╔══════════ NORMAL TESTS START ══════════╗\033[0m\n");
    for(int i=0; i<NORMAL_COUNT; i++) {
        bool ok = normal_tests[i].func();
        if(ok){
            printf("  PASS: %s\n", normal_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n", normal_tests[i].name, test_get_fail_reason());
        }
    }

    *total  = g_tests_run;
    *passed = (g_tests_run - g_tests_failed);

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║      NORMAL TESTS RESULTS: %d / %d passed       ║\n", *passed, *total);
    if(*passed < *total) {
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef NORMAL_TEST_H
#define NORMAL_TEST_H

/* Normal tests: SJF, STRF, HRRN, HRRN-RT, PRIORITY, CFS-SRTF, etc. */

void run_normal_tests(int* total,int* passed);
int normal_test_count(void);
void normal_test_run_single(int i, int* pass_out);
#endif
#include "test_common.h"
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <errno.h>
#include <stdarg.h>

static char g_fail_reason[256] = {0};

void test_set_fail_reason(const char* msg) {
    if(!msg) {
        g_fail_reason[0] = '\0';
        return;
    }
    strncpy(g_fail_reason, msg, sizeof(g_fail_reason)-1);
    g_fail_reason[sizeof(g_fail_reason)-1] = '\0';
}

const char* test_get_fail_reason(void) {
    if(g_fail_reason[0] == '\0') {
        return "???";
    }
    return g_fail_reason;
}

static ssize_t read_all_fd(int fd, char* buf, size_t cap) {
    size_t used = 0;
    while(used + 1 < cap) {
        ssize_t r = read(fd, buf + used, cap - 1 - used);
        if(r < 0 && errno == EINTR) continue;
        if(r <= 0) break;
        used += (size_t)r;
    }
    buf[used] = '\0';
    return (ssize_t)used;
}

int run_function_capture_output(void(*fn)(void), struct captured_output* out) {
    if(!fn || !out) return -1;
    int p_out[2], p_err[2];
    if(pipe(p_out)==-1 || pipe(p_err)==-1) return -1;
    int save_out = dup(STDOUT_FILENO);
    int save_err = dup(STDERR_FILENO);
    if(save_out<0 || save_err<0) return -1;

    pid_t c = fork();
    if(c<0) {
        return -1;
    }
    if(c==0) {
        close(p_out[0]);
        close(p_err[0]);
        dup2(p_out[1], STDOUT_FILENO);
        dup2(p_err[1], STDERR_FILENO);
        close(p_out[1]);
        close(p_err[1]);

        fn();
        _exit(0);
    } else {
        close(p_out[1]);
        close(p_err[1]);
        read_all_fd(p_out[0], out->stdout_buf, sizeof(out->stdout_buf));
        read_all_fd(p_err[0], out->stderr_buf, sizeof(out->stderr_buf));
        close(p_out[0]);
        close(p_err[0]);

        dup2(save_out, STDOUT_FILENO);
        dup2(save_err, STDERR_FILENO);
        close(save_out);
        close(save_err);

        int st=0;
        waitpid(c,&st,0);
        return st;
    }
    return 0;
}
#ifndef TEST_COMMON_H
#define TEST_COMMON_H

#include <stdbool.h>
#include <stdio.h>
#include <string.h>

/* Colors for ASCII art convenience. */
#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GREEN   "\033[92m"
#define CLR_GRAY    "\033[90m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

void test_set_fail_reason(const char* msg);
const char* test_get_fail_reason(void);

struct captured_output {
  char stdout_buf[8192];
  char stderr_buf[8192];
};

/*
  run_function_capture_output():
    Creates pipes, forks, runs fn() in child, captures output in out.
*/
int run_function_capture_output(void(*fn)(void), struct captured_output* out);
#endif
