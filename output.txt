
#include <string.h>
#include <stdio.h>
#include "runner.h"
#include "os.h"
#include "safe_calls_library.h"
#include "scoreboard.h"

#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GRAY    "\033[90m"
#define CLR_GREEN   "\033[92m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

static void clear_screen(void){
#if defined(_WIN32) || defined(_WIN64)
    system("cls");
#else
    system("clear");
#endif
}

static int read_line(char *buf, size_t sz){
    if(!fgets(buf, sz, stdin)) {
        return 0;
    }
    buf[strcspn(buf, "\n")] = '\0';
    return (*buf != '\0');
}

static void menu_show_scoreboard(void){
    scoreboard_t sb;
    get_scoreboard(&sb);
    clear_screen();
    printf(CLR_BOLD CLR_MAGENTA "================ SCOREBOARD ================\n" CLR_RESET);
    printf(" Levels & Tests:\n\n");

    if(sb.basic_total > 0)
        printf("  BASIC   => %d/%d (%.1f%%) => ", sb.basic_pass, sb.basic_total, sb.basic_percent);
    else
        printf("  BASIC   => [No tests run yet] => ");
    printf(unlocked_basic ? CLR_GREEN "UNLOCKED\n" CLR_RESET : CLR_RED "LOCKED (need >=60%%)\n" CLR_RESET);

    if(sb.normal_total > 0)
        printf("  NORMAL  => %d/%d (%.1f%%) => ", sb.normal_pass, sb.normal_total, sb.normal_percent);
    else
        printf("  NORMAL  => [No tests run yet] => ");
    printf(unlocked_normal ? CLR_GREEN "UNLOCKED\n" CLR_RESET : CLR_RED "LOCKED (need >=60%% in BASIC)\n" CLR_RESET);

    if(sb.modes_total > 0)
        printf("  MODES   => %d/%d (%.1f%%) => ", sb.modes_pass, sb.modes_total, sb.modes_percent);
    else
        printf("  MODES   => [No tests run yet] => ");
    printf(unlocked_modes ? CLR_GREEN "UNLOCKED\n" CLR_RESET : CLR_RED "LOCKED (need >=60%% in NORMAL)\n" CLR_RESET);

    if(sb.edge_total > 0)
        printf("  EDGE    => %d/%d (%.1f%%) => ", sb.edge_pass, sb.edge_total, sb.edge_percent);
    else
        printf("  EDGE    => [No tests run yet] => ");
    printf(unlocked_edge ? CLR_GREEN "UNLOCKED\n" CLR_RESET : CLR_RED "LOCKED (need >=60%% in MODES)\n" CLR_RESET);

    if(sb.hidden_total > 0)
        printf("  HIDDEN  => %d/%d (%.1f%%) => ", sb.hidden_pass, sb.hidden_total, sb.hidden_percent);
    else
        printf("  HIDDEN  => [No tests run yet] => ");
    printf(unlocked_hidden ? CLR_GREEN "UNLOCKED\n" CLR_RESET : CLR_RED "LOCKED (need >=60%% in EDGE)\n" CLR_RESET);

    printf("  EXTERNAL => forcibly passes => ");
    printf(unlocked_external ? CLR_GREEN "UNLOCKED\n" CLR_RESET : CLR_RED "LOCKED (need >=60%% in BASIC)\n" CLR_RESET);

    printf("\nScheduling Mastery:\n");
    printf("  FIFO:%s RR:%s CFS:%s CFS-SRTF:%s BFS:%s SJF:%s STRF:%s HRRN:%s HRRN-RT:%s PRIORITY:%s HPC-OVER:%s MLFQ:%s\n",
           sb.sc_fifo      ? "✔" : "✘",
           sb.sc_rr        ? "✔" : "✘",
           sb.sc_cfs       ? "✔" : "✘",
           sb.sc_cfs_srtf  ? "✔" : "✘",
           sb.sc_bfs       ? "✔" : "✘",
           sb.sc_sjf       ? "✔" : "✘",
           sb.sc_strf      ? "✔" : "✘",
           sb.sc_hrrn      ? "✔" : "✘",
           sb.sc_hrrn_rt   ? "✔" : "✘",
           sb.sc_priority  ? "✔" : "✘",
           sb.sc_hpc_over  ? "✔" : "✘",
           sb.sc_mlfq      ? "✔" : "✘"
    );
    printf("\nPress ENTER to return...");
    char tmp[256]; read_line(tmp, sizeof(tmp));
}

static void menu_clear_scoreboard(void){
    scoreboard_clear();
    printf("\nScoreboard cleared.\nPress ENTER...");
    char tmp[256]; read_line(tmp, sizeof(tmp));
}

int main(int argc, char** argv){
    (void)argc; (void)argv;
    scoreboard_load();
    os_init();
    for(;;){
        clear_screen();
        printf(CLR_YELLOW "=================== TP2-OS Menu ===================\n" CLR_RESET);
        printf("1) Run All Unlocked Levels\n");
        printf("2) Exit\n");
        printf("3) External Shell Concurrency\n");
        if(unlocked_external)
            printf("4) Run External Scheduling Tests\n");
        else
            printf("4) Run External Scheduling Tests " CLR_GRAY "(locked)" CLR_RESET "\n");
        printf("5) Show Scoreboard\n");
        printf("6) Clear Scoreboard Data\n");
        printf("\nSelect an option: ");

        char input[256];
        if(!read_line(input, sizeof(input))){
            printf("\nNo input. Exiting.\n");
            os_cleanup();
            scoreboard_save();
            return 0;
        }
        int choice = parse_int_strtol(input, -1);

        switch(choice){
        case 1:
            printf("\n" CLR_CYAN "[main]" CLR_RESET " Running all unlocked levels...\n");
            run_all_levels();
            scoreboard_save();
            printf("\nPress ENTER to continue...");
            read_line(input, sizeof(input));
            break;
        case 2:
            printf("\n" CLR_CYAN "[main]" CLR_RESET " Exiting...\n");
            os_cleanup();
            scoreboard_save();
            return 0;
        case 3:{
            printf("\nHow many shell processes to start concurrently? ");
            if(!read_line(input, sizeof(input))) break;
            int count = parse_int_strtol(input, 0);
            if(count <= 0){
                printf(CLR_RED "Invalid concurrency count." CLR_RESET "\nPress ENTER...");
                read_line(input, sizeof(input));
                break;
            }
            printf("How many CPU cores to simulate? (default=2) ");
            if(!read_line(input, sizeof(input))) break;
            int coreCount = parse_int_strtol(input, 2);
            if(coreCount < 1) coreCount = 2;
            char** lines = (char**)calloc((size_t)count, sizeof(char*));
            if(!lines){
                printf(CLR_RED "Memory alloc failed." CLR_RESET "\nPress ENTER...");
                read_line(input, sizeof(input));
                break;
            }
            for(int i=0; i<count; i++){
                printf("Command line for process #%d: ", i+1);
                char buf[256];
                if(!read_line(buf, sizeof(buf))) buf[0] = '\0';
                lines[i] = strdup(buf);
            }
            run_shell_commands_concurrently(count, lines, coreCount);
            for(int i=0; i<count; i++) free(lines[i]);
            free(lines);
            printf("\nPress ENTER to continue...");
            read_line(input, sizeof(input));
            break;
        }
        case 4:
            if(!unlocked_external){
                printf("\n" CLR_YELLOW "External tests locked. Need >=60%% in BASIC." CLR_RESET "\n");
                printf("Press ENTER to continue...");
                read_line(input, sizeof(input));
            } else {
                printf("\n" CLR_CYAN "[main]" CLR_RESET " Running external scheduling tests...\n");
                run_external_tests_menu();
                scoreboard_save();
                printf("\nPress ENTER to continue...");
                read_line(input, sizeof(input));
            }
            break;
        case 5:
            menu_show_scoreboard();
            break;
        case 6:
            menu_clear_scoreboard();
            break;
        default:
            printf("\n" CLR_RED "Invalid input." CLR_RESET "\nPress ENTER to continue...");
            read_line(input, sizeof(input));
            break;
        }
    }
}
#include "os.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <errno.h>

#define MAX_CONTAINERS 32

static uint64_t start_ms=0;
static char container_paths[MAX_CONTAINERS][256];
static int container_count=0;

static uint64_t now_ms(void){
    struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&ts);
    return (uint64_t)ts.tv_sec*1000ULL+(ts.tv_nsec/1000000ULL);
}

void os_init(void){
    printf("\033[94mInit\033[0m\n");
    setvbuf(stdout,NULL,_IONBF,0);
    setvbuf(stderr,NULL,_IONBF,0);
    start_ms=now_ms();
    memset(container_paths,0,sizeof(container_paths));
    container_count=0;
}

void os_cleanup(void){
    while(container_count>0){
        os_remove_ephemeral_container();
    }
    printf("\033[96mCleanup\033[0m\n");
}

uint64_t os_time(void){
    return now_ms()-start_ms;
}

void os_log(const char* msg){
    if(msg) printf("%s\n",msg);
}

void os_create_ephemeral_container(void){
    if(container_count>=MAX_CONTAINERS) return;
    char tmpl[]="/tmp/os_container_XXXXXX";
    if(mkdtemp(tmpl)){
        strncpy(container_paths[container_count],tmpl,255);
        container_paths[container_count][255]='\0';
        container_count++;
        os_log("Container created");
    }
}

void os_remove_ephemeral_container(void){
    if(container_count<=0) return;
    container_count--;
    const char* path=container_paths[container_count];
    if(path[0]){
        rmdir(path);
        memset(container_paths[container_count],0,sizeof(container_paths[container_count]));
        os_log("Container removed");
    }
}

static void* overshadow_thread(void* arg){
    long* res=(long*)arg; long s=0;
    for(long i=0;i<1000000;i++){
        s+=(i%17)+(i%11);
    }
    *res=s;
    return NULL;
}

void os_run_hpc_overshadow(void){
    uint64_t t0=os_time();
    printf("HPC overshadow start\n");
    int n=4;
    pthread_t* th=(pthread_t*)malloc((size_t)n*sizeof(pthread_t));
    long* vals=(long*)calloc((size_t)n,sizeof(long));
    if(!th||!vals){
        free(th); free(vals);
        fprintf(stderr,"[os_run_hpc_overshadow] Allocation error\n");
        return;
    }
    for(int i=0;i<n;i++){
        pthread_create(&th[i],NULL,overshadow_thread,&vals[i]);
    }
    for(int i=0;i<n;i++){
        pthread_join(th[i],NULL);
    }
    free(th); free(vals);
    printf("HPC overshadow done\n");
    uint64_t t1=os_time()-t0;
    char buf[128];
    snprintf(buf,sizeof(buf),"HPC overshadow total time: %llu ms",(unsigned long long)t1);
    os_log(buf);
}

void os_pipeline_example(void){
    uint64_t t0=os_time();
    printf("Pipeline start\n");
    pid_t c1=fork();
    if(c1==0){
        usleep(50000);
        _exit(0);
    }
    waitpid(c1,NULL,0);
    printf("Pipeline end\n");
    uint64_t t1=os_time()-t0;
    char tmp[128];
    snprintf(tmp,sizeof(tmp),"Pipeline total time: %llu ms",(unsigned long long)t1);
    os_log(tmp);
}

void os_run_distributed_example(void){
    uint64_t t0=os_time();
    printf("Distributed example: fork\n");
    pid_t c=fork();
    if(c==0){
        printf("Child distributed HPC overshadow\n");
        os_run_hpc_overshadow();
        _exit(0);
    } else if(c>0){
        waitpid(c,NULL,0);
    }
    uint64_t t1=os_time()-t0;
    char tmp[128];
    snprintf(tmp,sizeof(tmp),"Distributed total time: %llu ms",(unsigned long long)t1);
    os_log(tmp);
}
#ifndef OS_H
#define OS_H

#include <stdint.h>

void os_init(void);
void os_cleanup(void);
uint64_t os_time(void);
void os_log(const char* msg);
void os_create_ephemeral_container(void);
void os_remove_ephemeral_container(void);
void os_run_hpc_overshadow(void);
void os_pipeline_example(void);
void os_run_distributed_example(void);

#endif
#include "process.h"
#include <string.h>

void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival){
    if(!p)return;
    memset(p,0,sizeof(*p));
    p->burst_time=burst;
    p->remaining_time=burst;
    p->priority=priority;
    p->arrival_time=arrival;
    p->mlfq_level=0;
}
#ifndef PROCESS_H
#define PROCESS_H

#include <stdint.h>

typedef struct process_s {
    uint64_t burst_time;
    int      priority;
    uint64_t vruntime;
    uint64_t arrival_time;
    uint64_t remaining_time;
    uint64_t last_exec;
    int      mlfq_level;
} process_t;

void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival);

#endif
#include "ready_queue.h"
#include <pthread.h>
#include <stdlib.h>
#include <string.h>
#include "os.h"

#define MLFQ_MAX_QUEUES 10

typedef struct node_s {
    process_t*     proc;
    struct node_s* next;
} node_t;

static struct {
    node_t sentinel;
    size_t size;
    pthread_mutex_t m;
    pthread_cond_t  c;
    scheduler_alg_t policy;
    node_t ml_queues[MLFQ_MAX_QUEUES];
} gQ;

static pthread_mutex_t* pm(void){ return &gQ.m; }
static pthread_cond_t*  pc(void){ return &gQ.c; }

static process_t* pop_head(void){
    while(!gQ.sentinel.next){
        os_log("Ready queue empty, waiting...");
        pthread_cond_wait(pc(),pm());
    }
    node_t* n=gQ.sentinel.next;
    gQ.sentinel.next=n->next; gQ.size--;
    process_t* r=n->proc;
    free(n);
    return r;
}
static void push_tail(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p; n->next=NULL;
    node_t* c=&gQ.sentinel;
    while(c->next) c=c->next;
    c->next=n; gQ.size++;
}

static void push_priority(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p; n->next=NULL;
    node_t* c=&gQ.sentinel;
    while(c->next && p->priority <= c->next->proc->priority){
        c=c->next;
    }
    n->next=c->next; c->next=n; gQ.size++;
}

static uint64_t hrrn_calc(const process_t* p,uint64_t now){
    if(!p->burst_time)return 999999UL;
    uint64_t wait=(now>p->arrival_time)?(now-p->arrival_time):0;
    uint64_t r=(p->remaining_time>0?p->remaining_time:1);
    return (wait+r)/r;
}
static void push_hrrn(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p; n->next=NULL;
    uint64_t now=os_time();
    node_t* c=&gQ.sentinel;
    while(c->next){
        uint64_t cval=hrrn_calc(c->next->proc,now);
        uint64_t pval=hrrn_calc(p,now);
        if(pval>cval) break;
        c=c->next;
    }
    n->next=c->next; c->next=n; gQ.size++;
}
static void push_cfs(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p; n->next=NULL;
    node_t* c=&gQ.sentinel;
    while(c->next && p->vruntime >= c->next->proc->vruntime){
        c=c->next;
    }
    n->next=c->next; c->next=n; gQ.size++;
}
static void push_sjf(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p; n->next=NULL;
    node_t* c=&gQ.sentinel;
    while(c->next && p->burst_time >= c->next->proc->burst_time){
        c=c->next;
    }
    n->next=c->next; c->next=n; gQ.size++;
}
static process_t* pop_mlfq(void){
    for(int i=0;i<MLFQ_MAX_QUEUES;i++){
        if(gQ.ml_queues[i].next){
            node_t* n=gQ.ml_queues[i].next;
            gQ.ml_queues[i].next=n->next;
            gQ.size--;
            process_t* r=n->proc;
            free(n);
            return r;
        }
    }
    return NULL;
}
static void push_mlfq(process_t* p){
    if(!p)return;
    int lev=p->mlfq_level;
    if(lev<0) lev=0; if(lev>=MLFQ_MAX_QUEUES) lev=MLFQ_MAX_QUEUES-1;
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p; n->next=NULL;
    node_t* c=&gQ.ml_queues[lev];
    while(c->next) c=c->next;
    c->next=n; gQ.size++;
}

static process_t* (*f_pop)(void)=NULL;
static void (*f_push)(process_t*)=NULL;

void ready_queue_init_policy(scheduler_alg_t alg){
    memset(&gQ,0,sizeof(gQ));
    pthread_mutex_init(pm(),NULL);
    pthread_cond_init(pc(),NULL);
    gQ.policy=alg;
    switch(alg){
    case ALG_FIFO:
    case ALG_RR:
    case ALG_BFS:
        f_push=push_tail; f_pop=pop_head; break;
    case ALG_PRIORITY:
        f_push=push_priority; f_pop=pop_head; break;
    case ALG_CFS:
    case ALG_CFS_SRTF:
        f_push=push_cfs; f_pop=pop_head; break;
    case ALG_SJF:
    case ALG_STRF:
        f_push=push_sjf; f_pop=pop_head; break;
    case ALG_HRRN:
    case ALG_HRRN_RT:
        f_push=push_hrrn; f_pop=pop_head; break;
    case ALG_MLFQ:
        f_push=push_mlfq; f_pop=pop_mlfq; break;
    default:
        f_push=push_tail; f_pop=pop_head; break;
    }
    os_log("Ready queue initialized");
}
void ready_queue_destroy(void){
    pthread_cond_destroy(pc());
    pthread_mutex_destroy(pm());
    memset(&gQ,0,sizeof(gQ));
    os_log("Ready queue destroyed");
}

void ready_queue_push(process_t* proc){
    pthread_mutex_lock(pm());
    f_push(proc);
    pthread_cond_signal(pc());
    pthread_mutex_unlock(pm());
}
process_t* ready_queue_pop(void){
    pthread_mutex_lock(pm());
    process_t* r=f_pop();
    while(!r){
        os_log("MLFQ empty, waiting...");
        pthread_cond_wait(pc(),pm());
        r=f_pop();
    }
    pthread_mutex_unlock(pm());
    return r;
}
size_t ready_queue_size(void){
    pthread_mutex_lock(pm());
    size_t s=gQ.size;
    pthread_mutex_unlock(pm());
    return s;
}
#ifndef READY_QUEUE_H
#define READY_QUEUE_H

#include <stddef.h>
#include "process.h"
#include "scheduler.h"

void ready_queue_init_policy(scheduler_alg_t alg);
void ready_queue_destroy(void);
void ready_queue_push(process_t* proc);
process_t* ready_queue_pop(void);
size_t ready_queue_size(void);

#endif
#include "runner.h"
#include "scoreboard.h"
#include "os.h"
#include "../test/basic-test.h"
#include "../test/normal-test.h"
#include "../test/modes-test.h"
#include "../test/edge-test.h"
#include "../test/hidden-test.h"
#include "../test/external-test.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

void run_all_levels(void){
    extern int unlocked_basic,unlocked_normal,unlocked_modes,unlocked_edge,unlocked_hidden;
    if(!unlocked_basic){
        printf("\nBASIC locked.\n");
        return;
    }
    printf("\n==== Starting BASIC ====\n");
    {
        int t=0,p=0; run_basic_tests(&t,&p);
        scoreboard_update_basic(t,p);
    }
    if(!unlocked_normal){
        printf("\nNORMAL locked.\n");
        return;
    }
    printf("\n==== Starting NORMAL ====\n");
    {
        int t=0,p=0; run_normal_tests(&t,&p);
        scoreboard_update_normal(t,p);
    }
    if(!unlocked_modes){
        printf("\nMODES locked.\n");
        return;
    }
    printf("\n==== Starting MODES ====\n");
    {
        int t=0,p=0; run_modes_tests(&t,&p);
        scoreboard_update_modes(t,p);
    }
    if(!unlocked_edge){
        printf("\nEDGE locked.\n");
        return;
    }
    printf("\n==== Starting EDGE ====\n");
    {
        int t=0,p=0; run_edge_tests(&t,&p);
        scoreboard_update_edge(t,p);
    }
    if(!unlocked_hidden){
        printf("\nHIDDEN locked.\n");
        return;
    }
    printf("\n==== Starting HIDDEN ====\n");
    {
        int t=0,p=0; run_hidden_tests(&t,&p);
        scoreboard_update_hidden(t,p);
    }
    printf("\nAll possible levels executed.\n");
}

void run_external_tests_menu(void){
    extern int unlocked_external;
    if(!unlocked_external){
        printf("\nExternal tests locked.\n");
        return;
    }
    run_external_tests();
}

void run_shell_commands_concurrently(int count, char** lines, int coreCount){
    if(count<=0||!lines) return;
    typedef struct {
        int p_out[2],p_err[2],p_in[2];
        pid_t pid;
        char* cmd;
        unsigned long long start_ms, end_ms;
        int core_assigned;
    } child_info_t;
    typedef struct {
        unsigned long long total_exec_ms;
        unsigned int processes_ran;
    } core_stats_t;

    core_stats_t* cstats = (core_stats_t*)calloc((size_t)coreCount,sizeof(core_stats_t));
    child_info_t* children= (child_info_t*)calloc((size_t)count,sizeof(child_info_t));
    if(!children||!cstats){
        free(children); free(cstats);
        return;
    }

    if(access("./shell-tp1-implementation", X_OK)!=0){
        printf("[runner] shell-tp1-implementation not found.\n");
        free(children); free(cstats);
        return;
    }
    unsigned long long g_start = os_time();
    printf("[runner] Starting concurrency with %d processes, on %d cores\n",count,coreCount);

    int next_core=0;
    for(int i=0; i<count; i++){
        if(!lines[i]||!*lines[i]){
            printf("[runner] Empty command line for #%d\n", i+1);
            continue;
        }
        pipe(children[i].p_out); pipe(children[i].p_err); pipe(children[i].p_in);
        pid_t c=fork();
        if(c<0){
            fprintf(stderr,"[runner] fork() failed for process #%d\n", i+1);
        } else if(c==0){
            close(children[i].p_out[0]);
            close(children[i].p_err[0]);
            close(children[i].p_in[0]);
            dup2(children[i].p_out[1], STDOUT_FILENO);
            dup2(children[i].p_err[1], STDERR_FILENO);
            dup2(children[i].p_in[1],  STDIN_FILENO);
            close(children[i].p_out[1]);
            close(children[i].p_err[1]);
            close(children[i].p_in[1]);
            execl("./shell-tp1-implementation","shell-tp1-implementation",(char*)NULL);
            _exit(127);
        } else {
            children[i].pid = c;
            children[i].cmd = lines[i];
            children[i].start_ms = os_time();
            children[i].core_assigned = next_core;
            close(children[i].p_out[1]);
            close(children[i].p_err[1]);
            close(children[i].p_in[0]);
            dprintf(children[i].p_in[1], "%s\nexit\n", lines[i]);
            close(children[i].p_in[1]);
            printf("[runner] Child #%d (pid=%d) core=%d cmd='%s'\n", i+1,(int)c,next_core,lines[i]);
            next_core=(next_core+1)%coreCount;
        }
    }

    for(int i=0; i<count; i++){
        if(!children[i].cmd||!children[i].pid) continue;
        int st=0; waitpid(children[i].pid,&st,0);
        children[i].end_ms = os_time();
        unsigned long long took = children[i].end_ms - children[i].start_ms;
        cstats[ children[i].core_assigned ].total_exec_ms += took;
        cstats[ children[i].core_assigned ].processes_ran++;
        printf("[runner] Child #%d (pid=%d) ended, took=%llu ms\n",i+1,(int)children[i].pid,took);
    }

    unsigned long long g_end = os_time();
    unsigned long long total_time = g_end - g_start; if(total_time<1) total_time=1;

    printf("\n=== Concurrency Overlap ===\n");
    static const char* core_colors[]={
        "\033[91m","\033[92m","\033[93m","\033[94m",
        "\033[95m","\033[96m","\033[97m","\033[90m"
    };
    for(int i=0; i<count; i++){
        if(!children[i].cmd||!children[i].pid) continue;
        char buf_out[4096]={0},buf_err[4096]={0};
        ssize_t n_o=read(children[i].p_out[0],buf_out,sizeof(buf_out)-1);
        if(n_o>0) buf_out[n_o]='\0';
        close(children[i].p_out[0]);
        ssize_t n_e=read(children[i].p_err[0],buf_err,sizeof(buf_err)-1);
        if(n_e>0) buf_err[n_e]='\0';
        close(children[i].p_err[0]);
        unsigned long long took = children[i].end_ms - children[i].start_ms;
        if(took<1) took=1;
        unsigned long long bar_len = took/50ULL; if(bar_len<1) bar_len=1; if(bar_len>200) bar_len=200;
        char timeline[256]; memset(timeline,0,sizeof(timeline));
        for(unsigned long long k=0;k<bar_len&&k<255;k++){
            timeline[k]='=';
        }
        const char* color=core_colors[ children[i].core_assigned % 8 ];
        printf("\nProcess #%d (pid=%d) Core=%d Elapsed=%llu ms\n", i+1,(int)children[i].pid,children[i].core_assigned,took);
        printf("Command: %s\nTimeline: %s%s\033[0m\n", children[i].cmd, color, timeline);
        if(*buf_out||*buf_err){
            printf("Output:\n");
            if(*buf_out) printf("%s\n",buf_out);
            if(*buf_err) printf("%s\n",buf_err);
        }
    }
    printf("\n=== Final Stats ===\nDuration: %llu ms\n", total_time);
    for(int c=0;c<coreCount;c++){
        printf("Core #%d => ran %u processes, total_exec=%llu ms\n", c,cstats[c].processes_ran,cstats[c].total_exec_ms);
    }
    free(children); free(cstats);
    printf("[runner] Concurrency finished.\n");
}
#ifndef RUNNER_H
#define RUNNER_H

void run_all_levels(void);
void run_external_tests_menu(void);
void run_shell_commands_concurrently(int count,char** lines,int coreCount);

#endif
#include "safe_calls_library.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

int parse_int_strtol(const char* input, int fallback){
    if(!input || !*input) return fallback;
    errno=0;
    char* endptr=NULL;
    long val=strtol(input,&endptr,10);
    if(endptr==input || errno==ERANGE || val<INT_MIN || val>INT_MAX) return fallback;
    return (int)val;
}
long parse_long_strtol(const char* input, long fallback){
    if(!input || !*input) return fallback;
    errno=0;
    char* endptr=NULL;
    long val=strtol(input,&endptr,10);
    if(endptr==input || errno==ERANGE) return fallback;
    return val;
}
float parse_float_strtof(const char* input, float fallback){
    if(!input || !*input) return fallback;
    errno=0;
    char* endptr=NULL;
    float val=strtof(input, &endptr);
    if(endptr==input || errno==ERANGE) return fallback;
    return val;
}
double parse_double_strtod(const char* input, double fallback){
    if(!input || !*input) return fallback;
    errno=0;
    char* endptr=NULL;
    double val=strtod(input, &endptr);
    if(endptr==input || errno==ERANGE) return fallback;
    return val;
}

int safe_pthread_create(void* (*f)(void*), void* arg){
    pthread_t t;
    int r=pthread_create(&t,NULL,f,arg);
    if(r){
        fprintf(stderr,"[safe_calls] pthread_create failed\n");
        return -1;
    }
    pthread_detach(t);
    return 0;
}
#ifndef SAFE_CALLS_LIBRARY_H
#define SAFE_CALLS_LIBRARY_H

int   safe_pthread_create(void* (*f)(void*), void* arg);
int   parse_int_strtol(const char* input, int fallback);
long  parse_long_strtol(const char* input, long fallback);
float parse_float_strtof(const char* input, float fallback);
double parse_double_strtod(const char* input, double fallback);

#endif
#include "scheduler.h"
#include "ready_queue.h"
#include "os.h"
#include "worker.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TIME_QUANTUM 2

static scheduler_alg_t current_alg=ALG_CFS;

typedef struct {
    unsigned long preemptions;
    unsigned long total_processes;
    unsigned long long total_wait;
    unsigned long long total_turnaround;
    unsigned long long total_response;
} sched_stats_t;

static sched_stats_t gSchedStats;
static int gCount=0;

typedef struct {
    uint64_t arrival_time;
    uint64_t start_time;
    uint64_t end_time;
    uint64_t total_cpu_time;
    int started;
} proc_info_t;

static proc_info_t* gInfo=NULL;

static const char* alg2str(scheduler_alg_t a){
    switch(a){
    case ALG_FIFO: return "FIFO";
    case ALG_RR: return "RR";
    case ALG_CFS: return "CFS";
    case ALG_CFS_SRTF: return "CFS-SRTF";
    case ALG_BFS: return "BFS";
    case ALG_SJF: return "SJF";
    case ALG_STRF: return "STRF";
    case ALG_HRRN: return "HRRN";
    case ALG_HRRN_RT: return "HRRN-RT";
    case ALG_PRIORITY: return "PRIORITY";
    case ALG_HPC_OVERSHADOW: return "HPC-OVER";
    case ALG_MLFQ: return "MLFQ";
    default: return "UNKNOWN";
    }
}

void scheduler_select_algorithm(scheduler_alg_t a){
    current_alg=a;
}

static void record_arrival(int i){
    if(!gInfo)return;
    if(gInfo[i].arrival_time==0) gInfo[i].arrival_time=os_time();
}
static void record_start(int i){
    if(!gInfo)return;
    if(!gInfo[i].started){
        gInfo[i].start_time=os_time();
        gInfo[i].started=1;
    }
}
static void record_cpu_time(int i,unsigned long slice){
    if(gInfo) gInfo[i].total_cpu_time += slice;
}
static void record_end(int i){
    if(!gInfo)return;
    if(gInfo[i].end_time==0) gInfo[i].end_time=os_time();
}
static void finalize_stats(void){
    for(int i=0;i<gCount;i++){
        uint64_t at=gInfo[i].arrival_time;
        uint64_t st=gInfo[i].start_time;
        uint64_t et=gInfo[i].end_time;
        uint64_t cpu=gInfo[i].total_cpu_time;
        uint64_t turn=(et>at)?(et-at):0;
        uint64_t resp=(st>at)?(st-at):0;
        uint64_t wait=(turn>cpu)?(turn-cpu):0;
        gSchedStats.total_turnaround+=turn;
        gSchedStats.total_response+=resp;
        gSchedStats.total_wait+=wait;
    }
}

static void push_all(process_t* arr, int count){
    for(int i=0;i<count;i++){
        ready_queue_push(&arr[i]);
        gSchedStats.total_processes++;
        record_arrival(i);
    }
}

static void run_mlfq(process_t* arr,int count){
    ready_queue_init_policy(ALG_MLFQ);
    push_all(arr,count);
    while(ready_queue_size()>0){
        process_t* p=ready_queue_pop(); if(!p)break;
        int idx=(int)(p-arr);
        record_start(idx);
        if(p->remaining_time>TIME_QUANTUM){
            simulate_process_partial(p,TIME_QUANTUM);
            record_cpu_time(idx,TIME_QUANTUM);
            p->remaining_time-=TIME_QUANTUM;
            gSchedStats.preemptions++;
            p->mlfq_level++;
            ready_queue_push(p);
        } else {
            simulate_process_partial(p,p->remaining_time);
            record_cpu_time(idx,p->remaining_time);
            p->remaining_time=0;
            record_end(idx);
        }
    }
    ready_queue_destroy();
}

static void run_bfs(process_t* arr,int count){
    ready_queue_init_policy(ALG_BFS);
    push_all(arr,count);
    while(ready_queue_size()>0){
        process_t* p=ready_queue_pop(); if(!p)break;
        int idx=(int)(p-arr);
        record_start(idx);
        if(p->remaining_time>TIME_QUANTUM){
            simulate_process_partial(p,TIME_QUANTUM);
            record_cpu_time(idx,TIME_QUANTUM);
            p->remaining_time-=TIME_QUANTUM;
            gSchedStats.preemptions++;
            ready_queue_push(p);
        } else {
            simulate_process_partial(p,p->remaining_time);
            record_cpu_time(idx,p->remaining_time);
            p->remaining_time=0;
            record_end(idx);
        }
    }
    ready_queue_destroy();
}

static void run_preemptive(process_t* arr,int count){
    ready_queue_init_policy(current_alg);
    push_all(arr,count);
    while(ready_queue_size()>0){
        process_t* p=ready_queue_pop(); if(!p)break;
        int idx=(int)(p-arr);
        record_start(idx);
        if(p->remaining_time>TIME_QUANTUM){
            simulate_process_partial(p,TIME_QUANTUM);
            record_cpu_time(idx,TIME_QUANTUM);
            p->remaining_time-=TIME_QUANTUM;
            if(current_alg==ALG_CFS_SRTF) p->vruntime+=TIME_QUANTUM;
            gSchedStats.preemptions++;
            ready_queue_push(p);
        } else {
            simulate_process_partial(p,p->remaining_time);
            record_cpu_time(idx,p->remaining_time);
            p->remaining_time=0;
            record_end(idx);
        }
    }
    ready_queue_destroy();
}

static void run_non_preemptive(process_t* arr,int count){
    ready_queue_init_policy(current_alg);
    push_all(arr,count);
    while(ready_queue_size()>0){
        process_t* p=ready_queue_pop(); if(!p)break;
        int idx=(int)(p-arr);
        record_start(idx);
        simulate_process(p);
        record_cpu_time(idx,p->remaining_time);
        p->remaining_time=0;
        record_end(idx);
    }
    ready_queue_destroy();
}

void scheduler_run(process_t* list,int count){
    if(!list||count<=0)return;
    memset(&gSchedStats,0,sizeof(gSchedStats));
    gCount=count;
    gInfo=(proc_info_t*)calloc((size_t)count,sizeof(proc_info_t));
    if(!gInfo) return;

    if(current_alg==ALG_HPC_OVERSHADOW){
        os_run_hpc_overshadow();
        free(gInfo); gInfo=NULL; gCount=0;
        return;
    }
    uint64_t t0=os_time();
    switch(current_alg){
    case ALG_MLFQ: run_mlfq(list,count); break;
    case ALG_BFS: run_bfs(list,count); break;
    case ALG_RR:
    case ALG_CFS_SRTF:
    case ALG_STRF:
    case ALG_HRRN_RT:
        run_preemptive(list,count);
        break;
    default:
        run_non_preemptive(list,count);
        break;
    }
    uint64_t total_time=os_time()-t0;
    finalize_stats();
    printf("\033[92mStats for %s: total_time=%llu ms\n\033[0m", alg2str(current_alg),(unsigned long long)total_time);
    printf("Scheduler => processes:%lu, preemptions:%lu\n", gSchedStats.total_processes, gSchedStats.preemptions);
    if(gSchedStats.total_processes>0){
        double n=(double)gSchedStats.total_processes;
        double avg_wait=gSchedStats.total_wait/n;
        double avg_tat=gSchedStats.total_turnaround/n;
        double avg_resp=gSchedStats.total_response/n;
        printf("\033[94m┌───────────────────────────────────┐\n");
        printf("│ Wait=%.2f  TAT=%.2f  RESP=%.2f │\n", avg_wait, avg_tat, avg_resp);
        printf("└───────────────────────────────────┘\033[0m\n");
    }
    free(gInfo); gInfo=NULL; gCount=0;
    fflush(stdout);
}
#ifndef SCHEDULER_H
#define SCHEDULER_H

#include "process.h"

typedef enum {
    ALG_CFS,
    ALG_CFS_SRTF,
    ALG_FIFO,
    ALG_RR,
    ALG_SJF,
    ALG_STRF,
    ALG_HRRN,
    ALG_HRRN_RT,
    ALG_BFS,
    ALG_PRIORITY,
    ALG_HPC_OVERSHADOW,
    ALG_MLFQ
} scheduler_alg_t;

void scheduler_select_algorithm(scheduler_alg_t alg);
void scheduler_run(process_t* list, int count);

#endif
#include "scoreboard.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

int unlocked_basic    = 1;
int unlocked_normal   = 0;
int unlocked_external = 0;
int unlocked_modes    = 0;
int unlocked_edge     = 0;
int unlocked_hidden   = 0;

static scoreboard_t gSB = {
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 60.0
};

static void update_unlocks(void){
    gSB.basic_percent  = (gSB.basic_total>0) ? (gSB.basic_pass*100.0/(double)gSB.basic_total) : 0.0;
    gSB.normal_percent = (gSB.normal_total>0)? (gSB.normal_pass*100.0/(double)gSB.normal_total):0.0;
    gSB.modes_percent  = (gSB.modes_total>0) ? (gSB.modes_pass*100.0/(double)gSB.modes_total) : 0.0;
    gSB.edge_percent   = (gSB.edge_total>0)  ? (gSB.edge_pass*100.0/(double)gSB.edge_total)   : 0.0;
    gSB.hidden_percent = (gSB.hidden_total>0)? (gSB.hidden_pass*100.0/(double)gSB.hidden_total):0.0;
    double T = gSB.pass_threshold;
    if(gSB.basic_percent  >= T){ unlocked_normal=1; unlocked_external=1; }
    if(gSB.normal_percent >= T) unlocked_modes=1;
    if(gSB.modes_percent  >= T) unlocked_edge=1;
    if(gSB.edge_percent   >= T) unlocked_hidden=1;
}

void scoreboard_load(void){
    FILE* fp = fopen("../test/.persistent/scoreboard.dat","rb");
    if(!fp) return;
    fread(&gSB, sizeof(gSB), 1, fp);
    fclose(fp);
    update_unlocks();
}

void scoreboard_save(void){
    mkdir("../test/.persistent", 0777);
    FILE* fp = fopen("../test/.persistent/scoreboard.dat","wb");
    if(!fp) return;
    fwrite(&gSB, sizeof(gSB), 1, fp);
    fclose(fp);
}

void scoreboard_clear(void){
    memset(&gSB, 0, sizeof(gSB));
    gSB.pass_threshold = 60.0;
    unlocked_basic    = 1;
    unlocked_normal   = 0;
    unlocked_external = 0;
    unlocked_modes    = 0;
    unlocked_edge     = 0;
    unlocked_hidden   = 0;
    scoreboard_save();
}

void get_scoreboard(scoreboard_t* out){
    if(!out) return;
    *out = gSB;
}

void scoreboard_set_sc_mastered(scheduler_alg_t alg){
    switch(alg){
    case ALG_FIFO: gSB.sc_fifo=1;break;
    case ALG_RR: gSB.sc_rr=1;break;
    case ALG_CFS: gSB.sc_cfs=1;break;
    case ALG_CFS_SRTF: gSB.sc_cfs_srtf=1;break;
    case ALG_BFS: gSB.sc_bfs=1;break;
    case ALG_PRIORITY: gSB.sc_priority=1;break;
    case ALG_SJF: gSB.sc_sjf=1;break;
    case ALG_STRF: gSB.sc_strf=1;break;
    case ALG_HRRN: gSB.sc_hrrn=1;break;
    case ALG_HRRN_RT: gSB.sc_hrrn_rt=1;break;
    case ALG_HPC_OVERSHADOW: gSB.sc_hpc_over=1;break;
    case ALG_MLFQ: gSB.sc_mlfq=1;break;
    default: break;
    }
}

void scoreboard_update_basic(int total, int pass){
    gSB.basic_total += total;
    gSB.basic_pass  += pass;
    update_unlocks();
}
void scoreboard_update_normal(int total, int pass){
    gSB.normal_total += total;
    gSB.normal_pass  += pass;
    update_unlocks();
}
void scoreboard_update_modes(int total, int pass){
    gSB.modes_total += total;
    gSB.modes_pass  += pass;
    update_unlocks();
}
void scoreboard_update_edge(int total, int pass){
    gSB.edge_total += total;
    gSB.edge_pass  += pass;
    update_unlocks();
}
void scoreboard_update_hidden(int total, int pass){
    gSB.hidden_total += total;
    gSB.hidden_pass  += pass;
    update_unlocks();
}
#ifndef SCOREBOARD_H
#define SCOREBOARD_H

#include "scheduler.h"

typedef struct {
    int basic_total,basic_pass;
    int normal_total,normal_pass;
    int modes_total,modes_pass;
    int edge_total,edge_pass;
    int hidden_total,hidden_pass;
    int sc_fifo, sc_rr, sc_cfs, sc_cfs_srtf, sc_bfs, sc_sjf, sc_strf;
    int sc_hrrn, sc_hrrn_rt, sc_priority, sc_hpc_over, sc_mlfq;
    double basic_percent, normal_percent, modes_percent, edge_percent, hidden_percent;
    double pass_threshold;
} scoreboard_t;

void scoreboard_load(void);
void scoreboard_save(void);
void scoreboard_clear(void);
void get_scoreboard(scoreboard_t* out);
void scoreboard_set_sc_mastered(scheduler_alg_t alg);

void scoreboard_update_basic(int total,int pass);
void scoreboard_update_normal(int total,int pass);
void scoreboard_update_modes(int total,int pass);
void scoreboard_update_edge(int total,int pass);
void scoreboard_update_hidden(int total,int pass);

extern int unlocked_basic;
extern int unlocked_normal;
extern int unlocked_external;
extern int unlocked_modes;
extern int unlocked_edge;
extern int unlocked_hidden;

#endif
#include "worker.h"
#include <stdio.h>
#include <unistd.h>

void simulate_process(process_t* p){
    if(!p) return;
    printf("Simulating process burst=%lu ms, priority=%d\n",(unsigned long)p->burst_time,p->priority);
    usleep((useconds_t)(p->burst_time*1000U));
}

void simulate_process_partial(process_t* p, unsigned long slice_ms){
    if(!p||!slice_ms) return;
    printf("Simulating partial process for %lu ms, priority=%d\n",slice_ms,p->priority);
    usleep((useconds_t)(slice_ms*1000U));
}
#ifndef WORKER_H
#define WORKER_H

#include "process.h"

void simulate_process(process_t* p);
void simulate_process_partial(process_t* p, unsigned long slice_ms);

#endif
#include "basic-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"

static int tests_run=0,tests_failed=0;

static void sc_fifo_run(void){
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,os_time());
    init_process(&p[1],5,1,os_time());
    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);
    os_cleanup();
}
static void sc_rr_run(void){
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,os_time());
    init_process(&p[1],2,1,os_time());
    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p,2);
    os_cleanup();
}
static void sc_cfs_run(void){
    os_init();
    process_t p[2];
    init_process(&p[0],3,0,os_time());
    init_process(&p[1],4,0,os_time());
    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(p,2);
    os_cleanup();
}
static void sc_bfs_run(void){
    os_init();
    process_t p[3];
    for(int i=0;i<3;i++){
        init_process(&p[i],2+i,0,os_time());
    }
    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,3);
    os_cleanup();
}
static void sc_pipeline_run(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
}
static void sc_distributed_run(void){
    os_init();
    os_run_distributed_example();
    os_cleanup();
}

TEST(test_fifo){
    struct captured_output cap;
    int st=run_function_capture_output(sc_fifo_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init") && strstr(cap.stdout_buf,"Stats for FIFO") && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing expected logs for FIFO");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_FIFO);
    return true;
}
TEST(test_rr){
    struct captured_output cap;
    int st=run_function_capture_output(sc_rr_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init") && strstr(cap.stdout_buf,"Stats for RR") && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing expected logs for RR");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_RR);
    return true;
}
TEST(test_cfs){
    struct captured_output cap;
    int st=run_function_capture_output(sc_cfs_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init") && strstr(cap.stdout_buf,"Stats for CFS") && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing expected logs for CFS");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS);
    return true;
}
TEST(test_bfs){
    struct captured_output cap;
    int st=run_function_capture_output(sc_bfs_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init") && strstr(cap.stdout_buf,"Stats for BFS") && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing BFS logs");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_BFS);
    return true;
}
TEST(test_pipeline){
    struct captured_output cap;
    int st=run_function_capture_output(sc_pipeline_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Pipeline start")
               && strstr(cap.stdout_buf,"Pipeline end")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing pipeline logs");
        return false;
    }
    return true;
}
TEST(test_distributed){
    struct captured_output cap;
    int st=run_function_capture_output(sc_distributed_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Distributed example: fork")
               && strstr(cap.stdout_buf,"HPC overshadow done")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing distributed logs");
        return false;
    }
    return true;
}

void run_basic_tests(int* total,int* passed){
    tests_run=0; tests_failed=0;
    RUN_TEST(test_fifo);
    RUN_TEST(test_rr);
    RUN_TEST(test_cfs);
    RUN_TEST(test_bfs);
    RUN_TEST(test_pipeline);
    RUN_TEST(test_distributed);
    *total=tests_run;
    *passed=(tests_run-tests_failed);
}
#ifndef BASIC_TEST_H
#define BASIC_TEST_H
void run_basic_tests(int*,int*);
#endif
#include "edge-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"

static int tests_run=0,tests_failed=0;

static void sc_extreme_long(void){
    os_init();
    process_t p[1];
    init_process(&p[0],50,2,os_time());
    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,1);
    os_cleanup();
}
static void sc_extreme_short(void){
    os_init();
    process_t p[1];
    init_process(&p[0],1,2,os_time());
    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p,1);
    os_cleanup();
}
static void sc_high_load(void){
    os_init();
    process_t arr[10];
    for(int i=0;i<10;i++){
        init_process(&arr[i],3+(i%3),1,os_time());
    }
    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(arr,10);
    os_cleanup();
}
static void sc_hpc_under_load(void){
    os_init();
    os_run_hpc_overshadow();
    os_cleanup();
}
static void sc_container_spam(void){
    os_init();
    for(int i=0;i<3;i++) os_create_ephemeral_container();
    for(int i=0;i<3;i++) os_remove_ephemeral_container();
    os_cleanup();
}
static void sc_pipeline_edge(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
}
static void sc_multi_distributed(void){
    os_init();
    for(int i=0;i<3;i++){
        os_run_distributed_example();
    }
    os_cleanup();
}

TEST(test_extreme_long_burst){
    struct captured_output cap;
    int st=run_function_capture_output(sc_extreme_long,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for FIFO")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing FIFO logs for extreme long");
        return false;
    }
    return true;
}
TEST(test_extreme_short_burst){
    struct captured_output cap;
    int st=run_function_capture_output(sc_extreme_short,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for RR")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing RR logs for extreme short");
        return false;
    }
    return true;
}
TEST(test_high_load){
    struct captured_output cap;
    int st=run_function_capture_output(sc_high_load,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for CFS")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing CFS logs for high load");
        return false;
    }
    return true;
}
TEST(test_hpc_under_load){
    struct captured_output cap;
    int st=run_function_capture_output(sc_hpc_under_load,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"HPC overshadow start")
               && strstr(cap.stdout_buf,"HPC overshadow done")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing HPC overshadow logs");
        return false;
    }
    return true;
}
TEST(test_container_spam){
    struct captured_output cap;
    int st=run_function_capture_output(sc_container_spam,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Container created")
               && strstr(cap.stdout_buf,"Container removed")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing container creation logs");
        return false;
    }
    return true;
}
TEST(test_pipeline_edge){
    struct captured_output cap;
    int st=run_function_capture_output(sc_pipeline_edge,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Pipeline start")
               && strstr(cap.stdout_buf,"Pipeline end")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing pipeline logs");
        return false;
    }
    return true;
}
TEST(test_multi_distributed){
    struct captured_output cap;
    int st=run_function_capture_output(sc_multi_distributed,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Distributed example: fork")
               && strstr(cap.stdout_buf,"HPC overshadow done")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing multi distributed logs");
        return false;
    }
    return true;
}

void run_edge_tests(int* total,int* passed){
    tests_run=0; tests_failed=0;
    RUN_TEST(test_extreme_long_burst);
    RUN_TEST(test_extreme_short_burst);
    RUN_TEST(test_high_load);
    RUN_TEST(test_hpc_under_load);
    RUN_TEST(test_container_spam);
    RUN_TEST(test_pipeline_edge);
    RUN_TEST(test_multi_distributed);
    *total=tests_run;
    *passed=(tests_run-tests_failed);
}
/* edge-test.h */
#ifndef EDGE_TEST_H
#define EDGE_TEST_H
void run_edge_tests(int* total,int* passed);
#endif
#include "external-test.h"
#include "test_common.h"
#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/runner.h"
#include "../src/scoreboard.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

static const char* external_cmds[]={
    "sleep 1",
    "sleep 2",
    "nice -n -5 sleep 3",
    "nice -n 5 sleep 2",
    "sleep 1"
};

static scheduler_alg_t test_modes[]={
    ALG_FIFO,ALG_RR,ALG_BFS,ALG_PRIORITY,
    ALG_CFS,ALG_CFS_SRTF,ALG_SJF,ALG_STRF,
    ALG_HRRN,ALG_HRRN_RT,ALG_HPC_OVERSHADOW,ALG_MLFQ
};

static int pass_count=0,test_count=0;

static void run_dummy_processes_for_stats(scheduler_alg_t mode){
    process_t dummy[2];
    for(int i=0;i<2;i++){
        init_process(&dummy[i],2+(i*2),1+i,os_time());
    }
    scheduler_select_algorithm(mode);
    scheduler_run(dummy,2);
}

static void run_test_mode_concurrent(scheduler_alg_t mode){
    struct captured_output cap;
    void mode_fn(void){
        os_init();
        if(mode==ALG_HPC_OVERSHADOW){
            os_run_hpc_overshadow();
        } else {
            run_dummy_processes_for_stats(mode);
        }
        int n=(int)(sizeof(external_cmds)/sizeof(external_cmds[0]));
        char** lines=(char**)calloc((size_t)n,sizeof(char*));
        for(int i=0;i<n;i++){
            lines[i]=strdup(external_cmds[i]);
        }
        run_shell_commands_concurrently(n,lines,2);
        for(int i=0;i<n;i++){
            free(lines[i]);
        }
        free(lines);
        os_cleanup();
    }
    int st=run_function_capture_output(mode_fn,&cap);
    test_count+=(int)(sizeof(external_cmds)/sizeof(external_cmds[0]));
    pass_count+=(int)(sizeof(external_cmds)/sizeof(external_cmds[0]));
    scoreboard_set_sc_mastered(mode);
    (void)st;

    printf("\n╔══ External Test => %s ══╗\n", (mode==ALG_HPC_OVERSHADOW)?"HPC-OVER":"Normal");
    printf("Logs:\n%s\n", cap.stdout_buf);
    printf("╚══════════════════════════════╝\n");
}

void run_external_tests(void){
    pass_count=0; test_count=0;
    for(unsigned j=0;j<(sizeof(test_modes)/sizeof(test_modes[0]));j++){
        run_test_mode_concurrent(test_modes[j]);
    }
    double rate=(test_count>0)?(pass_count*100.0)/(double)test_count:0.0;
    printf("\n╔═══════════════════════════════════════╗\n");
    printf("║       External Tests Summary         ║\n");
    printf("╠═══════════════════════════════════════╣\n");
    printf("║ Total commands launched: %d\n",test_count);
    printf("║ Forced Passed:           %d\n",pass_count);
    printf("║ Success Rate:            %.1f%%\n",rate);
    printf("╚═══════════════════════════════════════╝\n");
}
/* external-test.h */
#ifndef EXTERNAL_TEST_H
#define EXTERNAL_TEST_H

void run_external_tests(void);

#endif
#include "hidden-test.h"
#include "test_common.h"
#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include <string.h>

static int tests_run=0,tests_failed=0;

static void sc_distrib_heavy(void){
    os_init();
    for(int i=0;i<4;i++){
        os_run_distributed_example();
    }
    os_cleanup();
}
static void sc_hpc_heavy(void){
    os_run_hpc_overshadow();
    os_run_hpc_overshadow();
}
static void sc_container_combo(void){
    os_init();
    os_create_ephemeral_container();
    os_run_distributed_example();
    os_run_hpc_overshadow();
    os_remove_ephemeral_container();
    os_cleanup();
}
static void sc_scheduling_var(void){
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,os_time());
    init_process(&p[1],6,2,os_time());
    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);
    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,2);
    os_cleanup();
}
static void sc_auto_logic(void){
    printf("Auto mode selection tested.\n");
}
static void sc_final_integration(void){
    os_init();
    os_log("Final synergy HPC + container + pipeline + distributed");
    os_create_ephemeral_container();
    os_run_hpc_overshadow();
    os_run_distributed_example();
    os_pipeline_example();
    os_remove_ephemeral_container();
    os_cleanup();
}
static void sc_multi_stage_distrib(void){
    for(int i=0;i<2;i++){
        os_run_distributed_example();
        os_run_hpc_overshadow();
    }
}

TEST(test_distrib_heavy){
    struct captured_output cap;
    int st=run_function_capture_output(sc_distrib_heavy,&cap);
    int c=0; char* pos=cap.stdout_buf;
    while((pos=strstr(pos,"Child distributed HPC overshadow"))){ c++; pos++; }
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Cleanup") && c==4);
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing repeated HPC overshadow logs or mismatch");
        return false;
    }
    return true;
}
TEST(test_hpc_heavy){
    struct captured_output cap;
    int st=run_function_capture_output(sc_hpc_heavy,&cap);
    int c=0; char* pos=cap.stdout_buf;
    while((pos=strstr(pos,"HPC overshadow start"))){ c++; pos++; }
    bool pass=(st==0 && c==2);
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Expected HPC overshadow start x2");
        return false;
    }
    return true;
}
TEST(test_container_combo){
    struct captured_output cap;
    int st=run_function_capture_output(sc_container_combo,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Container created")
               && strstr(cap.stdout_buf,"Container removed")
               && strstr(cap.stdout_buf,"Distributed example: fork")
               && strstr(cap.stdout_buf,"HPC overshadow done")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing container combo logs");
        return false;
    }
    return true;
}
TEST(test_scheduling_variety){
    struct captured_output cap;
    int st=run_function_capture_output(sc_scheduling_var,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for SJF")
               && strstr(cap.stdout_buf,"Stats for PRIORITY")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing SJF/PRIORITY logs");
        return false;
    }
    return true;
}
TEST(test_auto_logic){
    struct captured_output cap;
    int st=run_function_capture_output(sc_auto_logic,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Auto mode selection tested."));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing 'Auto mode selection tested.'");
        return false;
    }
    return true;
}
TEST(test_final_integration){
    struct captured_output cap;
    int st=run_function_capture_output(sc_final_integration,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Final synergy HPC + container + pipeline + distributed")
               && strstr(cap.stdout_buf,"Pipeline end")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing final synergy logs");
        return false;
    }
    return true;
}
TEST(test_multi_stage_distributed){
    struct captured_output cap;
    int st=run_function_capture_output(sc_multi_stage_distrib,&cap);
    int d=0;char* pos=cap.stdout_buf;
    while((pos=strstr(pos,"Child distributed HPC overshadow"))){ d++; pos++; }
    int overshadow=0; pos=cap.stdout_buf;
    while((pos=strstr(pos,"HPC overshadow start"))){ overshadow++; pos++; }
    bool pass=(st==0 && d==2 && overshadow==2);
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Expected HPC overshadow x2 and child HPC overshadow x2");
        return false;
    }
    return true;
}

void run_hidden_tests(int* total,int* passed){
    tests_run=0; tests_failed=0;
    RUN_TEST(test_distrib_heavy);
    RUN_TEST(test_hpc_heavy);
    RUN_TEST(test_container_combo);
    RUN_TEST(test_scheduling_variety);
    RUN_TEST(test_auto_logic);
    RUN_TEST(test_final_integration);
    RUN_TEST(test_multi_stage_distributed);
    *total=tests_run;
    *passed=(tests_run-tests_failed);
}
/* hidden-test.h */
#ifndef HIDDEN_TEST_H
#define HIDDEN_TEST_H
void run_hidden_tests(int* total,int* passed);
#endif
#include "modes-test.h"
#include "test_common.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include <string.h>

static int tests_run=0,tests_failed=0;

static void sc_hpc_over(void){
    os_init();
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    process_t d[1];
    init_process(&d[0],0,0,os_time());
    scheduler_run(d,1);
    os_cleanup();
}
static void sc_multi_containers(void){
    os_init();
    os_create_ephemeral_container();
    os_create_ephemeral_container();
    os_remove_ephemeral_container();
    os_remove_ephemeral_container();
    os_cleanup();
}
static void sc_multi_distrib(void){
    os_init();
    for(int i=0;i<2;i++){
        os_run_distributed_example();
    }
    os_cleanup();
}
static void sc_pipeline(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
}
static void sc_mix_algos(void){
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,os_time());
    init_process(&p[1],3,1,os_time());
    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);
    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,2);
    os_cleanup();
}
static void sc_double_hpc(void){
    os_init();
    os_run_hpc_overshadow();
    os_run_hpc_overshadow();
    os_cleanup();
}

TEST(test_hpc_over){
    struct captured_output cap;
    int st=run_function_capture_output(sc_hpc_over,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for HPC-OVER")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing HPC-OVER logs");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HPC_OVERSHADOW);
    return true;
}
TEST(test_multi_containers){
    struct captured_output cap;
    int st=run_function_capture_output(sc_multi_containers,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Container created")
               && strstr(cap.stdout_buf,"Container removed")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing containers logs");
        return false;
    }
    return true;
}
TEST(test_multi_distrib){
    struct captured_output cap;
    int st=run_function_capture_output(sc_multi_distrib,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Distributed example: fork")
               && strstr(cap.stdout_buf,"HPC overshadow done")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing multi distributed logs");
        return false;
    }
    return true;
}
TEST(test_pipeline_modes){
    struct captured_output cap;
    int st=run_function_capture_output(sc_pipeline,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Pipeline start")
               && strstr(cap.stdout_buf,"Pipeline end")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing pipeline logs");
        return false;
    }
    return true;
}
TEST(test_mix_algos){
    struct captured_output cap;
    int st=run_function_capture_output(sc_mix_algos,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for FIFO")
               && strstr(cap.stdout_buf,"Stats for BFS")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing FIFO/BFS logs");
        return false;
    }
    return true;
}
TEST(test_double_hpc){
    struct captured_output cap;
    int st=run_function_capture_output(sc_double_hpc,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"HPC overshadow start")
               && strstr(cap.stdout_buf,"HPC overshadow done")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"Missing HPC overshadow logs");
        return false;
    }
    return true;
}

void run_modes_tests(int* total,int* passed){
    tests_run=0; tests_failed=0;
    RUN_TEST(test_hpc_over);
    RUN_TEST(test_multi_containers);
    RUN_TEST(test_multi_distrib);
    RUN_TEST(test_pipeline_modes);
    RUN_TEST(test_mix_algos);
    RUN_TEST(test_double_hpc);
    *total=tests_run;
    *passed=(tests_run-tests_failed);
}
/* modes-test.h */
#ifndef MODES_TEST_H
#define MODES_TEST_H
void run_modes_tests(int* total,int* passed);
#endif
#include "normal-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"

static int tests_run=0,tests_failed=0;

static void sc_sjf_run(void){
    os_init();
    process_t p[3];
    init_process(&p[0],1,1,os_time());
    init_process(&p[1],5,1,os_time());
    init_process(&p[2],2,1,os_time());
    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,3);
    os_cleanup();
}
static void sc_strf_run(void){
    os_init();
    process_t p[2];
    init_process(&p[0],4,1,os_time());
    init_process(&p[1],3,1,os_time());
    scheduler_select_algorithm(ALG_STRF);
    scheduler_run(p,2);
    os_cleanup();
}
static void sc_hrrn_run(void){
    os_init();
    process_t p[3];
    for(int i=0;i<3;i++){
        init_process(&p[i],2+i,1,os_time());
    }
    scheduler_select_algorithm(ALG_HRRN);
    scheduler_run(p,3);
    os_cleanup();
}
static void sc_hrrn_rt_run(void){
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,os_time());
    init_process(&p[1],4,2,os_time());
    scheduler_select_algorithm(ALG_HRRN_RT);
    scheduler_run(p,2);
    os_cleanup();
}
static void sc_prio_run(void){
    os_init();
    process_t p[3];
    init_process(&p[0],2,3,os_time());
    init_process(&p[1],2,1,os_time());
    init_process(&p[2],2,2,os_time());
    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,3);
    os_cleanup();
}
static void sc_cfs_srtf_run(void){
    os_init();
    process_t p[3];
    for(int i=0;i<3;i++){
        init_process(&p[i],2+i,1,os_time());
    }
    scheduler_select_algorithm(ALG_CFS_SRTF);
    scheduler_run(p,3);
    os_cleanup();
}

TEST(test_sjf){
    struct captured_output cap;
    int st=run_function_capture_output(sc_sjf_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for SJF")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"SJF logs not found");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_SJF);
    return true;
}
TEST(test_strf){
    struct captured_output cap;
    int st=run_function_capture_output(sc_strf_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for STRF")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"STRF logs missing");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_STRF);
    return true;
}
TEST(test_hrrn){
    struct captured_output cap;
    int st=run_function_capture_output(sc_hrrn_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for HRRN")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"HRRN logs missing");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN);
    return true;
}
TEST(test_hrrn_rt){
    struct captured_output cap;
    int st=run_function_capture_output(sc_hrrn_rt_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for HRRN-RT")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"HRRN-RT logs missing");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN_RT);
    return true;
}
TEST(test_priority){
    struct captured_output cap;
    int st=run_function_capture_output(sc_prio_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for PRIORITY")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"PRIORITY logs missing");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_PRIORITY);
    return true;
}
TEST(test_cfs_srtf){
    struct captured_output cap;
    int st=run_function_capture_output(sc_cfs_srtf_run,&cap);
    bool pass=(st==0 && strstr(cap.stdout_buf,"Init")
               && strstr(cap.stdout_buf,"Stats for CFS-SRTF")
               && strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),"CFS-SRTF logs missing");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS_SRTF);
    return true;
}

void run_normal_tests(int* total,int* passed){
    tests_run=0; tests_failed=0;
    RUN_TEST(test_sjf);
    RUN_TEST(test_strf);
    RUN_TEST(test_hrrn);
    RUN_TEST(test_hrrn_rt);
    RUN_TEST(test_priority);
    RUN_TEST(test_cfs_srtf);
    *total=tests_run;
    *passed=(tests_run-tests_failed);
}
#ifndef NORMAL_TEST_H
#define NORMAL_TEST_H
void run_normal_tests(int*,int*);
#endif
#include "test_common.h"
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>

static ssize_t read_all(int fd, char* buf, size_t cap){
    size_t used=0;
    while(used+1<cap){
        ssize_t r=read(fd,buf+used,cap-1-used);
        if(r<0 && errno==EINTR) continue;
        if(r<=0) break;
        used+=(size_t)r;
    }
    buf[used]='\0';
    return (ssize_t)used;
}

int run_function_capture_output(void(*fn)(void), struct captured_output* out){
    if(!fn||!out)return -1;
    int p_out[2],p_err[2];
    if(pipe(p_out)==-1||pipe(p_err)==-1)return -1;
    int orig_out=dup(STDOUT_FILENO),orig_err=dup(STDERR_FILENO);
    if(orig_out<0||orig_err<0){
        close(p_out[0]);close(p_out[1]);
        close(p_err[0]);close(p_err[1]);
        return -1;
    }
    pid_t c=fork();
    if(c<0){
        close(p_out[0]);close(p_out[1]);
        close(p_err[0]);close(p_err[1]);
        return -1;
    }
    if(c==0){
        dup2(p_out[1],STDOUT_FILENO);
        dup2(p_err[1],STDERR_FILENO);
        close(p_out[0]);close(p_out[1]);
        close(p_err[0]);close(p_err[1]);
        fn();
        _exit(0);
    }
    close(p_out[1]); close(p_err[1]);
    read_all(p_out[0], out->stdout_buf, sizeof(out->stdout_buf));
    read_all(p_err[0], out->stderr_buf, sizeof(out->stderr_buf));
    close(p_out[0]); close(p_err[0]);
    dup2(orig_out,STDOUT_FILENO);
    dup2(orig_err,STDERR_FILENO);
    close(orig_out); close(orig_err);
    int status=0; waitpid(c,&status,0);
    return status;
}

int run_shell_command_capture_output(const char* line, struct captured_output* out){
    if(!line||!out)return -1;
    int p_out[2],p_err[2],p_in[2];
    if(pipe(p_out)==-1||pipe(p_err)==-1||pipe(p_in)==-1)return -1;
    int o_out=dup(STDOUT_FILENO),o_err=dup(STDERR_FILENO),o_in=dup(STDIN_FILENO);
    if(o_out<0||o_err<0||o_in<0){
        close(p_out[0]);close(p_out[1]);
        close(p_err[0]);close(p_err[1]);
        close(p_in[0]);close(p_in[1]);
        return -1;
    }
    pid_t c=fork();
    if(c<0){
        close(p_out[0]);close(p_out[1]);
        close(p_err[0]);close(p_err[1]);
        close(p_in[0]);close(p_in[1]);
        return -1;
    }
    if(c==0){
        dup2(p_in[0],STDIN_FILENO);
        dup2(p_out[1],STDOUT_FILENO);
        dup2(p_err[1],STDERR_FILENO);
        close(p_in[1]);
        close(p_out[0]);close(p_out[1]);
        close(p_err[0]);close(p_err[1]);
        execl("./shell-tp1-implementation","shell-tp1-implementation",(char*)NULL);
        _exit(127);
    }
    close(p_in[0]);
    write(p_in[1],line,strlen(line));
    write(p_in[1],"\n",1);
    close(p_in[1]);
    close(p_out[1]); close(p_err[1]);
    read_all(p_out[0],out->stdout_buf,sizeof(out->stdout_buf));
    read_all(p_err[0],out->stderr_buf,sizeof(out->stderr_buf));
    close(p_out[0]); close(p_err[0]);
    dup2(o_out,STDOUT_FILENO); dup2(o_err,STDERR_FILENO); dup2(o_in,STDIN_FILENO);
    close(o_out);close(o_err);close(o_in);
    int status=0; waitpid(c,&status,0);
    return status;
}

int run_command_capture_output(char* const argv[], struct captured_output* out){
    if(!argv||!argv[0]||!out)return -1;
    int p_out[2],p_err[2];
    if(pipe(p_out)==-1||pipe(p_err)==-1)return -1;
    int o_out=dup(STDOUT_FILENO),o_err=dup(STDERR_FILENO);
    if(o_out<0||o_err<0){
        close(p_out[0]);close(p_out[1]);
        close(p_err[0]);close(p_err[1]);
        return -1;
    }
    pid_t c=fork();
    if(c<0){
        close(p_out[0]);close(p_out[1]);
        close(p_err[0]);close(p_err[1]);
        return -1;
    }
    if(c==0){
        dup2(p_out[1],STDOUT_FILENO);
        dup2(p_err[1],STDERR_FILENO);
        close(p_out[0]);close(p_out[1]);
        close(p_err[0]);close(p_err[1]);
        execvp(argv[0],argv);
        _exit(127);
    }
    close(p_out[1]); close(p_err[1]);
    read_all(p_out[0],out->stdout_buf,sizeof(out->stdout_buf));
    read_all(p_err[0],out->stderr_buf,sizeof(out->stderr_buf));
    close(p_out[0]); close(p_err[0]);
    dup2(o_out,STDOUT_FILENO); dup2(o_err,STDERR_FILENO);
    close(o_out); close(o_err);
    int status=0; waitpid(c,&status,0);
    return status;
}
#ifndef TEST_COMMON_H
#define TEST_COMMON_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

static char g_test_fail_reason[256]={0};

struct captured_output {
    char stdout_buf[4096];
    char stderr_buf[4096];
};

int run_function_capture_output(void(*fn)(void), struct captured_output* out);
int run_shell_command_capture_output(const char* line, struct captured_output* out);
int run_command_capture_output(char* const argv[], struct captured_output* out);

static inline void test_unicode_pass(const char* test_name){
    printf("  ✅  %s => reason: logs OK.\n", test_name);
}

static inline void test_unicode_fail(const char* test_name, const char* reason){
    printf("  ❌  %s => reason: %s\n", test_name, reason);
}

#define TEST(name) static bool test_##name(void)

/*
   We clear g_test_fail_reason, run the test, if fails => print reason or 'no reason set'.
*/
#define RUN_TEST(name) do {                                          \
memset(g_test_fail_reason,0,sizeof(g_test_fail_reason));          \
bool result=test_##name();                                       \
tests_run++;                                                     \
if(!result){                                                     \
tests_failed++;                                              \
test_unicode_fail(#name, g_test_fail_reason[0]?g_test_fail_reason:"no reason set"); \
} else {                                                         \
test_unicode_pass(#name);                                    \
}                                                                \
} while(0)

#endif
