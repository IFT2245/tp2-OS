
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include "runner.h"
#include "os.h"
#include "safe_calls_library.h"
#include "scoreboard.h"

#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GRAY    "\033[90m"
#define CLR_GREEN   "\033[92m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

static void cleanup_and_exit(int code);
static void handle_signal(int signum);

/* Clear terminal screen (POSIX vs Windows). */
static void clear_screen(void){
#if defined(_WIN32) || defined(_WIN64)
    system("cls");
#else
    system("clear");
#endif
}

static void pause_enter(void){
    printf("\nPress ENTER...");
    fflush(stdout);
    int c;
    while((c = getchar()) != '\n' && c != EOF){}
}

/* Safe read_line for user input. */
static int read_line(char *buf, size_t sz){
    if(!fgets(buf, sz, stdin)) return 0;
    buf[strcspn(buf, "\n")] = '\0';
    return 1;
}

/* Show scoreboard in a nice ASCII box. */
static void menu_show_scoreboard(void){
    scoreboard_t sb;
    get_scoreboard(&sb);
    clear_screen();

    printf(CLR_BOLD CLR_MAGENTA "╔════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_MAGENTA "║           ★ SCOREBOARD ★          ║\n" CLR_RESET);

    printf("║ BASIC       => %.1f/100 => %s\n",
           sb.basic_percent,
           unlocked_basic ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ NORMAL      => %.1f/100 => %s\n",
           sb.normal_percent,
           unlocked_normal ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ EXTERNAL    => %.1f/100 => %s\n",
           sb.external_percent,
           unlocked_external ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ MODES       => %.1f/100 => %s\n",
           sb.modes_percent,
           unlocked_modes ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ EDGE        => %.1f/100 => %s\n",
           sb.edge_percent,
           unlocked_edge ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ HIDDEN      => %.1f/100 => %s\n",
           sb.hidden_percent,
           unlocked_hidden ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║\n");
    printf("║ Schedulers mastery (for 10%% block):\n");
    printf("║   FIFO:%s  RR:%s  CFS:%s  CFS-SRTF:%s  BFS:%s\n",
           sb.sc_fifo? "✔":"✘",
           sb.sc_rr? "✔":"✘",
           sb.sc_cfs? "✔":"✘",
           sb.sc_cfs_srtf? "✔":"✘",
           sb.sc_bfs? "✔":"✘");

    printf("║   SJF:%s  STRF:%s  HRRN:%s  HRRN-RT:%s  PRIORITY:%s\n",
           sb.sc_sjf? "✔":"✘",
           sb.sc_strf? "✔":"✘",
           sb.sc_hrrn? "✔":"✘",
           sb.sc_hrrn_rt? "✔":"✘",
           sb.sc_priority? "✔":"✘");

    printf("║   HPC-OVER:%s  MLFQ:%s\n",
           sb.sc_hpc_over? "✔":"✘",
           sb.sc_mlfq? "✔":"✘");

    int final_score = scoreboard_get_final_score();
    printf("║\n");
    printf("╚═ Overall Score => %d/100\n", final_score);
    pause_enter();
}

/* Clear scoreboard entirely. */
static void menu_clear_scoreboard(void){
    scoreboard_clear();
    printf("\nScoreboard cleared.\n");
    pause_enter();
}

/* Cleanup and exit. */
static void cleanup_and_exit(int code){
    os_cleanup();
    scoreboard_save();
    scoreboard_close();
    exit(code);
}

/* Handle Ctrl-C => Save scoreboard before exiting. */
static void handle_signal(int signum){
    if(signum == SIGINT){
        printf("\nCaught SIGINT! Saving scoreboard...\n");
        int fs = scoreboard_get_final_score();
        cleanup_and_exit(fs);
    }
}

/* Let user choose concurrency level => short, medium, stress. */
static int menu_choose_concurrency_level(void){
    printf("\nChoose concurrency test type:\n");
    printf(" 1) Short test (sleep 2)\n");
    printf(" 2) Medium test (sleep 5, etc.)\n");
    printf(" 3) Stress test (sleep 10 or 12, etc.)\n");
    printf("Choice: ");
    char buf[256];
    if(!read_line(buf,sizeof(buf))) return 1;
    int x = parse_int_strtol(buf,1);
    if(x<1 || x>3) x=1;
    return x;
}

/*
  Submenu for external concurrency:
   1) single scheduling mode
   2) all scheduling modes
*/
static void menu_submenu_external_concurrency(void){
    printf(CLR_BOLD CLR_CYAN "\n╔══════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "║ External Shell Concurrency   ║\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "╚══════════════════════════════╝\n" CLR_RESET);

    printf("1) Run concurrency with a SINGLE scheduling mode\n");
    printf("2) Run concurrency with ALL scheduling modes\n");
    printf("\nChoice: ");
    char buf[256];
    if(!read_line(buf, sizeof(buf))) return;
    int sub = parse_int_strtol(buf, -1);
    if(sub < 1 || sub > 2){
        printf("Invalid.\n");
        pause_enter();
        return;
    }

    printf("How many concurrent shells? ");
    if(!read_line(buf, sizeof(buf))) return;
    int n = parse_int_strtol(buf, 0);
    if(n<1){
        printf("Invalid number of shells.\n");
        pause_enter();
        return;
    }

    printf("How many CPU cores? ");
    if(!read_line(buf, sizeof(buf))) return;
    int c = parse_int_strtol(buf, 2);
    if(c<1) c=2;

    /* Build lines array based on style or ALL modes. */
    char** lines = (char**)calloc(n, sizeof(char*));
    if(sub==1){
        int style=menu_choose_concurrency_level();
        if(style==1){
            for(int i=0;i<n;i++){
                char tmp[64];
                snprintf(tmp,sizeof(tmp),"sleep %d", (i+1)*2);
                lines[i]=strdup(tmp);
            }
        } else if(style==2){
            for(int i=0;i<n;i++){
                char tmp[64];
                snprintf(tmp,sizeof(tmp),"sleep %d", ((i+1)*3)+2);
                lines[i]=strdup(tmp);
            }
        } else {
            for(int i=0;i<n;i++){
                char tmp[64];
                snprintf(tmp,sizeof(tmp),"sleep %d", (i+1)*5);
                lines[i]=strdup(tmp);
            }
        }
    } else {
        /* sub==2 => same lines for all modes => "sleep 2" scaled. */
        for(int i=0;i<n;i++){
            char tmp[64];
            snprintf(tmp,sizeof(tmp),"sleep %d", (i+1)*2);
            lines[i]=strdup(tmp);
        }
    }

    if(sub==1){
        printf("\nSelect scheduling mode:\n");
        printf(" 0=FIFO,1=RR,2=CFS,3=CFS-SRTF,4=BFS,\n");
        printf(" 5=SJF,6=STRF,7=HRRN,8=HRRN-RT,\n");
        printf(" 9=PRIORITY,10=HPC-OVER,11=MLFQ\n");
        printf("Choice: ");
        if(!read_line(buf,sizeof(buf))){
            pause_enter();
            for(int i=0;i<n;i++) free(lines[i]);
            free(lines);
            return;
        }
        int mode = parse_int_strtol(buf, -1);
        if(mode<0 || mode>11){
            printf("Invalid mode.\n");
            pause_enter();
        } else {
            run_shell_commands_concurrently(n, lines, c, mode, 0);
        }
    } else {
        run_shell_commands_concurrently(n, lines, c, -1, 1);
    }

    for(int i=0; i<n; i++){
        free(lines[i]);
    }
    free(lines);
    pause_enter();
}

int main(int argc, char** argv){
    (void)argc; (void)argv;
    signal(SIGINT, handle_signal);

    scoreboard_init();
    scoreboard_load();
    os_init();

    while(1){
        clear_screen();
        printf(CLR_BOLD CLR_YELLOW "┌─── MAIN MENU ────────────────────┐\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 1) Run All Unlocked              │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 2) Exit                          │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 3) External Shell Concurrency    │\n" CLR_RESET);

        if(unlocked_external){
            printf(CLR_BOLD CLR_YELLOW "│ 4) External Tests                │\n" CLR_RESET);
        } else {
            printf(CLR_BOLD CLR_YELLOW "│ 4) External Tests " CLR_GRAY "(locked)" CLR_RESET "\n");
        }

        printf(CLR_BOLD CLR_YELLOW "│ 5) Show Scoreboard               │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 6) Clear Scoreboard              │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "└───────────────────────────────────┘\n\n" CLR_RESET);
        printf("Choice: ");

        char input[256];
        if(!read_line(input, sizeof(input))){
            printf("Exiting (EOF/read error).\n");
            int fs = scoreboard_get_final_score();
            cleanup_and_exit(fs);
        }
        int choice = parse_int_strtol(input, -1);

        switch(choice){
        case 1:
            printf("\n" CLR_CYAN "Running all unlocked tests...\n" CLR_RESET);
            run_all_levels();
            scoreboard_save();
            pause_enter();
            break;

        case 2:{
            int fs = scoreboard_get_final_score();
            printf("\nExiting with final score = %d.\n", fs);
            cleanup_and_exit(fs);
            break;
        }

        case 3:
            if(!unlocked_external){
                printf("External is locked.\n");
                pause_enter();
            } else {
                menu_submenu_external_concurrency();
            }
            break;

        case 4:
            if(!unlocked_external){
                printf("External tests locked.\n");
                pause_enter();
            } else {
                printf("\nRunning external tests...\n");
                run_external_tests_menu();
                scoreboard_save();
                pause_enter();
            }
            break;

        case 5:
            menu_show_scoreboard();
            break;

        case 6:
            menu_clear_scoreboard();
            break;

        default:
            printf("Invalid.\n");
            pause_enter();
            break;
        }
    }
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <errno.h>
#include <sys/ptrace.h>
#include "os.h"

#define MAX_CONTAINERS 32

#define CLR_CYAN    "\033[96m"
#define CLR_GREEN   "\033[92m"
#define CLR_RESET   "\033[0m"
#define CLR_YELLOW  "\033[93m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"

static uint64_t start_ms=0;
static char container_paths[MAX_CONTAINERS][256];
static int container_count=0;

static uint64_t now_ms(void){
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec*1000ULL + (ts.tv_nsec/1000000ULL);
}

void os_init(void){
    setvbuf(stdout,NULL,_IONBF,0);
    setvbuf(stderr,NULL,_IONBF,0);
    start_ms=now_ms();
    memset(container_paths, 0, sizeof(container_paths));
    container_count=0;

    printf(CLR_BOLD CLR_MAGENTA "==== OS INIT ====" CLR_RESET "\n");
    usleep(250000);
}

void os_cleanup(void){
    while(container_count>0){
        os_remove_ephemeral_container();
        usleep(200000);
    }
    printf(CLR_BOLD CLR_MAGENTA "==== OS CLEANUP ====" CLR_RESET "\n");
    usleep(250000);
}

uint64_t os_time(void){
    return now_ms() - start_ms;
}

void os_log(const char* msg){
    if(msg) {
        printf("%s\n", msg);
        usleep(150000);
    }
}

void os_create_ephemeral_container(void){
    if(container_count >= MAX_CONTAINERS) return;
    char tmpl[]="/tmp/os_cont_XXXXXX";
    if(mkdtemp(tmpl)){
        strncpy(container_paths[container_count], tmpl, 255);
        container_count++;
        printf(CLR_CYAN "$$$$$ Container created: %s (count=%d) $$$$$" CLR_RESET "\n",
               tmpl, container_count);
        usleep(250000);
    }
}

void os_remove_ephemeral_container(void){
    if(container_count<=0) return;
    container_count--;
    const char* path=container_paths[container_count];
    if(path[0]){
        rmdir(path);
        memset(container_paths[container_count], 0, sizeof(container_paths[container_count]));
        printf(CLR_CYAN "$$$$$ Container removed: %s (remaining=%d) $$$$$" CLR_RESET "\n",
               path, container_count);
        usleep(250000);
    }
}

/* overshadow_thread simulates HPC overshadowing. */
static void* overshadow_thread(void* arg){
    long* ret=(long*)arg;
    long s=0;
    for(long i=0; i<700000; i++){
        s += (i%17)+(i%11);
    }
    *ret=s;
    return NULL;
}

void os_run_hpc_overshadow(void){
    printf(CLR_CYAN "$$$$$$$$$$$$$ HPC-OVERSHADOW BLOCK START $$$$$$$$$$$$$\n" CLR_RESET);
    usleep(200000);

    int n=4;
    long* vals=(long*)calloc(n,sizeof(long));
    pthread_t* th=(pthread_t*)malloc(n*sizeof(pthread_t));

    for(int i=0;i<n;i++){
        pthread_create(&th[i],NULL,overshadow_thread,&vals[i]);
        printf(CLR_GREEN "   HPC Overshadow Thread #%d => time=%llu ms => started.\n" CLR_RESET,
               i+1, (unsigned long long)os_time());
        usleep(300000);
    }

    for(int i=0;i<n;i++){
        pthread_join(th[i],NULL);
        printf(CLR_GREEN "   HPC Overshadow Thread #%d => time=%llu ms => finished.\n" CLR_RESET,
               i+1, (unsigned long long)os_time());
        usleep(300000);
    }

    free(th);
    free(vals);

    printf(CLR_CYAN "$$$$$$$$$$$$$ HPC-OVERSHADOW BLOCK END $$$$$$$$$$$$$\n" CLR_RESET);
    usleep(200000);
    printf("HPC overshadow done\n");
    usleep(200000);
}

void os_pipeline_example(void){
    printf("Pipeline start\n");
    printf(CLR_CYAN "$$$$$$$$$$$ PIPELINE BLOCK START $$$$$$$$$$$$$\n" CLR_RESET);
    usleep(200000);

    pid_t c=fork();
    if(c==0){
        printf(CLR_GREEN "   [Pipeline child => started => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        usleep(50000);
        printf(CLR_GREEN "   [Pipeline child => finishing => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        _exit(0);
    }
    printf(CLR_GREEN "   [Pipeline parent => waiting child => time=%llu ms]\n" CLR_RESET,
           (unsigned long long)os_time());
    usleep(200000);
    waitpid(c,NULL,0);

    printf(CLR_CYAN "$$$$$$$$$$$ PIPELINE BLOCK END $$$$$$$$$$$$$\n" CLR_RESET);
    usleep(200000);
    printf("Pipeline end\n");
    usleep(200000);
}

void os_run_distributed_example(void){
    printf("Distributed example: fork\n");
    printf(CLR_CYAN "$$$$$$$ DISTRIBUTED BLOCK START $$$$$$$$\n" CLR_RESET);
    usleep(200000);

    pid_t c=fork();
    if(c==0){
        printf(CLR_GREEN "   [Distributed child => HPC overshadow => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        usleep(200000);
        os_run_hpc_overshadow();
        _exit(0);
    } else {
        printf(CLR_GREEN "   [Distributed parent => waiting => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        usleep(200000);
        waitpid(c,NULL,0);
    }

    printf(CLR_CYAN "$$$$$$$ DISTRIBUTED BLOCK END $$$$$$$$\n" CLR_RESET);
    usleep(200000);
}
#ifndef OS_H
#define OS_H

#include <stdint.h>

void     os_init(void);
void     os_cleanup(void);
uint64_t os_time(void);
void     os_log(const char* msg);

void     os_create_ephemeral_container(void);
void     os_remove_ephemeral_container(void);

void     os_run_hpc_overshadow(void);
void     os_pipeline_example(void);
void     os_run_distributed_example(void);

#endif
#include "process.h"
#include <string.h>

void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival){
    if(!p) return;
    memset(p, 0, sizeof(*p));
    p->burst_time     = burst;
    p->remaining_time = burst;
    p->priority       = priority;
    p->arrival_time   = arrival;
    p->times_owning_core = 0;
}
#ifndef PROCESS_H
#define PROCESS_H

#include <stdint.h>

typedef struct process_s {
    uint64_t burst_time;
    int      priority;
    uint64_t vruntime;
    uint64_t arrival_time;
    uint64_t remaining_time;
    uint64_t last_exec;
    int      mlfq_level;
    int      times_owning_core;
} process_t;

void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival);

#endif
#include <pthread.h>
#include <stdlib.h>
#include <string.h>
#include "ready_queue.h"
#include "os.h"

#define MLFQ_MAX_QUEUES 10

typedef struct node_s {
    process_t*     proc;
    struct node_s* next;
} node_t;

static struct {
    node_t sentinel;
    size_t size;
    pthread_mutex_t m;
    pthread_cond_t  c;
    scheduler_alg_t alg;
    node_t ml_queues[MLFQ_MAX_QUEUES];
} gQ;

static pthread_mutex_t* pm(void){ return &gQ.m; }
static pthread_cond_t*  pc(void){ return &gQ.c; }

static process_t* pop_head(void){
    while(!gQ.sentinel.next){
        pthread_cond_wait(pc(), pm());
    }
    node_t* n=gQ.sentinel.next;
    gQ.sentinel.next=n->next;
    gQ.size--;
    process_t* r=n->proc;
    free(n);
    return r;
}

static void push_tail(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;

    node_t* c=&gQ.sentinel;
    while(c->next) c=c->next;
    c->next=n;
    gQ.size++;
}

static void push_prio(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;

    node_t* c=&gQ.sentinel;
    while(c->next && p->priority <= c->next->proc->priority){
        c=c->next;
    }
    n->next=c->next;
    c->next=n;
    gQ.size++;
}

static void push_cfs(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;
    node_t* c=&gQ.sentinel;
    while(c->next && p->vruntime >= c->next->proc->vruntime){
        c=c->next;
    }
    n->next=c->next;
    c->next=n;
    gQ.size++;
}

static void push_sjf(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;
    node_t* c=&gQ.sentinel;
    while(c->next && p->burst_time >= c->next->proc->burst_time){
        c=c->next;
    }
    n->next=c->next;
    c->next=n;
    gQ.size++;
}

static uint64_t hrrn_val(process_t* p, uint64_t now){
    if(!p->burst_time) return 999999;
    uint64_t w=(now>p->arrival_time?(now - p->arrival_time):0);
    uint64_t r=(p->remaining_time>0? p->remaining_time : 1);
    return (w + r)/r;
}

static void push_hrrn(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;

    uint64_t now=os_time();
    node_t* c=&gQ.sentinel;
    while(c->next){
        uint64_t cv=hrrn_val(c->next->proc, now);
        uint64_t pv=hrrn_val(p, now);
        if(pv>cv) break;
        c=c->next;
    }
    n->next=c->next;
    c->next=n;
    gQ.size++;
}

static process_t* pop_mlfq(void){
    for(int i=0;i<MLFQ_MAX_QUEUES;i++){
        if(gQ.ml_queues[i].next){
            node_t* n=gQ.ml_queues[i].next;
            gQ.ml_queues[i].next=n->next;
            gQ.size--;
            process_t* r=n->proc;
            free(n);
            return r;
        }
    }
    return NULL;
}

static void push_mlfq(process_t* p){
    if(!p) return;
    int lev=p->mlfq_level;
    if(lev<0) lev=0;
    if(lev>=MLFQ_MAX_QUEUES) lev=MLFQ_MAX_QUEUES-1;
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;

    node_t* c=&gQ.ml_queues[lev];
    while(c->next) c=c->next;
    c->next=n;
    gQ.size++;
}

static process_t*(*f_pop)(void)=NULL;
static void(*f_push)(process_t*)=NULL;

void ready_queue_init_policy(scheduler_alg_t alg){
    memset(&gQ, 0, sizeof(gQ));
    pthread_mutex_init(pm(), NULL);
    pthread_cond_init(pc(), NULL);
    gQ.alg=alg;

    switch(alg){
    case ALG_FIFO:
    case ALG_RR:
    case ALG_BFS:
        f_push=push_tail;
        f_pop=pop_head;
        break;
    case ALG_PRIORITY:
        f_push=push_prio;
        f_pop=pop_head;
        break;
    case ALG_CFS:
    case ALG_CFS_SRTF:
        f_push=push_cfs;
        f_pop=pop_head;
        break;
    case ALG_SJF:
    case ALG_STRF:
        f_push=push_sjf;
        f_pop=pop_head;
        break;
    case ALG_HRRN:
    case ALG_HRRN_RT:
        f_push=push_hrrn;
        f_pop=pop_head;
        break;
    case ALG_MLFQ:
        f_push=push_mlfq;
        f_pop=pop_mlfq;
        break;
    default:
        f_push=push_tail;
        f_pop=pop_head;
        break;
    }
}

void ready_queue_destroy(void){
    pthread_cond_destroy(pc());
    pthread_mutex_destroy(pm());
    memset(&gQ, 0, sizeof(gQ));
}

void ready_queue_push(process_t* p){
    pthread_mutex_lock(pm());
    f_push(p);
    pthread_cond_signal(pc());
    pthread_mutex_unlock(pm());
}

process_t* ready_queue_pop(void){
    pthread_mutex_lock(pm());
    process_t* r=f_pop();
    while(!r){
        pthread_cond_wait(pc(), pm());
        r=f_pop();
    }
    pthread_mutex_unlock(pm());
    return r;
}

size_t ready_queue_size(void){
    pthread_mutex_lock(pm());
    size_t s=gQ.size;
    pthread_mutex_unlock(pm());
    return s;
}
#ifndef READY_QUEUE_H
#define READY_QUEUE_H

#include <stddef.h>
#include "process.h"
#include "scheduler.h"

void       ready_queue_init_policy(scheduler_alg_t alg);
void       ready_queue_destroy(void);
void       ready_queue_push(process_t* proc);
process_t* ready_queue_pop(void);
size_t     ready_queue_size(void);

#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include "runner.h"
#include "scoreboard.h"
#include "os.h"
#include "scheduler.h"
#include "worker.h"
#include "../test/basic-test.h"
#include "../test/normal-test.h"
#include "../test/modes-test.h"
#include "../test/edge-test.h"
#include "../test/hidden-test.h"
#include "../test/external-test.h"
#include <sys/ptrace.h>
#include <errno.h>

/*
  run_all_levels():
    - We only call each suite if unlocked.
    - That suite’s "run_X_tests()" calls all its test functions with RUN_TEST(...).
    - No test is left orphaned.
*/
void run_all_levels(void){
    extern int unlocked_basic, unlocked_normal, unlocked_modes,
                unlocked_edge, unlocked_hidden;

    if(!unlocked_basic){
        printf("BASIC locked.\n");
        return;
    }
    {
        int t=0,p=0;
        run_basic_tests(&t,&p);
        scoreboard_update_basic(t,p);
        scoreboard_save();
    }

    if(!unlocked_normal){
        printf("NORMAL locked.\n");
        return;
    }
    {
        int t=0,p=0;
        run_normal_tests(&t,&p);
        scoreboard_update_normal(t,p);
        scoreboard_save();
    }

    if(!unlocked_modes){
        printf("MODES locked.\n");
        return;
    }
    {
        int t=0,p=0;
        run_modes_tests(&t,&p);
        scoreboard_update_modes(t,p);
        scoreboard_save();
    }

    if(!unlocked_edge){
        printf("EDGE locked.\n");
        return;
    }
    {
        int t=0,p=0;
        run_edge_tests(&t,&p);
        scoreboard_update_edge(t,p);
        scoreboard_save();
    }

    if(!unlocked_hidden){
        printf("HIDDEN locked.\n");
        return;
    }
    {
        int t=0,p=0;
        run_hidden_tests(&t,&p);
        scoreboard_update_hidden(t,p);
        scoreboard_save();
    }
}

void run_external_tests_menu(void){
    extern int unlocked_external;
    if(!unlocked_external) return;
    run_external_tests(); /* from external-test.c */
}

/* Example advanced child tracing with ptrace. */
static void advanced_debug_child(pid_t pid){
    if(ptrace(PTRACE_ATTACH, pid, NULL, NULL)==-1){
        fprintf(stderr,"[Runner] ptrace attach fail (pid=%d): %s\n",
                pid, strerror(errno));
        return;
    }
    waitpid(pid,NULL,0);
    ptrace(PTRACE_DETACH, pid, NULL, NULL);
}

/*
  We'll spawn each child with a dedicated "shell" in which
  the "sleep XX" runs, then exit. We also attach ptrace for demonstration.
*/

typedef struct {
    pid_t pid;
    char* cmd;
    int   core;
    uint64_t start_ms;
    uint64_t end_ms;
    int   p_out[2];
    int   p_err[2];
    int   p_in[2];
} child_t;

/* All possible modes: 12 total. */
static scheduler_alg_t modes_arr[]={
    ALG_FIFO, ALG_RR, ALG_CFS, ALG_CFS_SRTF, ALG_BFS,
    ALG_SJF, ALG_STRF, ALG_HRRN, ALG_HRRN_RT, ALG_PRIORITY,
    ALG_HPC_OVERSHADOW, ALG_MLFQ
};

static const char* modeNames[]={
    "FIFO","RR","CFS","CFS-SRTF","BFS",
    "SJF","STRF","HRRN","HRRN-RT","PRIORITY",
    "HPC-OVER","MLFQ"
};

static pid_t spawn_child(const char* cmd, child_t* ch, int core){
    pipe(ch->p_out);
    pipe(ch->p_err);
    pipe(ch->p_in);

    pid_t c=fork();
    if(c<0){
        fprintf(stderr,"fork() error\n");
        return -1;
    }
    else if(c==0){
        close(ch->p_out[0]);
        close(ch->p_err[0]);
        close(ch->p_in[0]);
        dup2(ch->p_out[1],STDOUT_FILENO);
        dup2(ch->p_err[1],STDERR_FILENO);
        dup2(ch->p_in[1],STDIN_FILENO);
        close(ch->p_out[1]);
        close(ch->p_err[1]);
        close(ch->p_in[1]);

        execl("./shell-tp1-implementation", "shell-tp1-implementation", (char*)NULL);
        _exit(127);
    }
    else {
        ch->pid=c;
        ch->cmd=(cmd?strdup(cmd):NULL);
        ch->core=core;
        ch->start_ms=os_time();
        close(ch->p_out[1]);
        close(ch->p_err[1]);
        close(ch->p_in[0]);

        /* Send the command and exit command into child's stdin. */
        dprintf(ch->p_in[1], "%s\nexit\n", cmd?cmd:"");
        close(ch->p_in[1]);

        /* Attach ptrace => advanced debugging example. */
        advanced_debug_child(c);
    }
    return c;
}

/*
  run_shell_commands_concurrently():
   - If (mode<0 & allModes=1) => test all known sched modes.
   - Else => test chosen mode.
   - Each child => runs "shell-tp1-implementation" with "sleep" command.
   - We show concurrency lines with ASCII-art block.
*/
void run_shell_commands_concurrently(int count, char** lines, int coreCount,
                                     int mode, int allModes)
{
    if(count<=0 || !lines) return;
    if(access("./shell-tp1-implementation", X_OK)!=0){
        printf("No shell-tp1-implementation found.\n");
        return;
    }

    int from=0;
    int to=(int)(sizeof(modes_arr)/sizeof(modes_arr[0]))-1;
    if(!allModes){
        if(mode<0 || mode>to){
            printf("Invalid scheduling mode.\n");
            return;
        }
        from=to=mode;
    }

    for(int m=from; m<=to; m++){
        printf("\n\033[95m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
        printf("SCHEDULE BLOCK START => %s\n", modeNames[m]);
        printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
        usleep(250000);

        child_t* ch=(child_t*)calloc(count, sizeof(child_t));
        if(!ch) return;

        uint64_t global_start=os_time();
        int next_core=0;

        /* Spawn children. */
        for(int i=0; i<count; i++){
            spawn_child(lines[i], &ch[i], next_core);
            printf("\033[92m[time=%llu ms] container=1 core=%d => Launch child#%d cmd=\"%s\"\033[0m\n",
                   (unsigned long long)os_time(),
                   next_core, i+1, lines[i]?lines[i]:"(none)");
            usleep(300000);
            next_core=(next_core+1) % coreCount;
        }

        /* Wait for each child. */
        for(int i=0; i<count; i++){
            if(!ch[i].pid) continue;
            waitpid(ch[i].pid, NULL, 0);
            ch[i].end_ms=os_time();
            printf("\033[93m[time=%llu ms] container=1 core=%d => Child#%d ended => cmd=\"%s\" total_duration=%llums\033[0m\n",
                   (unsigned long long)os_time(),
                   ch[i].core, i+1, ch[i].cmd?ch[i].cmd:"",
                   (unsigned long long)(ch[i].end_ms - ch[i].start_ms));
            usleep(300000);
        }

        uint64_t global_end=os_time();
        uint64_t total_time=(global_end>global_start?(global_end - global_start):0ULL);

        /* Drain leftover output, close pipes. */
        for(int i=0; i<count; i++){
            if(!ch[i].pid) continue;
            char outb[256]={0}, errb[256]={0};
            read(ch[i].p_out[0], outb, sizeof(outb)-1);
            read(ch[i].p_err[0], errb, sizeof(errb)-1);
            close(ch[i].p_out[0]);
            close(ch[i].p_err[0]);
            if(ch[i].cmd) free(ch[i].cmd);
        }
        free(ch);

        printf("\033[96m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
        printf("SCHEDULE BLOCK END => %s, total_time=%llums\n",
               modeNames[m], (unsigned long long)total_time);
        printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
        usleep(400000);
    }
}
#ifndef RUNNER_H
#define RUNNER_H

void run_all_levels(void);
void run_external_tests_menu(void);

void run_shell_commands_concurrently(int count,
                                     char** lines,
                                     int coreCount,
                                     int mode,
                                     int allModes);

#endif
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <string.h>
#include "safe_calls_library.h"

int parse_int_strtol(const char* in, int fb){
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    long v=strtol(in,&e,10);
    if(e==in || errno==ERANGE || v<INT_MIN || v>INT_MAX) return fb;
    return (int)v;
}

long parse_long_strtol(const char* in, long fb){
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    long v=strtol(in,&e,10);
    if(e==in||errno==ERANGE) return fb;
    return v;
}

float parse_float_strtof(const char* in, float fb){
    if(!in||!*in) return fb;
    errno=0;
    char* e=NULL;
    float v=strtof(in,&e);
    if(e==in||errno==ERANGE) return fb;
    return v;
}

double parse_double_strtod(const char* in, double fb){
    if(!in||!*in) return fb;
    errno=0;
    char* e=NULL;
    double v=strtod(in,&e);
    if(e==in||errno==ERANGE) return fb;
    return v;
}

int safe_pthread_create(void*(*f)(void*), void* arg){
    pthread_t t;
    int r=pthread_create(&t,NULL,f,arg);
    if(r){
        fprintf(stderr,"pthread_create fail: %s\n", strerror(r));
        return -1;
    }
    pthread_detach(t);
    return 0;
}#ifndef SAFE_CALLS_LIBRARY_H
#define SAFE_CALLS_LIBRARY_H

int    safe_pthread_create(void*(*f)(void*), void* arg);
int    parse_int_strtol(const char* input, int fallback);
long   parse_long_strtol(const char* input, long fallback);
float  parse_float_strtof(const char* input, float fallback);
double parse_double_strtod(const char* input, double fallback);

#endif
#include "scheduler.h"
#include "ready_queue.h"
#include "os.h"
#include "worker.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* We'll keep final stats in static variables so tests can retrieve them. */
static scheduler_alg_t current_alg=ALG_CFS;

typedef struct {
    unsigned long long preemptions;
    unsigned long long total_processes;
    unsigned long long total_wait;
    unsigned long long total_turnaround;
    unsigned long long total_response;
} sched_stats_accum_t;

static sched_stats_accum_t gStats;
static double gAvgWait=0.0, gAvgTAT=0.0, gAvgResp=0.0;
static unsigned long long gPreemptions=0, gProcs=0;
static int HPC_over_mode=0;

typedef struct {
    uint64_t arrival;
    uint64_t start;
    uint64_t end;
    uint64_t cpu;
    int      started;
} track_t;

static track_t* gTrack=NULL;
static int gCount=0;

static void reset_accumulators(void){
    memset(&gStats, 0, sizeof(gStats));
    gAvgWait=0; gAvgTAT=0; gAvgResp=0;
    gPreemptions=0; gProcs=0;
    HPC_over_mode=0;
}

static void rec_arrival(int i){
    if(gTrack && gTrack[i].arrival==0){
        gTrack[i].arrival=os_time();
    }
}

static void rec_start(int i){
    if(gTrack && !gTrack[i].started){
        gTrack[i].start=os_time();
        gTrack[i].started=1;
    }
}

static void rec_cpu(int i, unsigned long slice){
    if(gTrack) gTrack[i].cpu += slice;
}

static void rec_end(int i){
    if(gTrack && gTrack[i].end==0){
        gTrack[i].end=os_time();
    }
}

static void finalize(void){
    if(gCount<=0 || HPC_over_mode) {
        return;
    }
    for(int i=0; i<gCount; i++){
        uint64_t at  = gTrack[i].arrival;
        uint64_t st  = gTrack[i].start;
        uint64_t et  = gTrack[i].end;
        uint64_t cpu = gTrack[i].cpu;

        uint64_t turn = (et>at)? (et - at) : 0ULL;
        uint64_t resp = (st>at)? (st - at) : 0ULL;
        uint64_t wait = (turn>cpu)? (turn - cpu) : 0ULL;

        gStats.total_turnaround += turn;
        gStats.total_response   += resp;
        gStats.total_wait       += wait;
    }
    unsigned long long n = gStats.total_processes;
    if(n>0){
        gAvgWait = (double)gStats.total_wait/(double)n;
        gAvgTAT  = (double)gStats.total_turnaround/(double)n;
        gAvgResp = (double)gStats.total_response/(double)n;
    }
    gPreemptions = gStats.preemptions;
    gProcs       = n;
}

static void enqueue_all(process_t* arr,int n){
    for(int i=0; i<n; i++){
        ready_queue_push(&arr[i]);
        gStats.total_processes++;
        rec_arrival(i);
    }
}

void scheduler_select_algorithm(scheduler_alg_t a){
    current_alg=a;
}

void scheduler_run(process_t* list,int count){
    reset_accumulators();
    if(!list || count<=0){
        return;
    }
    gCount=count;
    gTrack=(track_t*)calloc(count, sizeof(track_t));

    if(current_alg==ALG_HPC_OVERSHADOW){
        HPC_over_mode=1;
        /* Print big ASCII schedule block */
        printf("\n\033[95m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
        printf("SCHEDULE NAME => HPC-OVERSHADOW\n");
        printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
        usleep(300000);

        os_run_hpc_overshadow();

        printf("\033[96m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
        printf("SCHEDULE END => HPC-OVERSHADOW => no normal stats.\n");
        printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
        usleep(300000);

        free(gTrack);
        gTrack=NULL;
        gCount=0;
        return;
    }

    /* If normal scheduling: show ASCII-art block. */
    printf("\n\033[95m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
    printf("SCHEDULE NAME => %d (enum)\n", current_alg);
    printf("Number of processes=%d\n", count);
    printf("Time start=%llu ms\n", (unsigned long long)os_time());
    printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
    usleep(300000);

    ready_queue_init_policy(current_alg);
    enqueue_all(list, count);

    uint64_t t0 = os_time();
    int quantum=2;

    while(ready_queue_size()>0){
        process_t* p=ready_queue_pop();
        if(!p) break;
        int idx=(int)(p - list);

        /* Print each scheduling step with ASCII details. */
        printf("\033[93m[time=%llu ms] => container=1 core=??? => scheduling processPtr=%p\n"
               "   => burst_time=%lu, prio=%d, vruntime=%llu, remain=%llu, timesScheduled=%d\033[0m\n",
               (unsigned long long)os_time(),
               (void*)p,
               (unsigned long)p->burst_time,
               p->priority,
               (unsigned long long)p->vruntime,
               (unsigned long long)p->remaining_time,
               p->times_owning_core);
        usleep(300000);

        rec_start(idx);
        p->times_owning_core++;

        if(current_alg==ALG_RR || current_alg==ALG_BFS || current_alg==ALG_CFS_SRTF ||
           current_alg==ALG_STRF || current_alg==ALG_HRRN_RT || current_alg==ALG_MLFQ)
        {
            if(p->remaining_time > (unsigned long)quantum){
                simulate_process_partial(p, quantum);
                rec_cpu(idx, quantum);
                p->remaining_time -= quantum;

                if(current_alg==ALG_CFS_SRTF){
                    p->vruntime += quantum;
                }
                gStats.preemptions++;

                if(current_alg==ALG_MLFQ){
                    p->mlfq_level++;
                }

                printf("\033[94m   => PREEMPT => processPtr=%p => new remain=%llu => preemptions=%llu\033[0m\n",
                       (void*)p,
                       (unsigned long long)p->remaining_time,
                       (unsigned long long)gStats.preemptions);
                usleep(300000);

                ready_queue_push(p);
            } else {
                unsigned long slice = p->remaining_time;
                simulate_process_partial(p, slice);
                rec_cpu(idx, slice);
                p->remaining_time=0;
                rec_end(idx);

                printf("\033[92m   => FINISH => processPtr=%p => total CPU used=%lu ms => time=%llu ms\033[0m\n",
                       (void*)p,
                       (unsigned long)slice,
                       (unsigned long long)os_time());
                usleep(300000);
            }
        } else {
            unsigned long slice = p->remaining_time;
            simulate_process_partial(p, slice);
            rec_cpu(idx, slice);
            p->remaining_time=0;
            rec_end(idx);

            printf("\033[92m   => FINISH => processPtr=%p => total CPU used=%lu ms => time=%llu ms\033[0m\n",
                   (void*)p,
                   (unsigned long)slice,
                   (unsigned long long)os_time());
            usleep(300000);
        }
    }

    ready_queue_destroy();
    uint64_t total_time = os_time()-t0;

    finalize();

    /* End ASCII-art block */
    printf("\033[96m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
    printf("SCHEDULE END => alg=%d => totalTime=%llums\n", current_alg,
           (unsigned long long)total_time);
    printf("Stats: preemptions=%llu, totalProcs=%llu\n",
           (unsigned long long)gPreemptions,
           (unsigned long long)gProcs);
    printf("AvgWait=%.2f, AvgTAT=%.2f, AvgResp=%.2f\n",
           gAvgWait, gAvgTAT, gAvgResp);
    printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
    usleep(300000);

    free(gTrack);
    gTrack=NULL;
    gCount=0;
}

void scheduler_fetch_report(sched_report_t* out){
    if(!out) return;
    if(HPC_over_mode){
        out->avg_wait=0.0;
        out->avg_turnaround=0.0;
        out->avg_response=0.0;
        out->preemptions=0ULL;
        out->total_procs=0ULL;
    } else {
        out->avg_wait       = gAvgWait;
        out->avg_turnaround = gAvgTAT;
        out->avg_response   = gAvgResp;
        out->preemptions    = gPreemptions;
        out->total_procs    = gProcs;
    }
}
#ifndef SCHEDULER_H
#define SCHEDULER_H

#include "process.h"

typedef enum {
    ALG_CFS,
    ALG_CFS_SRTF,
    ALG_FIFO,
    ALG_RR,
    ALG_SJF,
    ALG_STRF,
    ALG_HRRN,
    ALG_HRRN_RT,
    ALG_BFS,
    ALG_PRIORITY,
    ALG_HPC_OVERSHADOW,
    ALG_MLFQ
} scheduler_alg_t;

typedef struct {
    double avg_wait;
    double avg_turnaround;
    double avg_response;
    unsigned long long preemptions;
    unsigned long long total_procs;
} sched_report_t;

void scheduler_select_algorithm(scheduler_alg_t a);
void scheduler_run(process_t* list, int count);
void scheduler_fetch_report(sched_report_t* out);

#endif
#include "scoreboard.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>

/*
  Weighted categories: BASIC(32%), NORMAL(20%), EXTERNAL(10%), MODES(10%),
  EDGE(10%), HIDDEN(8%), SCHEDULING(10%).
*/

int unlocked_basic=1;
int unlocked_normal=0;
int unlocked_external=0;
int unlocked_modes=0;
int unlocked_edge=0;
int unlocked_hidden=0;

static scoreboard_t gSB={
    0,0,0,0,0,0, /* test totals & passes */
    0,0,0,0,0,0, /* scheduling mastery flags */
    0.0,0.0,0.0,0.0,0.0,0.0, /* percentages for each test category */
    60.0 /* pass_threshold */
};

static void update_unlocks(void){
    /* Recalculate each category's pass %: */
    gSB.basic_percent=(gSB.basic_total>0)?
        ((gSB.basic_pass*100.0)/gSB.basic_total):0.0;
    gSB.normal_percent=(gSB.normal_total>0)?
        ((gSB.normal_pass*100.0)/gSB.normal_total):0.0;
    gSB.external_percent=(gSB.external_total>0)?
        ((gSB.external_pass*100.0)/gSB.external_total):0.0;
    gSB.modes_percent=(gSB.modes_total>0)?
        ((gSB.modes_pass*100.0)/gSB.modes_total):0.0;
    gSB.edge_percent=(gSB.edge_total>0)?
        ((gSB.edge_pass*100.0)/gSB.edge_total):0.0;
    gSB.hidden_percent=(gSB.hidden_total>0)?
        ((gSB.hidden_pass*100.0)/gSB.hidden_total):0.0;

    double T=gSB.pass_threshold;
    if(gSB.basic_percent>=T){
        unlocked_normal=1;
        unlocked_external=1;
    }
    if(gSB.normal_percent>=T){
        unlocked_modes=1;
    }
    if(gSB.modes_percent>=T){
        unlocked_edge=1;
    }
    if(gSB.edge_percent>=T){
        unlocked_hidden=1;
    }
}

/* Read entire file. */
static char* read_file_all(const char* path){
    FILE* f=fopen(path,"rb");
    if(!f) return NULL;
    fseek(f,0,SEEK_END);
    long size=ftell(f);
    if(size<0){fclose(f);return NULL;}
    fseek(f,0,SEEK_SET);
    char* buf=(char*)malloc(size+1);
    if(!buf){fclose(f);return NULL;}
    if(fread(buf,1,size,f)!=(size_t)size){
        fclose(f); free(buf); return NULL;
    }
    buf[size]='\0';
    fclose(f);
    return buf;
}

/* parse JSON-ish integer. */
static int parse_json_int(const char* json,const char* key,int def){
    if(!json||!key) return def;
    char pattern[128];
    snprintf(pattern,sizeof(pattern),"\"%s\"",key);
    char* found=strstr(json,pattern);
    if(!found) return def;
    char* colon=strstr(found,":");
    if(!colon) return def;
    colon++;
    while(*colon && (*colon==' '||*colon=='\t')) colon++;
    int val=def;
    sscanf(colon,"%d",&val);
    return val;
}

/* parse JSON-ish double. */
static double parse_json_double(const char* json,const char* key,double def){
    if(!json||!key) return def;
    char pattern[128];
    snprintf(pattern,sizeof(pattern),"\"%s\"",key);
    char* found=strstr(json,pattern);
    if(!found) return def;
    char* colon=strstr(found,":");
    if(!colon) return def;
    colon++;
    while(*colon && (*colon==' '||*colon=='\t')) colon++;
    double val=def;
    sscanf(colon,"%lf",&val);
    return val;
}

/* Save scoreboard to scoreboard.json. */
static void write_scoreboard_json(const scoreboard_t* sb){
    FILE* f=fopen("scoreboard.json","w");
    if(!f) return;
    fprintf(f,"{\n");
    fprintf(f,"  \"basic_total\": %d,\n",   sb->basic_total);
    fprintf(f,"  \"basic_pass\": %d,\n",    sb->basic_pass);
    fprintf(f,"  \"normal_total\": %d,\n",  sb->normal_total);
    fprintf(f,"  \"normal_pass\": %d,\n",   sb->normal_pass);
    fprintf(f,"  \"external_total\": %d,\n",sb->external_total);
    fprintf(f,"  \"external_pass\": %d,\n", sb->external_pass);
    fprintf(f,"  \"modes_total\": %d,\n",   sb->modes_total);
    fprintf(f,"  \"modes_pass\": %d,\n",    sb->modes_pass);
    fprintf(f,"  \"edge_total\": %d,\n",    sb->edge_total);
    fprintf(f,"  \"edge_pass\": %d,\n",     sb->edge_pass);
    fprintf(f,"  \"hidden_total\": %d,\n",  sb->hidden_total);
    fprintf(f,"  \"hidden_pass\": %d,\n",   sb->hidden_pass);

    fprintf(f,"  \"sc_fifo\": %d,\n",       sb->sc_fifo);
    fprintf(f,"  \"sc_rr\": %d,\n",         sb->sc_rr);
    fprintf(f,"  \"sc_cfs\": %d,\n",        sb->sc_cfs);
    fprintf(f,"  \"sc_cfs_srtf\": %d,\n",   sb->sc_cfs_srtf);
    fprintf(f,"  \"sc_bfs\": %d,\n",        sb->sc_bfs);
    fprintf(f,"  \"sc_sjf\": %d,\n",        sb->sc_sjf);
    fprintf(f,"  \"sc_strf\": %d,\n",       sb->sc_strf);
    fprintf(f,"  \"sc_hrrn\": %d,\n",       sb->sc_hrrn);
    fprintf(f,"  \"sc_hrrn_rt\": %d,\n",    sb->sc_hrrn_rt);
    fprintf(f,"  \"sc_priority\": %d,\n",   sb->sc_priority);
    fprintf(f,"  \"sc_hpc_over\": %d,\n",   sb->sc_hpc_over);
    fprintf(f,"  \"sc_mlfq\": %d,\n",       sb->sc_mlfq);

    fprintf(f,"  \"basic_percent\": %.3f,\n",    sb->basic_percent);
    fprintf(f,"  \"normal_percent\": %.3f,\n",   sb->normal_percent);
    fprintf(f,"  \"external_percent\": %.3f,\n", sb->external_percent);
    fprintf(f,"  \"modes_percent\": %.3f,\n",    sb->modes_percent);
    fprintf(f,"  \"edge_percent\": %.3f,\n",     sb->edge_percent);
    fprintf(f,"  \"hidden_percent\": %.3f,\n",   sb->hidden_percent);

    fprintf(f,"  \"pass_threshold\": %.1f\n",     sb->pass_threshold);
    fprintf(f,"}\n");
    fclose(f);
}

void scoreboard_init(void){ }
void scoreboard_close(void){ }

void scoreboard_load(void){
    char* json=read_file_all("scoreboard.json");
    if(!json){
        update_unlocks();
        return;
    }
    gSB.basic_total    = parse_json_int(json,"basic_total",    gSB.basic_total);
    gSB.basic_pass     = parse_json_int(json,"basic_pass",     gSB.basic_pass);
    gSB.normal_total   = parse_json_int(json,"normal_total",   gSB.normal_total);
    gSB.normal_pass    = parse_json_int(json,"normal_pass",    gSB.normal_pass);
    gSB.external_total = parse_json_int(json,"external_total", gSB.external_total);
    gSB.external_pass  = parse_json_int(json,"external_pass",  gSB.external_pass);
    gSB.modes_total    = parse_json_int(json,"modes_total",    gSB.modes_total);
    gSB.modes_pass     = parse_json_int(json,"modes_pass",     gSB.modes_pass);
    gSB.edge_total     = parse_json_int(json,"edge_total",     gSB.edge_total);
    gSB.edge_pass      = parse_json_int(json,"edge_pass",      gSB.edge_pass);
    gSB.hidden_total   = parse_json_int(json,"hidden_total",   gSB.hidden_total);
    gSB.hidden_pass    = parse_json_int(json,"hidden_pass",    gSB.hidden_pass);

    gSB.sc_fifo        = parse_json_int(json,"sc_fifo",        gSB.sc_fifo);
    gSB.sc_rr          = parse_json_int(json,"sc_rr",          gSB.sc_rr);
    gSB.sc_cfs         = parse_json_int(json,"sc_cfs",         gSB.sc_cfs);
    gSB.sc_cfs_srtf    = parse_json_int(json,"sc_cfs_srtf",    gSB.sc_cfs_srtf);
    gSB.sc_bfs         = parse_json_int(json,"sc_bfs",         gSB.sc_bfs);
    gSB.sc_sjf         = parse_json_int(json,"sc_sjf",         gSB.sc_sjf);
    gSB.sc_strf        = parse_json_int(json,"sc_strf",        gSB.sc_strf);
    gSB.sc_hrrn        = parse_json_int(json,"sc_hrrn",        gSB.sc_hrrn);
    gSB.sc_hrrn_rt     = parse_json_int(json,"sc_hrrn_rt",     gSB.sc_hrrn_rt);
    gSB.sc_priority    = parse_json_int(json,"sc_priority",    gSB.sc_priority);
    gSB.sc_hpc_over    = parse_json_int(json,"sc_hpc_over",    gSB.sc_hpc_over);
    gSB.sc_mlfq        = parse_json_int(json,"sc_mlfq",        gSB.sc_mlfq);

    gSB.basic_percent   = parse_json_double(json,"basic_percent",    gSB.basic_percent);
    gSB.normal_percent  = parse_json_double(json,"normal_percent",   gSB.normal_percent);
    gSB.external_percent= parse_json_double(json,"external_percent", gSB.external_percent);
    gSB.modes_percent   = parse_json_double(json,"modes_percent",    gSB.modes_percent);
    gSB.edge_percent    = parse_json_double(json,"edge_percent",     gSB.edge_percent);
    gSB.hidden_percent  = parse_json_double(json,"hidden_percent",   gSB.hidden_percent);

    gSB.pass_threshold  = parse_json_double(json,"pass_threshold",   gSB.pass_threshold);

    free(json);
    update_unlocks();
}

void scoreboard_save(void){
    update_unlocks();
    write_scoreboard_json(&gSB);
}

/*
  scoreboard_get_final_score():
   Weighted final = sum of the 7 categories:
     1) BASIC => 32%
     2) NORMAL => 20%
     3) EXTERNAL => 10%
     4) MODES => 10%
     5) EDGE => 10%
     6) HIDDEN => 8%
     7) SCHEDULING => 10%  (based on # of sched modes mastered => up to 15 points)
*/

static int get_scheduler_points(void){
    /* BFS=2, HPC=2, MLFQ=2, others=1 => up to 15 total. */
    int points=0;
    if(gSB.sc_fifo)      points+=1;
    if(gSB.sc_rr)        points+=1;
    if(gSB.sc_cfs)       points+=1;
    if(gSB.sc_cfs_srtf)  points+=1;
    if(gSB.sc_bfs)       points+=2;
    if(gSB.sc_sjf)       points+=1;
    if(gSB.sc_strf)      points+=1;
    if(gSB.sc_hrrn)      points+=1;
    if(gSB.sc_hrrn_rt)   points+=1;
    if(gSB.sc_priority)  points+=1;
    if(gSB.sc_hpc_over)  points+=2;
    if(gSB.sc_mlfq)      points+=2;
    return points;
}

int scoreboard_get_final_score(void){
    update_unlocks();
    double b = gSB.basic_percent     * 0.32;
    double n = gSB.normal_percent    * 0.20;
    double e = gSB.external_percent  * 0.10;
    double m = gSB.modes_percent     * 0.10;
    double ed= gSB.edge_percent      * 0.10;
    double h = gSB.hidden_percent    * 0.08;

    int sched_points = get_scheduler_points();
    double sched_percent = (sched_points / 15.0)*100.0;
    double s = sched_percent * 0.10; /* 10% block for scheduling */

    double total = b + n + e + m + ed + h + s;
    if(total>100.0) total=100.0;
    if(total<0.0)   total=0.0;
    return (int)(total + 0.5);
}

void scoreboard_clear(void){
    memset(&gSB, 0, sizeof(gSB));
    gSB.pass_threshold=60.0;
    unlocked_basic=1;
    unlocked_normal=0;
    unlocked_external=0;
    unlocked_modes=0;
    unlocked_edge=0;
    unlocked_hidden=0;
    scoreboard_save();
}

void get_scoreboard(scoreboard_t* out){
    if(out) *out=gSB;
}

/* Mark a scheduling mode as mastered => sets scoreboard bit. */
void scoreboard_set_sc_mastered(scheduler_alg_t alg){
    switch(alg){
    case ALG_FIFO:          gSB.sc_fifo=1;        break;
    case ALG_RR:            gSB.sc_rr=1;          break;
    case ALG_CFS:           gSB.sc_cfs=1;         break;
    case ALG_CFS_SRTF:      gSB.sc_cfs_srtf=1;    break;
    case ALG_BFS:           gSB.sc_bfs=1;         break;
    case ALG_SJF:           gSB.sc_sjf=1;         break;
    case ALG_STRF:          gSB.sc_strf=1;        break;
    case ALG_HRRN:          gSB.sc_hrrn=1;        break;
    case ALG_HRRN_RT:       gSB.sc_hrrn_rt=1;     break;
    case ALG_PRIORITY:      gSB.sc_priority=1;    break;
    case ALG_HPC_OVERSHADOW:gSB.sc_hpc_over=1;    break;
    case ALG_MLFQ:          gSB.sc_mlfq=1;        break;
    default: break;
    }
}

void scoreboard_update_basic(int total,int pass){
    gSB.basic_total += total;
    gSB.basic_pass  += pass;
}
void scoreboard_update_normal(int total,int pass){
    gSB.normal_total += total;
    gSB.normal_pass  += pass;
}
void scoreboard_update_external(int total,int pass){
    gSB.external_total += total;
    gSB.external_pass  += pass;
}
void scoreboard_update_modes(int total,int pass){
    gSB.modes_total += total;
    gSB.modes_pass  += pass;
}
void scoreboard_update_edge(int total,int pass){
    gSB.edge_total += total;
    gSB.edge_pass  += pass;
}
void scoreboard_update_hidden(int total,int pass){
    gSB.hidden_total += total;
    gSB.hidden_pass  += pass;
}
#ifndef SCOREBOARD_H
#define SCOREBOARD_H

#include "scheduler.h"

typedef struct {
    int basic_total,    basic_pass;
    int normal_total,   normal_pass;
    int external_total, external_pass;
    int modes_total,    modes_pass;
    int edge_total,     edge_pass;
    int hidden_total,   hidden_pass;

    int sc_fifo, sc_rr, sc_cfs, sc_cfs_srtf, sc_bfs;
    int sc_sjf, sc_strf, sc_hrrn, sc_hrrn_rt;
    int sc_priority, sc_hpc_over, sc_mlfq;

    double basic_percent;
    double normal_percent;
    double external_percent;
    double modes_percent;
    double edge_percent;
    double hidden_percent;

    double pass_threshold;
} scoreboard_t;

extern int unlocked_basic;
extern int unlocked_normal;
extern int unlocked_external;
extern int unlocked_modes;
extern int unlocked_edge;
extern int unlocked_hidden;

void scoreboard_init(void);
void scoreboard_close(void);
void scoreboard_load(void);
void scoreboard_save(void);
void scoreboard_clear(void);
void get_scoreboard(scoreboard_t* out);
int  scoreboard_get_final_score(void);

void scoreboard_set_sc_mastered(scheduler_alg_t alg);

void scoreboard_update_basic(int total,int pass);
void scoreboard_update_normal(int total,int pass);
void scoreboard_update_external(int total,int pass);
void scoreboard_update_modes(int total,int pass);
void scoreboard_update_edge(int total,int pass);
void scoreboard_update_hidden(int total,int pass);

#endif
#include "worker.h"
#include <stdio.h>
#include <unistd.h>

void simulate_process(process_t* p){
    if(!p) return;
    printf("[Worker] Full run => priority=%d, burst=%lu ms\n",
           p->priority,(unsigned long)p->burst_time);
    usleep(p->burst_time*1000U);
}

void simulate_process_partial(process_t* p, unsigned long slice_ms){
    if(!p || !slice_ms) return;
    printf("[Worker] Partial => priority=%d, slice=%lu ms\n",
           p->priority, slice_ms);
    usleep(slice_ms*1000U);
}
#ifndef WORKER_H
#define WORKER_H

#include "process.h"

void simulate_process(process_t* p);
void simulate_process_partial(process_t* p, unsigned long slice_ms);

#endif
#include "basic-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;

static int almost_equal(double a, double b, double eps){
    return fabs(a - b) < eps;
}

static bool check_stats(const sched_report_t* rep,
                        double exp_wait, double exp_tat,
                        double exp_resp, unsigned long long exp_preempt,
                        double eps)
{
    if(!almost_equal(rep->avg_wait,       exp_wait, eps))   return false;
    if(!almost_equal(rep->avg_turnaround, exp_tat,  eps))   return false;
    if(!almost_equal(rep->avg_response,   exp_resp, eps))   return false;
    if(rep->preemptions != exp_preempt)                     return false;
    return true;
}

/* FIFO test => 2 procs => p0=3, p1=5 => arrival=0 => wait p0=0, p1=3 => etc. */
static bool test_fifo_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 1, 0);
    init_process(&p[1], 5, 1, 0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);

    os_cleanup();
    return check_stats(&rep, 1.5, 5.5, 1.5, 0ULL, 0.001);
}
TEST(test_fifo){
    if(!test_fifo_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "FIFO stats mismatch (expected W=1.5,T=5.5,R=1.5,pre=0)");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_FIFO);
    return true;
}

/* RR => p0=2, p1=2 => quantum=2 => each runs once => preempt=0 => wait=1, tat=3, resp=1. */
static bool test_rr_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 2, 1, 0);
    init_process(&p[1], 2, 1, 0);

    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);

    os_cleanup();
    return check_stats(&rep, 1.0, 3.0, 1.0, 0ULL, 0.001);
}
TEST(test_rr){
    if(!test_rr_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "RR stats mismatch (expected W=1,T=3,R=1,pre=0)");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_RR);
    return true;
}

/* CFS => 2 procs => p0=3, p1=4 => no preempt => wait=1.5, tat=5.0, resp=1.5, preempt=0. */
static bool test_cfs_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 0, 0);
    init_process(&p[1], 4, 0, 0);

    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);

    os_cleanup();
    return check_stats(&rep, 1.5, 5.0, 1.5, 0ULL, 0.001);
}
TEST(test_cfs){
    if(!test_cfs_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "CFS stats mismatch (expected W=1.5,T=5.0,R=1.5,pre=0).");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS);
    return true;
}

/* BFS => 3 procs => partial => check preempt>0 if quantum=2. */
static bool test_bfs_impl(void){
    os_init();
    process_t p[3];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    init_process(&p[2],4,1,0);

    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=3) return false;
    if(rep.preemptions<1)  return false;
    return true;
}
TEST(test_bfs){
    if(!test_bfs_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "BFS stats mismatch => expected preempt>0, procs=3.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_BFS);
    return true;
}

/* HPC overshadow => just call pipeline, distributed => no stats check => pass if no crash. */
static bool test_hpc_pipeline_impl(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}
TEST(test_pipeline){
    if(!test_hpc_pipeline_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "Pipeline test failed unexpectedly.");
        return false;
    }
    return true;
}

/* distributed => pass if no crash. */
static bool test_distributed_impl(void){
    os_init();
    os_run_distributed_example();
    os_cleanup();
    return true;
}
TEST(test_distributed){
    if(!test_distributed_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "Distributed example test failed unexpectedly.");
        return false;
    }
    return true;
}

/* FIFO strict => 2 procs => p0=3, p1=4 => wait=1.5, tat=5.0, resp=1.5, pre=0. */
static bool test_fifo_strict_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],3,10,0);
    init_process(&p[1],4,20,0);
    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    return check_stats(&rep, 1.5, 5.0, 1.5, 0ULL, 0.001);
}
TEST(test_fifo_strict){
    if(!test_fifo_strict_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "FIFO strict test mismatch => W=1.5,T=5.0,R=1.5,pre=0");
        return false;
    }
    return true;
}

void run_basic_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_fifo);
    RUN_TEST(test_rr);
    RUN_TEST(test_cfs);
    RUN_TEST(test_bfs);
    RUN_TEST(test_pipeline);
    RUN_TEST(test_distributed);
    RUN_TEST(test_fifo_strict);

    *total = tests_run;
    *passed= tests_run - tests_failed;
}
/* basic-test.h */
#ifndef BASIC_TEST_H
#define BASIC_TEST_H
void run_basic_tests(int* total,int* passed);
#endif
#include "edge-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;

static bool test_extreme_long_impl(void){
    os_init();
    process_t p[1];
    init_process(&p[0], 50, 2, 0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=1) return false;
    if(rep.preemptions!=0) return false;
    if(fabs(rep.avg_wait - 0.0)>0.001) return false;
    if(fabs(rep.avg_turnaround - 50.0)>0.1) return false;
    if(fabs(rep.avg_response - 0.0)>0.001) return false;
    return true;
}
TEST(test_extreme_long){
    if(!test_extreme_long_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "extreme_long => mismatch => expected wait=0, tat=50, etc.");
        return false;
    }
    return true;
}

static bool test_extreme_short_impl(void){
    os_init();
    process_t p[1];
    init_process(&p[0],1,2,0);

    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=1) return false;
    if(rep.preemptions!=0) return false;
    if(fabs(rep.avg_wait - 0.0)>0.001) return false;
    if(fabs(rep.avg_turnaround -1.0)>0.001) return false;
    return true;
}
TEST(test_extreme_short){
    if(!test_extreme_short_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "extreme_short => mismatch => expected wait=0, tat=1, etc.");
        return false;
    }
    return true;
}

static bool test_high_load_impl(void){
    os_init();
    process_t arr[10];
    for(int i=0;i<10;i++){
        init_process(&arr[i], 3+(i%3), 1, 0);
    }
    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(arr,10);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=10) return false;
    return true;
}
TEST(test_high_load){
    if(!test_high_load_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "high_load => expected 10 procs, mismatch.");
        return false;
    }
    return true;
}

static bool test_hpc_under_load_impl(void){
    os_init();
    os_run_hpc_overshadow();
    os_cleanup();
    return true;
}
TEST(test_hpc_under_load){
    if(!test_hpc_under_load_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "hpc_under_load => unexpected error/crash");
        return false;
    }
    return true;
}

static bool test_container_spam_impl(void){
    os_init();
    for(int i=0;i<3;i++){
        os_create_ephemeral_container();
    }
    for(int i=0;i<3;i++){
        os_remove_ephemeral_container();
    }
    os_cleanup();
    return true;
}
TEST(test_container_spam){
    if(!test_container_spam_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "container spam => unexpected error.");
        return false;
    }
    return true;
}

static bool test_pipeline_edge_impl(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}
TEST(test_pipeline_edge){
    if(!test_pipeline_edge_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "pipeline edge => unexpected error.");
        return false;
    }
    return true;
}

static bool test_multi_distrib_impl(void){
    os_init();
    for(int i=0;i<3;i++){
        os_run_distributed_example();
    }
    os_cleanup();
    return true;
}
TEST(test_multi_distrib){
    if(!test_multi_distrib_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "multi_distrib => unexpected error");
        return false;
    }
    return true;
}

void run_edge_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_extreme_long);
    RUN_TEST(test_extreme_short);
    RUN_TEST(test_high_load);
    RUN_TEST(test_hpc_under_load);
    RUN_TEST(test_container_spam);
    RUN_TEST(test_pipeline_edge);
    RUN_TEST(test_multi_distrib);

    *total=tests_run;
    *passed=tests_run - tests_failed;
}
#ifndef EDGE_TEST_H
#define EDGE_TEST_H

/*
  run_edge_tests():
    Various edge cases: extreme long/short bursts, HPC under load,
    container spam, pipeline edge, multi-distributed runs, etc.
*/
void run_edge_tests(int* total,int* passed);

#endif
#include "external-test.h"
#include "test_common.h"
#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/scoreboard.h"
#include "../src/runner.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

/*
  We maintain counters to track how many tests run and how many fail.
  The 'g_test_fail_reason' is a global string from "test_common.h"
  that can be used to store the reason for a failure.
*/
static int tests_run = 0;
static int tests_failed = 0;

/*-------------------------------------------------------------------
  Test #1: HPC overshadow (external)
    - We run HPC overshadow via scheduler_run() with ALG_HPC_OVERSHADOW
    - Then we check stats => expected to be 0
-------------------------------------------------------------------*/
bool test_external_hpc(void)
{
    os_init();

    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);

    os_cleanup();

    // HPC overshadow => total_procs=0 => pass if so
    if(rep.total_procs!=0) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "external HPC overshadow => expected 0 procs, got %llu",
                 (unsigned long long)rep.total_procs);
        return false;
    }
    return true;
}

/*-------------------------------------------------------------------
  Test #2: BFS (external)
    - We run BFS on 2 short processes => expect at least 1 preemption
-------------------------------------------------------------------*/
bool test_external_bfs(void)
{
    os_init();

    process_t p[2];
    init_process(&p[0], 3, 1, 0);
    init_process(&p[1], 3, 1, 0);

    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);

    os_cleanup();

    // BFS => total_procs=2, preemptions>=1 => pass if so
    if(rep.total_procs!=2 || rep.preemptions<1) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "external BFS => mismatch => expected procs=2, preempt>0 got procs=%llu preempt=%llu",
                 (unsigned long long)rep.total_procs,
                 (unsigned long long)rep.preemptions);
        return false;
    }
    return true;
}

/*-------------------------------------------------------------------
  Test #3: run_shell_concurrency
    - We do a trivial concurrency run: "sleep 2" and "sleep 3"
    - In FIFO mode => concurrency lines are printed
-------------------------------------------------------------------*/
bool test_run_shell_concurrency(void)
{
    int count=2;
    char* lines[2];
    lines[0] = "sleep 2";
    lines[1] = "sleep 3";

    // We'll just call run_shell_commands_concurrently() in FIFO mode
    run_shell_commands_concurrently(count, lines, 1, ALG_FIFO, 0);

    // We'll consider it "pass if no crash."
    return true;
}

/*-------------------------------------------------------------------
  run_external_tests():
    - Gathers all external tests in a single place, calls them in a row.
    - Tally pass/fail, update scoreboard, etc.
-------------------------------------------------------------------*/
void run_external_tests(void)
{
    printf("[External] => Starting external tests.\n");
    tests_run=0;
    tests_failed=0;

    {
        tests_run++;
        bool ok = test_external_hpc();
        if(!ok){
            tests_failed++;
            printf("  FAIL: test_external_hpc => %s\n",
                   g_test_fail_reason[0]? g_test_fail_reason : "???");
        } else {
            printf("  PASS: test_external_hpc\n");
        }
    }

    {
        tests_run++;
        bool ok = test_external_bfs();
        if(!ok){
            tests_failed++;
            printf("  FAIL: test_external_bfs => %s\n",
                   g_test_fail_reason[0]? g_test_fail_reason : "???");
        } else {
            printf("  PASS: test_external_bfs\n");
        }
    }

    {
        tests_run++;
        bool ok = test_run_shell_concurrency();
        if(!ok){
            tests_failed++;
            printf("  FAIL: test_run_shell_concurrency => %s\n",
                   g_test_fail_reason[0]? g_test_fail_reason : "???");
        } else {
            printf("  PASS: test_run_shell_concurrency\n");
        }
    }

    // Summarize
    scoreboard_update_external(tests_run, tests_run - tests_failed);
    scoreboard_save();
    printf("[External] => %d total, %d passed.\n", tests_run, (tests_run - tests_failed));
}
#ifndef EXTERNAL_TEST_H
#define EXTERNAL_TEST_H

#include <stdbool.h>

/*
  Each of these test_* functions is now explicitly declared here,
  so the IDE won't complain about "Cannot resolve symbol."
*/
bool test_external_hpc(void);
bool test_external_bfs(void);
bool test_run_shell_concurrency(void);

/*
  run_external_tests():
    - Calls each external test function (HPC overshadow, BFS, concurrency).
    - Aggregates pass/fail counts, updates scoreboard, etc.
*/
void run_external_tests(void);

#endif
#include "hidden-test.h"
#include "test_common.h"
#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;

static bool test_distrib_heavy_impl(void){
    os_init();
    for(int i=0;i<4;i++){
        os_run_distributed_example();
    }
    os_cleanup();
    /* no scheduling => pass if no crash. */
    return true;
}
TEST(test_distrib_heavy){
    if(!test_distrib_heavy_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "Distrib heavy => unexpected error");
        return false;
    }
    return true;
}

/* HPC overshadow heavy => do HPC overshadow multiple times.
   We'll do ALG_HPC_OVERSHADOW => check stats=0 each time.
*/
static bool test_hpc_heavy_impl(void){
    os_init();
    process_t dummy[1];
    init_process(&dummy[0],0,0,0);

    /* overshadow #1 */
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs!=0) return false;

    /* overshadow #2 */
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    if(r2.total_procs!=0) return false;

    os_cleanup();
    return true;
}
TEST(test_hpc_heavy){
    if(!test_hpc_heavy_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "HPC heavy => overshadow stats mismatch => expected total_procs=0");
        return false;
    }
    return true;
}

/* container combo => then HPC overshadow => pass if no crash. */
static bool test_container_combo_impl(void){
    os_init();
    os_create_ephemeral_container();
    os_run_distributed_example();
    os_run_hpc_overshadow();
    os_remove_ephemeral_container();
    os_cleanup();
    return true;
}
TEST(test_container_combo){
    if(!test_container_combo_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "container combo => unexpected fail.");
        return false;
    }
    return true;
}

/* scheduling variety => run SJF then PRIORITY => compare stats. */
static bool test_scheduling_variety_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,0);
    init_process(&p[1],6,2,0);

    /* SJF */
    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);
    sched_report_t rep1;
    scheduler_fetch_report(&rep1);
    /* we won't do a super strict check => ensure total_procs=2, preempt=0. */
    if(rep1.total_procs!=2) return false;
    if(rep1.preemptions!=0) return false;

    /* Re-init them => run PRIORITY. */
    init_process(&p[0],2,3,0);
    init_process(&p[1],6,1,0);
    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,2);
    sched_report_t rep2;
    scheduler_fetch_report(&rep2);
    /* total_procs=2, preempt=0 => good enough. */
    if(rep2.total_procs!=2) return false;
    if(rep2.preemptions!=0) return false;

    os_cleanup();
    return true;
}
TEST(test_scheduling_variety){
    if(!test_scheduling_variety_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "scheduling variety => mismatch => expecting total=2, preempt=0 in both runs.");
        return false;
    }
    return true;
}

static bool test_auto_logic_impl(void){
    /* placeholder => no real scheduling => just pass. */
    printf("Auto mode selection tested.\n");
    return true;
}
TEST(test_auto_logic){
    if(!test_auto_logic_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "auto_logic => fail ???");
        return false;
    }
    return true;
}

/* final integration => HPC overshadow + container + pipeline + distributed => pass if no crash. */
static bool test_final_integration_impl(void){
    os_init();
    os_log("Final synergy HPC + container + pipeline + distributed");
    os_create_ephemeral_container();
    os_run_hpc_overshadow();
    os_run_distributed_example();
    os_pipeline_example();
    os_remove_ephemeral_container();
    os_cleanup();
    return true;
}
TEST(test_final_integration){
    if(!test_final_integration_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "final integration => unexpected error");
        return false;
    }
    return true;
}

/* multi_stage => distributed + HPC overshadow => pass if overshadow stats=0. */
static bool test_multi_stage_distrib_impl(void){
    os_init();

    /* step1 => distributed => no stats => pass if no crash. */
    os_run_distributed_example();

    /* step2 => HPC overshadow => stats=0. */
    process_t dummy[1];
    init_process(&dummy[0],0,0,0);
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t rep;
    scheduler_fetch_report(&rep);
    if(rep.total_procs!=0) return false;

    /* repeat once more. */
    os_run_distributed_example();
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t rep2;
    scheduler_fetch_report(&rep2);
    if(rep2.total_procs!=0) return false;

    os_cleanup();
    return true;
}
TEST(test_multi_stage_distributed){
    if(!test_multi_stage_distrib_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "multi_stage => HPC overshadow => stats mismatch => expected zero.");
        return false;
    }
    return true;
}

void run_hidden_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_distrib_heavy);
    RUN_TEST(test_hpc_heavy);
    RUN_TEST(test_container_combo);
    RUN_TEST(test_scheduling_variety);
    RUN_TEST(test_auto_logic);
    RUN_TEST(test_final_integration);
    RUN_TEST(test_multi_stage_distributed);

    *total=tests_run;
    *passed=tests_run - tests_failed;
}
#ifndef HIDDEN_TEST_H
#define HIDDEN_TEST_H

/*
  run_hidden_tests():
    Additional hidden or advanced synergy tests.
*/
void run_hidden_tests(int* total,int* passed);

#endif
#include "modes-test.h"
#include "test_common.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;

static int almost_equal(double a, double b, double eps){
    return fabs(a-b)<eps;
}

static bool check_stats(const sched_report_t* r,
                        double w, double t, double rs,
                        unsigned long long p, double eps){
    if(!almost_equal(r->avg_wait, w, eps)) return false;
    if(!almost_equal(r->avg_turnaround, t, eps)) return false;
    if(!almost_equal(r->avg_response, rs, eps)) return false;
    if(r->preemptions!=p) return false;
    return true;
}

/* HPC overshadow => stats=0. */
static bool test_hpc_over_impl(void){
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* HPC overshadow => all zero. */
    if(rep.total_procs!=0) return false;
    if(rep.preemptions!=0) return false;
    if(rep.avg_wait!=0.0) return false;
    if(rep.avg_turnaround!=0.0) return false;
    if(rep.avg_response!=0.0) return false;
    return true;
}
TEST(test_hpc_over){
    if(!test_hpc_over_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "HPC overshadow => expected stats=0, got mismatch");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HPC_OVERSHADOW);
    return true;
}

/* ephemeral containers => not part of scheduling. We'll do 'no crash => pass'. */
static bool test_multi_containers_impl(void){
    os_init();
    for(int i=0;i<2;i++){
        os_create_ephemeral_container();
    }
    for(int i=0;i<2;i++){
        os_remove_ephemeral_container();
    }
    os_cleanup();
    return true;
}
TEST(test_multi_containers){
    if(!test_multi_containers_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "Containers test fail => unexpected error.");
        return false;
    }
    return true;
}

/* multi distributed => not normal scheduling => no stats. We'll do 'no crash => pass'. */
static bool test_multi_distrib_impl(void){
    os_init();
    for(int i=0;i<2;i++){
        os_run_distributed_example();
    }
    os_cleanup();
    return true;
}
TEST(test_multi_distrib){
    if(!test_multi_distrib_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "Multi distributed => unexpected error.");
        return false;
    }
    return true;
}

/* pipeline => no scheduling => 'no crash => pass'. */
static bool test_pipeline_modes_impl(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}
TEST(test_pipeline_modes){
    if(!test_pipeline_modes_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "Pipeline => unexpected error.");
        return false;
    }
    return true;
}

/* mix algos => run FIFO then BFS => just partial checks. */
static bool test_mix_algos_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);

    sched_report_t rep1;
    scheduler_fetch_report(&rep1);
    /* Expect total_procs=2, preempt=0 for FIFO. */
    if(rep1.total_procs!=2 || rep1.preemptions!=0){
        return false;
    }

    /* run BFS with same array => re-init them. */
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,2);

    sched_report_t rep2;
    scheduler_fetch_report(&rep2);
    /* BFS => likely preempt>0 if quantum=2, p1=3 => partial. */
    if(rep2.total_procs!=2) return false;
    if(rep2.preemptions<1)  return false;

    os_cleanup();
    return true;
}
TEST(test_mix_algos){
    if(!test_mix_algos_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "mix_algos => stats mismatch in FIFO or BFS portion.");
        return false;
    }
    return true;
}

/* double HPC overshadow => ensures overshadow stats=0 each time. */
static bool test_double_hpc_impl(void){
    os_init();

    process_t dummy[1];
    init_process(&dummy[0],0,0,0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t rep1;
    scheduler_fetch_report(&rep1);
    if(rep1.total_procs!=0) return false;

    /* do it again */
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t rep2;
    scheduler_fetch_report(&rep2);
    if(rep2.total_procs!=0) return false;

    os_cleanup();
    return true;
}
TEST(test_double_hpc){
    if(!test_double_hpc_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "double HPC overshadow => stats mismatch => expected 0, got something else");
        return false;
    }
    return true;
}

/* MLFQ => partial check => 3 procs => expect some preempt. */
static bool test_mlfq_check_impl(void){
    os_init();
    process_t p[3];
    for(int i=0;i<3;i++){
        init_process(&p[i], 3+i, (i+1)*10, 0);
    }
    scheduler_select_algorithm(ALG_MLFQ);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* Expect total_procs=3, preempt>0. */
    if(rep.total_procs!=3) return false;
    if(rep.preemptions<1)  return false;
    return true;
}
TEST(test_mlfq_check){
    if(!test_mlfq_check_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "MLFQ => expected 3 procs, preempt>0 => mismatch");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_MLFQ);
    return true;
}

void run_modes_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_hpc_over);
    RUN_TEST(test_multi_containers);
    RUN_TEST(test_multi_distrib);
    RUN_TEST(test_pipeline_modes);
    RUN_TEST(test_mix_algos);
    RUN_TEST(test_double_hpc);
    RUN_TEST(test_mlfq_check);

    *total = tests_run;
    *passed = tests_run - tests_failed;
}
#ifndef MODES_TEST_H
#define MODES_TEST_H

/*
  run_modes_tests():
    Tests HPC overshadow, multi containers, BFS, MLFQ, and previous.
*/
void run_modes_tests(int* total,int* passed);

#endif
#include "normal-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;
char g_test_fail_reason[256]={0};

static int almost_equal(double a,double b,double eps){
    return fabs(a-b)<eps;
}
static bool check_stats(const sched_report_t* rep,
                        double w, double t, double r,
                        unsigned long long p, double eps){
    if(!almost_equal(rep->avg_wait,       w, eps)) return false;
    if(!almost_equal(rep->avg_turnaround, t, eps)) return false;
    if(!almost_equal(rep->avg_response,   r, eps)) return false;
    if(rep->preemptions != p)                   return false;
    return true;
}

/* SJF => 3 procs => p0=1, p1=5, p2=2 => all arrive=0 =>
   SJF picks p0(1), then p2(2), then p1(5).
   p0 wait=0,tat=1 => p2 wait=1,tat=3 => p1 wait=3,tat=8 =>
   avg wait= (0+1+3)/3=1.333..., avg tat=(1+3+8)/3=4,
   resp= same as wait =>1.333..., preempt=0
*/
static bool test_sjf_impl(void){
    os_init();
    process_t p[3];
    init_process(&p[0],1,1,0);
    init_process(&p[1],5,1,0);
    init_process(&p[2],2,1,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    return check_stats(&rep, 1.3333, 4.0, 1.3333, 0ULL, 0.01);
}
TEST(test_sjf){
    if(!test_sjf_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "SJF stats mismatch (expected avgW~1.33, T=4, R=1.33, p=0).");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_SJF);
    return true;
}

/* STRF => partial preemption if new short job arrives.
   We'll do a simpler approach => 2 procs => p0=4, p1=3 =>
   They arrive same time => quantum=2 => we expect at least 1 preemption.
   Let's do approximate checks: total_procs=2, preemptions>0
*/
static bool test_strf_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],4,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_STRF);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* We won't do exact numeric. We'll just ensure we got 2 processes, preempt>0. */
    if(rep.total_procs!=2) return false;
    if(rep.preemptions<1)  return false;
    /* Optionally check that avg wait < something. Up to you. */
    return true;
}
TEST(test_strf){
    if(!test_strf_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "STRF stats mismatch => expected total_procs=2, some preemption>0");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_STRF);
    return true;
}

/* HRRN => 3 procs => p0=2, p1=3, p2=4 => all arrive=0 =>
   Typically picks highest ratio => we can do partial numeric checks.
*/
static bool test_hrrn_impl(void){
    os_init();
    process_t p[3];
    for(int i=0; i<3; i++){
        init_process(&p[i], 2+i, 1, 0);
    }
    scheduler_select_algorithm(ALG_HRRN);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* Let's do a rough check => preempt=0 (non-preemptive). total_procs=3. */
    if(rep.total_procs!=3) return false;
    if(rep.preemptions!=0) return false;
    return true;
}
TEST(test_hrrn){
    if(!test_hrrn_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "HRRN mismatch => expected total_procs=3, preempt=0.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN);
    return true;
}

/* HRRN-RT => partial preemption => let's do 2 procs => p0=3, p1=4 =>
   We expect at least 1 preemption if the ratio changes.
*/
static bool test_hrrn_rt_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,0);
    init_process(&p[1],4,2,0);
    scheduler_select_algorithm(ALG_HRRN_RT);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* Just ensure total_procs=2, preemptions>=1. */
    if(rep.total_procs!=2) return false;
    if(rep.preemptions<1)  return false;
    return true;
}
TEST(test_hrrn_rt){
    if(!test_hrrn_rt_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "HRRN-RT mismatch => expected procs=2, preempt>=1.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN_RT);
    return true;
}

/* PRIORITY => 3 procs => p0=burst=2,prio=3, p1=2,prio=1, p2=2,prio=2 =>
   This is non-preemptive priority => we expect run order: p1->p2->p0.
   That yields a certain wait pattern.
*/
static bool test_priority_impl(void){
    os_init();
    process_t p[3];
    init_process(&p[0],2,3,0);
    init_process(&p[1],2,1,0);
    init_process(&p[2],2,2,0);

    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* p1 runs first => wait=0 => tat=2
       p2 runs second => wait=2 => tat=4
       p0 last => wait=4 => tat=6 =>
       avg wait= (0+2+4)/3=2, avg tat= (2+4+6)/3=4, resp=2, preempt=0.
    */
    return check_stats(&rep, 2.0, 4.0, 2.0, 0ULL, 0.001);
}
TEST(test_prio){
    if(!test_priority_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "PRIORITY mismatch => expected W=2, T=4, R=2, pre=0");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_PRIORITY);
    return true;
}

/* CFS-SRTF => 3 procs => let's do partial check => ensure total_procs=3, preempt>0. */
static bool test_cfs_srtf_impl(void){
    os_init();
    process_t p[3];
    for(int i=0;i<3;i++){
        init_process(&p[i], 2+(i*2), 1, 0);
    }
    scheduler_select_algorithm(ALG_CFS_SRTF);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=3) return false;
    if(rep.preemptions<1)  return false;
    return true;
}
TEST(test_cfs_srtf){
    if(!test_cfs_srtf_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "CFS-SRTF => expected procs=3, preempt>0");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS_SRTF);
    return true;
}

/* Strict SJF => 2 procs => p0=2( prio=10 ), p1=5( prio=20 ) =>
   We expect the order p0->p1 =>
   p0 wait=0,tat=2 => p1 wait=2,tat=7 =>
   avg wait=1, tat=4.5 => we'll do approximate.
*/
static bool test_sjf_strict_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],2,10,0);
    init_process(&p[1],5,20,0);
    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* p0 wait=0, tat=2 => p1 wait=2, tat=7 =>
       avgWait=1, avgTAT=4.5, avgResp=1, preempt=0
    */
    return check_stats(&rep, 1.0, 4.5, 1.0, 0ULL, 0.001);
}
TEST(test_sjf_strict){
    if(!test_sjf_strict_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "SJF strict mismatch => expected W=1, T=4.5, R=1, pre=0");
        return false;
    }
    return true;
}

void run_normal_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_sjf);
    RUN_TEST(test_strf);
    RUN_TEST(test_hrrn);
    RUN_TEST(test_hrrn_rt);
    RUN_TEST(test_prio);
    RUN_TEST(test_cfs_srtf);
    RUN_TEST(test_sjf_strict);

    *total = tests_run;
    *passed= tests_run - tests_failed;
}
#ifndef NORMAL_TEST_H
#define NORMAL_TEST_H

/*
  run_normal_tests():
    Runs the "normal" test suite: SJF, STRF, HRRN, HRRN-RT,
    PRIORITY, CFS-SRTF, etc.
*/
void run_normal_tests(int* total,int* passed);

#endif
#include "test_common.h"
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <errno.h>

/* global reason for test failure */

/*
  read_all():
    Reads from fd until EOF, storing in buf up to cap-1 bytes.
    Null-terminates.
*/
static ssize_t read_all(int fd, char* buf, size_t cap){
    size_t used=0;
    while(used + 1 < cap){
        ssize_t r=read(fd, buf + used, cap - 1 - used);
        if(r<0 && errno==EINTR){
            continue;
        }
        if(r<=0){
            break;
        }
        used+=(size_t)r;
    }
    buf[used] = '\0';
    return (ssize_t)used;
}

/*
  run_function_capture_output():
    1) Create pipes for stdout & stderr.
    2) Fork => child => redirect to pipes => run test function.
    3) Parent => read from pipes => store in out->stdout_buf/stderr_buf.
    4) Wait for child => return exit status code.
*/
int run_function_capture_output(void(*fn)(void), struct captured_output* out){
    if(!fn || !out){
        return -1;
    }
    int p_out[2], p_err[2];
    if(pipe(p_out)==-1 || pipe(p_err)==-1){
        return -1;
    }
    int save_out=dup(STDOUT_FILENO);
    int save_err=dup(STDERR_FILENO);
    if(save_out<0||save_err<0){
        return -1;
    }

    pid_t c=fork();
    if(c<0){
        return -1; // fork fail
    }
    if(c==0){
        // child
        close(p_out[0]);
        close(p_err[0]);
        dup2(p_out[1],STDOUT_FILENO);
        dup2(p_err[1],STDERR_FILENO);
        close(p_out[1]);
        close(p_err[1]);

        fn(); // run test function in child
        _exit(0);
    }

    // parent
    close(p_out[1]);
    close(p_err[1]);
    read_all(p_out[0], out->stdout_buf, sizeof(out->stdout_buf));
    read_all(p_err[0], out->stderr_buf, sizeof(out->stderr_buf));
    close(p_out[0]);
    close(p_err[0]);

    dup2(save_out, STDOUT_FILENO);
    dup2(save_err, STDERR_FILENO);
    close(save_out);
    close(save_err);

    int st=0;
    waitpid(c,&st,0);
    return st;
}
#ifndef TEST_COMMON_H
#define TEST_COMMON_H

#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "../src/safe_calls_library.h"

/*
  A global buffer for test failure reason.
*/
extern char g_test_fail_reason[256];

/*
  Structure to hold stdout/stderr from a forked child test run.
*/
struct captured_output {
  char stdout_buf[8192];
  char stderr_buf[8192];
};

/*
  Runs the given function 'fn' in a child process,
  capturing the child's stdout/stderr into 'out'.
  Returns the child's exit code.
*/
int run_function_capture_output(void(*fn)(void), struct captured_output* out);

/*
  TEST macro => define a test function that returns bool.
  RUN_TEST => run that function, track pass/fail, print result.
*/
#define TEST(name) static bool test_##name(void)
#define RUN_TEST(name) do { \
bool ok=test_##name(); \
tests_run++; \
if(!ok){ \
tests_failed++; \
printf("  FAIL: %s => %s\n",#name, \
g_test_fail_reason[0]?g_test_fail_reason:"???"); \
} else { \
printf("  PASS: %s\n", #name); \
} \
} while(0)

#endif
