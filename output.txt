#include "scheduler.h"
#include "ready_queue.h"
#include "worker.h"
#include "../lib/log.h"
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>

/* =========== (A) ephemeral remove code =========== */
#ifdef EPHEMERAL_RM_RECURSIVE
static int remove_directory_recursive(const char* path){
    DIR* dir = opendir(path);
    if(!dir) return rmdir(path);
    struct dirent* entry;
    int ret=0;
    while((entry = readdir(dir))){
        if(strcmp(entry->d_name,".")==0 || strcmp(entry->d_name,"..")==0){
            continue;
        }
        char buf[512];
        snprintf(buf,sizeof(buf),"%s/%s", path, entry->d_name);
        struct stat st;
        if(stat(buf,&st)==0){
            if(S_ISDIR(st.st_mode)){
                ret=remove_directory_recursive(buf);
                if(ret!=0) break;
            } else {
                ret=unlink(buf);
                if(ret!=0) break;
            }
        }
    }
    closedir(dir);
    if(ret==0) ret=rmdir(path);
    return ret;
}
#endif

static char* ephemeral_create_container(void){
    char tmpl[] = "/tmp/container_XXXXXX";
    char* p = (char*)malloc(256);
    if(!p){
        log_error("ephemeral_create_container mem fail");
        return NULL;
    }
    strcpy(p, tmpl);
    if(!mkdtemp(p)){
        log_error("mkdtemp fail %s => %s", p, strerror(errno));
        free(p);
        return NULL;
    }
    /* Make ephemeral container logs purple: */
    log_info("\033[35mephemeral created => %s\033[0m", p);
    return p;
}

static void ephemeral_remove_container(const char* path){
    if(!path) return;
#ifdef EPHEMERAL_RM_RECURSIVE
    int r = remove_directory_recursive(path);
#else
    int r = rmdir(path);
#endif
    if(r==0){
        log_info("\033[35mephemeral removed => %s\033[0m", path);
    } else {
        log_warn("ephemeral remove fail => %s : %s", path, strerror(errno));
    }
}

/* =========== (B) timeline printing =========== */
static int compare_timeline(const void* a, const void* b){
    const timeline_item_t* A = (const timeline_item_t*)a;
    const timeline_item_t* B = (const timeline_item_t*)b;
    if(A->core_id < B->core_id) return -1;
    if(A->core_id > B->core_id) return 1;
    if(A->start_ms < B->start_ms) return -1;
    if(A->start_ms > B->start_ms) return 1;
    return 0;
}

static void print_container_timeline(const container_t* c){
    if(c->timeline_count == 0){
        printf("\n\033[1m\033[33mNo timeline for container.\033[0m\n");
        return;
    }
    qsort(c->timeline, c->timeline_count, sizeof(c->timeline[0]), compare_timeline);

    printf("\033[1m\033[36m\n--- Container Timeline ---\n\033[0m");
    int current_core=9999999;
    for(int i=0; i<c->timeline_count; i++){
        int cid = c->timeline[i].core_id;
        if(cid != current_core){
            if(cid >= 0){
                printf("\033[1m\033[32m\nMain Core %d:\n\033[0m", cid);
            } else {
                int hpc_idx = (-1 - cid);
                printf("\033[1m\033[35m\nHPC Thread %d:\n\033[0m", hpc_idx);
            }
            current_core=cid;
        }
        unsigned long st=c->timeline[i].start_ms;
        unsigned long ln=c->timeline[i].length_ms;
        bool pre=c->timeline[i].preempted_slice;
        if(pre){
            printf("  T[%lu..%lu] => P%d \033[1m\033[33m[PREEMPT]\033[0m\n",
                   st, st+ln, c->timeline[i].proc_id);
        } else {
            printf("  T[%lu..%lu] => P%d\n", st, st+ln, c->timeline[i].proc_id);
        }
    }
}

/* =========== (C) container_run =========== */
static void* container_thread_runner(void* arg){
    container_t* c=(container_t*)arg;
    if(!c){
        log_error("container_run => null container pointer?");
        return NULL;
    }

    c->ephemeral_path = ephemeral_create_container();
    if(!c->ephemeral_path){
        log_error("container_run => ephemeral creation failed => ignoring");
    }

    /* HPC procs offset 1000. */
    for(int i=0; i<c->main_count; i++){
        c->main_procs[i].id = i;
    }
    for(int i=0; i<c->hpc_count; i++){
        c->hpc_procs[i].id = 1000 + i;
    }

    /* Build local RQs. */
    ready_queue_t main_q, hpc_q;
    rq_init(&main_q, c->main_alg);
    rq_init(&hpc_q, c->hpc_alg);

    /* Push immediate arrivals. */
    for(int i=0; i<c->main_count; i++){
        process_t* p=&c->main_procs[i];
        if(p->remaining_time>0 && p->arrival_time==0){
            rq_push(&main_q, p);
        }
    }
    for(int i=0; i<c->hpc_count; i++){
        process_t* p=&c->hpc_procs[i];
        if(p->remaining_time>0 && p->arrival_time==0){
            rq_push(&hpc_q, p);
        }
    }

    /* Create main threads. */
    pthread_t* main_threads = calloc(c->nb_cores, sizeof(pthread_t));
    if(!main_threads){
        log_error("container_run => no memory for main_threads");
        return NULL;
    }
    for(int i=0; i<c->nb_cores; i++){
        core_thread_pack_t* pack = malloc(sizeof(core_thread_pack_t));
        pack->container = c;
        pack->qs.main_rq = &main_q;
        pack->qs.hpc_rq  = &hpc_q;
        pack->core_id = i;
        pthread_create(&main_threads[i], NULL, main_core_thread, pack);
    }

    /* HPC threads. */
    pthread_t* hpc_threads = NULL;
    if(c->nb_hpc_threads > 0){
        hpc_threads = calloc(c->nb_hpc_threads, sizeof(pthread_t));
        if(!hpc_threads){
            log_error("container_run => no memory for hpc_threads");
        } else {
            for(int i=0; i<c->nb_hpc_threads; i++){
                core_thread_pack_t* pack = malloc(sizeof(core_thread_pack_t));
                pack->container = c;
                pack->qs.main_rq = &main_q;
                pack->qs.hpc_rq  = &hpc_q;
                pack->core_id = i;
                pthread_create(&hpc_threads[i], NULL, hpc_thread, pack);
            }
        }
    }

    /* Join main cores. */
    for(int i=0; i<c->nb_cores; i++){
        pthread_join(main_threads[i], NULL);
    }
    free(main_threads);

    /* Join HPC threads. */
    if(c->nb_hpc_threads>0 && hpc_threads){
        for(int i=0; i<c->nb_hpc_threads; i++){
            pthread_join(hpc_threads[i], NULL);
        }
        free(hpc_threads);
    }

    rq_destroy(&main_q);
    rq_destroy(&hpc_q);

    /* ephemeral remove */
    if(c->ephemeral_path){
        ephemeral_remove_container(c->ephemeral_path);
        free(c->ephemeral_path);
        c->ephemeral_path=NULL;
    }

    print_container_timeline(c);

    if(c->timeline){
        free(c->timeline);
        c->timeline = NULL;
    }
    pthread_mutex_destroy(&c->timeline_lock);
    pthread_mutex_destroy(&c->finish_lock);

    return NULL;
}

void container_init(container_t* c,
                    int nb_cores,
                    int nb_hpc_threads,
                    scheduler_alg_t main_alg,
                    scheduler_alg_t hpc_alg,
                    process_t* main_list,
                    int main_count,
                    process_t* hpc_list,
                    int hpc_count,
                    unsigned long max_cpu_ms)
{
    if(!c){
        log_error("container_init => null container pointer");
        return;
    }
    memset(c,0,sizeof(*c));

    if(nb_cores<0) nb_cores=0;
    if(nb_hpc_threads<0) nb_hpc_threads=0;
    if(max_cpu_ms==0){
        log_warn("container_init => forcing max_cpu_ms=100");
        max_cpu_ms=100;
    }

    c->nb_cores       = nb_cores;
    c->nb_hpc_threads = nb_hpc_threads;
    c->main_alg       = main_alg;
    c->hpc_alg        = hpc_alg;
    c->main_procs     = main_list;
    c->main_count     = main_count;
    c->hpc_procs      = hpc_list;
    c->hpc_count      = hpc_count;
    c->max_cpu_time_ms= max_cpu_ms;
    c->remaining_count= main_count + hpc_count;

    pthread_mutex_init(&c->finish_lock,NULL);
    pthread_mutex_init(&c->timeline_lock,NULL);

    c->timeline       = NULL;
    c->timeline_count = 0;
    c->timeline_cap   = 0;
    c->time_exhausted = false;
    c->accumulated_cpu= 0;
    c->sim_time       = 0;

    /* HPC steal if 0 main cores but have main processes. */
    if(nb_cores == 0 && main_count>0){
        log_info("container_init => no main cores but main processes => enabling HPC steal");
        c->allow_hpc_steal = true;
    }
}

void container_run(container_t* c){
    container_thread_runner((void*)c);
}

void orchestrator_run(container_t* arr, int count){
    pthread_t* tids = calloc(count, sizeof(pthread_t));
    if(!tids){
        log_error("orchestrator_run => cannot allocate");
        return;
    }
    for(int i=0; i<count; i++){
        pthread_create(&tids[i], NULL, container_thread_runner, &arr[i]);
    }
    for(int i=0; i<count; i++){
        pthread_join(tids[i], NULL);
    }
    free(tids);
}
#ifndef CONTAINER_H
#define CONTAINER_H

#include <pthread.h>
#include <stdbool.h>
#include "../lib/scheduler_alg.h"
#include "process.h"

/**
 * Timeline event struct
 */
typedef struct timeline_item_s {
    int           core_id;    /* HPC ID if negative */
    int           proc_id;
    unsigned long start_ms;
    unsigned long length_ms;
    bool          preempted_slice;
} timeline_item_t;

/**
 * @brief The container struct for processes + HPC threads + scheduling info.
 */
typedef struct container_s {
    int              nb_cores;
    int              nb_hpc_threads;
    scheduler_alg_t  main_alg;
    scheduler_alg_t  hpc_alg;

    process_t*       main_procs;
    int              main_count;
    process_t*       hpc_procs;
    int              hpc_count;

    unsigned long    max_cpu_time_ms;
    unsigned long    accumulated_cpu;
    unsigned long    sim_time;
    bool             time_exhausted;
    int              remaining_count;

    pthread_mutex_t  finish_lock;
    pthread_mutex_t  timeline_lock;

    timeline_item_t* timeline;
    int   timeline_count;
    int   timeline_cap;

    char* ephemeral_path;
    bool  allow_hpc_steal;
} container_t;

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Initialize a container. HPC steal is automatically enabled if nb_cores=0 but main_count>0.
 */
void container_init(container_t* c,
                    int nb_cores,
                    int nb_hpc_threads,
                    scheduler_alg_t main_alg,
                    scheduler_alg_t hpc_alg,
                    process_t* main_list,
                    int main_count,
                    process_t* hpc_list,
                    int hpc_count,
                    unsigned long max_cpu_ms);

/**
 * @brief Run this container in the current thread. (Blocks until completion.)
 */
void container_run(container_t* c);

/**
 * @brief Orchestrator that runs multiple containers in parallel.
 */
void orchestrator_run(container_t* arr, int count);

#ifdef __cplusplus
}
#endif

#endif // CONTAINER_H
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include "../lib/scoreboard.h"
#include "../test/basic-tests.h"
#include "../lib/library.h"
#include "../lib/log.h"

extern void set_slow_mode(int onOff);
extern int  is_slow_mode(void);
extern void set_bonus_test(int onOff);
extern int  is_bonus_test(void);

static void do_run_tests(void){
    set_log_level(LOG_LEVEL_INFO);
    run_all_tests();    /* This calls your test your work */
    show_scoreboard();  /* Display after running. */
    scoreboard_save();
    fflush(stdout);
    fflush(stderr);
}

static void show_scoreboard_submenu(void) {
    while(1) {
        printf("\n\033[1m\033[36m=== SCOREBOARD MENU ===\033[0m\n");
        printf("1) Show scoreboard legend\n");
        printf("2) Return to main menu\n");
        printf("Choice? ");
        fflush(stdout);
        char choice[64];
        if(!fgets(choice, sizeof(choice), stdin)) break;
        switch(choice[0]) {
        case '1':
            show_legend();
            break;
        case '2':
            return;
        default:
            printf("\033[33mUnknown option.\033[0m\n");
            break;
        }
    }
}

static void show_main_menu(void){
    fflush(stdout);
    fflush(stderr);
    if(is_slow_mode())
    {
        printf("\033[36mSlow motion activated\033[0m");
    } else
    {
        printf("\033[36mFast motion activated\033[0m");
    }
    printf("\n\033[1m\033[35m=== MAIN MENU ===\033[0m\n");
    printf("1) Run all tests\n");
    printf("2) Scoreboard\n");
    printf("3) Clear scoreboard\n");
    printf("4) Enable slow concurrency\n");
    printf("5) Disable slow concurrency\n");
    printf("6) Enable/Disable bonus test\n");
    printf("7) Exit\n");
    printf("Choice? ");
}

int main(void){
    signal(SIGINT, handle_signal);
    signal(SIGTERM, handle_signal);
    // HPC Bonus is initially ON for demonstration
    set_log_level(LOG_LEVEL_INFO);
    scoreboard_load();
    scoreboard_set_sc_hpc(1);
    set_slow_mode(0);    // default concurrency mode: fast
    set_bonus_test(0);   // default: bonus test OFF

    while(1){
        if (fflush(stdout) == 0 && fflush(stderr) == 0) {
            usleep(10000);
            show_main_menu();
        }
        char choice[64];
        if(!fgets(choice, sizeof(choice), stdin)){
            break;
        }
        switch(choice[0]){
        case '1':
            do_run_tests();
            break;
        case '2':
            show_scoreboard();
            show_scoreboard_submenu();
            break;
        case '3':
            scoreboard_clear();
            printf("\033[31mScoreboard cleared.\033[00m\n");
            break;
        case '4':
            set_slow_mode(1);
            printf("\033[36mSlow concurrency enabled.\033[0m\n");
            break;
        case '5':
            set_slow_mode(0);
            printf("\033[36mSlow concurrency disabled.\033[00m\n");
            break;
        case '6':
            if (is_bonus_test()) {
                set_bonus_test(0);
                printf("\033[35mBonus test disabled.\033[0m\n");
            } else {
                set_bonus_test(1);
                printf("\033[35mBonus test enabled.\033[0m\n");
            }
            break;
        case '7':
        case 'q':
        case 'Q':
            printf("Exiting...\n");
            return scoreboard_get_final_score();
        default:
            printf("\033[33mUnknown option.\033[0m\n");
            break;
        }
    }
    return -1;
}
#include "process.h"
#include "../lib/log.h"

void init_process(process_t* p, unsigned long burst, int prio, unsigned long arrival, double weight){
    if(!p){
        log_error("init_process => Null pointer for process_t");
        return;
    }
    if(burst == 0){
        log_warn("init_process => burst=0 => completes instantly");
    }
    if(prio < 0){
        log_warn("init_process => negative priority => continuing");
    }
    if(weight <= 0.0){
        log_warn("init_process => nonpositive weight => forcing weight=1.0");
        weight = 1.0;
    }

    p->id             = 0;
    p->burst_time     = burst;
    p->priority       = prio;
    p->arrival_time   = arrival;
    p->remaining_time = burst;
    p->first_response = 0;
    p->end_time       = 0;
    p->responded      = false;
    p->weight         = weight;
    p->hpc_affinity   = -1;
    p->mlfq_level     = 0;
    p->was_preempted  = false;
}
#ifndef PROCESS_H
#define PROCESS_H

#include <stdbool.h>

/**
 * @brief Represents a single process entity for scheduling.
 */
typedef struct {
    int           id;             /**< Unique ID (for debugging/timeline) */
    unsigned long burst_time;     /**< Original burst (execution) time */
    int           priority;       /**< Used by priority-based schedulers */
    unsigned long arrival_time;   /**< Arrival time for process */
    unsigned long remaining_time; /**< Remaining execution time */
    unsigned long first_response; /**< Timestamp of first scheduling response */
    unsigned long end_time;       /**< Timestamp when process completed */
    bool          responded;      /**< True if process has responded at least once */

    double        weight;         /**< Weight for Weighted Fair Queueing */

    int           hpc_affinity;   /**< HPC thread index if relevant */

    int           mlfq_level;     /**< MLFQ queue level for demonstration */

    bool          was_preempted;  /**< If forcibly preempted */
} process_t;

/**
 * @brief Initialize a single process struct.
 */
void init_process(process_t* p, unsigned long burst, int prio, unsigned long arrival, double weight);

#endif
#include "ready_queue.h"
#include "../lib/log.h"
#include <stdlib.h>
#include <string.h>

/* ------------------------------------------------------
   Internal comparator for sorted insertion
   ------------------------------------------------------ */
typedef int (*proc_cmp_fn)(const process_t* A, const process_t* B);

static int prio_asc_cmp(const process_t* A, const process_t* B){
    return (A->priority - B->priority);
}
static int burst_asc_cmp(const process_t* A, const process_t* B){
    if(A->burst_time < B->burst_time) return -1;
    if(A->burst_time > B->burst_time) return 1;
    return 0;
}

/* Simple ascending sort insertion if cmp != NULL,
   or tail insertion (FIFO) if cmp == NULL. */
static void rq_insert_sorted(ready_queue_t* rq, process_t* p, proc_cmp_fn cmp){
    rq_node_t* n = (rq_node_t*)malloc(sizeof(rq_node_t));
    n->proc = p;
    n->next = NULL;

    if(!rq->head){
        rq->head = n;
        return;
    }
    if(!cmp){
        /* Insert at tail => FIFO. */
        rq_node_t* c = rq->head;
        while(c->next) c = c->next;
        c->next = n;
        return;
    }
    /* Else ascending sorted insertion. */
    rq_node_t* c  = rq->head;
    rq_node_t* px = NULL;
    while(c){
        if(cmp(p, c->proc) < 0){
            if(px){
                px->next = n;
            } else {
                rq->head = n;
            }
            n->next = c;
            return;
        }
        px = c;
        c = c->next;
    }
    px->next = n;
}

void rq_init(ready_queue_t* rq, scheduler_alg_t alg){
    memset(rq, 0, sizeof(*rq));
    pthread_mutex_init(&rq->lock, NULL);
    pthread_cond_init(&rq->cond, NULL);
    rq->alg = alg;
    rq->wfq_virtual_time = 0.0;
}

void rq_destroy(ready_queue_t* rq){
    if(!rq) return;
    rq_node_t* c = rq->head;
    while(c){
        rq_node_t* nxt = c->next;
        free(c);
        c = nxt;
    }
    pthread_mutex_destroy(&rq->lock);
    pthread_cond_destroy(&rq->cond);
    memset(rq, 0, sizeof(*rq));
}

void rq_push(ready_queue_t* rq, process_t* p){
    pthread_mutex_lock(&rq->lock);

    if(!p){
        /* termination marker => push front always. */
        rq_node_t* n = (rq_node_t*)malloc(sizeof(rq_node_t));
        n->proc = NULL;
        n->next = rq->head;
        rq->head = n;
        rq->size++;
        pthread_cond_broadcast(&rq->cond);
        pthread_mutex_unlock(&rq->lock);
        return;
    }

    switch(rq->alg){
    case ALG_PRIORITY:
        /* Non-preemptive priority => ascending prio. */
        rq_insert_sorted(rq, p, prio_asc_cmp);
        break;
    case ALG_PRIO_PREEMPT:
        /* Preemptive => also ascending prio. */
        rq_insert_sorted(rq, p, prio_asc_cmp);
        break;
    case ALG_SJF:
        /* Insert by burst ascending. */
        rq_insert_sorted(rq, p, burst_asc_cmp);
        break;
    case ALG_HPC:
        /* HPC example => push front. */
    {
        rq_node_t* n = (rq_node_t*)malloc(sizeof(rq_node_t));
        n->proc = p;
        n->next = rq->head;
        rq->head = n;
        break;
    }
    default:
        /* default => FIFO for RR, BFS, MLFQ, WFQ, etc. */
        rq_insert_sorted(rq, p, NULL);
        break;
    }

    rq->size++;
    pthread_cond_broadcast(&rq->cond);
    pthread_mutex_unlock(&rq->lock);
}

process_t* rq_pop(ready_queue_t* rq, bool* got_term){
    *got_term = false;
    pthread_mutex_lock(&rq->lock);

    /* Wait until something is in the queue. */
    while(rq->size == 0){
        pthread_cond_wait(&rq->cond, &rq->lock);
    }

    /* Weighted Fair Queueing special pop => earliest finish time. */
    if(rq->alg == ALG_WFQ){
        rq_node_t* prev = NULL;
        rq_node_t* best_prev = NULL;
        rq_node_t* best_node = NULL;
        double best_val = 1e15;

        rq_node_t* cur = rq->head;
        while(cur){
            if(!cur->proc){
                /* termination marker => pick that immediately. */
                best_node = cur;
                break;
            }
            double finish_time = rq->wfq_virtual_time
                              + ((double)cur->proc->remaining_time / cur->proc->weight);
            if(finish_time < best_val){
                best_val = finish_time;
                best_node = cur;
                best_prev = prev;
            }
            prev = cur;
            cur = cur->next;
        }
        if(!best_node){
            pthread_mutex_unlock(&rq->lock);
            return NULL;
        }
        if(!best_node->proc){
            *got_term = true;
            /* Remove best_node from list. */
            if(best_node == rq->head){
                rq->head = best_node->next;
            } else if(best_prev){
                best_prev->next = best_node->next;
            }
            free(best_node);
            rq->size--;
            pthread_mutex_unlock(&rq->lock);
            return NULL;
        }
        process_t* ret = best_node->proc;
        if(best_node == rq->head){
            rq->head = best_node->next;
        } else if(best_prev){
            best_prev->next = best_node->next;
        }
        free(best_node);
        rq->size--;

        rq->wfq_virtual_time += ((double)ret->remaining_time / ret->weight);

        pthread_mutex_unlock(&rq->lock);
        return ret;
    }
    else {
        /* Non-WFQ => pop head. */
        rq_node_t* h = rq->head;
        rq->head = h->next;
        rq->size--;

        process_t* ret = h->proc;
        if(!ret){
            *got_term = true;
        }
        free(h);
        pthread_mutex_unlock(&rq->lock);
        return ret;
    }
}

bool try_preempt_if_needed(ready_queue_t* rq, process_t* p){
    if(rq->alg != ALG_PRIO_PREEMPT || !p) return false;

    pthread_mutex_lock(&rq->lock);
    if(!rq->head || !rq->head->proc){
        pthread_mutex_unlock(&rq->lock);
        return false;
    }
    process_t* front = rq->head->proc;
    if(front->priority < p->priority){
        /* Preempt => put p back, pop the new highest prio. */
        p->was_preempted = true;
        /* Insert p into the queue sorted by priority. */
        rq_insert_sorted(rq, p, prio_asc_cmp);
        rq->size++;
        pthread_mutex_unlock(&rq->lock);
        return true;
    }
    pthread_mutex_unlock(&rq->lock);
    return false;
}
#ifndef READY_QUEUE_H
#define READY_QUEUE_H

#include <stdbool.h>
#include <pthread.h>
#include "scheduler.h"
#include "process.h"

/* A singly-linked node. */
typedef struct rq_node_s {
    process_t*        proc;
    struct rq_node_s* next;
} rq_node_t;

/* The main "ready queue" structure. */
typedef struct {
    rq_node_t*       head;
    int              size;
    pthread_mutex_t  lock;
    pthread_cond_t   cond;
    scheduler_alg_t  alg;

    double           wfq_virtual_time; /* For Weighted Fair Queueing. */
} ready_queue_t;

/**
 * @brief Initialize a ready queue with a given algorithm.
 */
void rq_init(ready_queue_t* rq, scheduler_alg_t alg);

/**
 * @brief Destroy the queue (frees any leftover nodes).
 */
void rq_destroy(ready_queue_t* rq);

/**
 * @brief Push a process. (If `p == NULL`, we treat that as termination marker.)
 */
void rq_push(ready_queue_t* rq, process_t* p);

/**
 * @brief Pop the next process. If we pop the termination marker, sets *got_term=true.
 */
process_t* rq_pop(ready_queue_t* rq, bool* got_term);

/**
 * @brief Try to see if we need to preempt the current running process
 *        if a higher-priority one arrives in the queue (for ALG_PRIO_PREEMPT).
 *
 * @return true if a preemption occurred and we reinserted the old process.
 */
bool try_preempt_if_needed(ready_queue_t* rq, process_t* p);

#endif // READY_QUEUE_H
#include "scheduler.h"
#include "../lib/log.h"
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>

unsigned long get_quantum(scheduler_alg_t alg, const process_t* p){
    if(!p) return 0;
    switch(alg){
    case ALG_RR:           return 2;
    case ALG_BFS:          return 4;
    case ALG_WFQ:          return 3;
    case ALG_MLFQ:         return (2 + p->mlfq_level * 2);
    case ALG_PRIO_PREEMPT: return 2;
    case ALG_FIFO:
    case ALG_SJF:
    case ALG_PRIORITY:
    case ALG_HPC:
    case ALG_NONE:
    default:
        return 2;
    }
}

void record_timeline(container_t* c, int core_id, int proc_id,
                     unsigned long start_ms, unsigned long slice, bool preempted_flag)
{
    pthread_mutex_lock(&c->timeline_lock);
    if(c->timeline_count + 1 >= c->timeline_cap){
        int new_cap = c->timeline_cap + 64;
        void* tmp = realloc(c->timeline, new_cap * sizeof(*c->timeline));
        if(!tmp){
            log_error("record_timeline => out of memory!");
            pthread_mutex_unlock(&c->timeline_lock);
            return;
        }
        c->timeline = tmp;
        c->timeline_cap = new_cap;
    }
    c->timeline[c->timeline_count].core_id         = core_id;
    c->timeline[c->timeline_count].proc_id         = proc_id;
    c->timeline[c->timeline_count].start_ms        = start_ms;
    c->timeline[c->timeline_count].length_ms       = slice;
    c->timeline[c->timeline_count].preempted_slice = preempted_flag;
    c->timeline_count++;
    pthread_mutex_unlock(&c->timeline_lock);
}
#ifndef SCHEDULER_H
#define SCHEDULER_H
#include <stdbool.h>
#include "../lib/scheduler_alg.h"
#include "process.h"
#include "container.h"

/* Forward-declare container_t for function prototypes: */
struct container_s;
typedef struct container_s container_t;

/**
 * @brief Return the timeslice “quantum” for a given algorithm + process.
 */
unsigned long get_quantum(scheduler_alg_t alg, const process_t* p);

/**
 * @brief Perform actual CPU-bound "work" for `ms` milliseconds,
 *        with optional slow-mode vs. fast-mode behavior.
 */
void do_cpu_work(unsigned long ms, int core_id, int proc_id);

/**
 * @brief Record a timeline event into the container's timeline array.
 */
void record_timeline(container_t* c,
                     int core_id,
                     int proc_id,
                     unsigned long start_ms,
                     unsigned long slice,
                     bool preempted_flag);

/**
 * @brief Enable or disable slow mode concurrency.
 *        HPC shell is only used if found in ../../libExtern/ ;
 *        otherwise HPC-based tests that rely on it will fail gracefully.
 */
void set_slow_mode(int onOff);

#endif // SCHEDULER_H
#include "worker.h"

/* Forward helpers */
static bool is_time_exhausted(container_t* c){
    pthread_mutex_lock(&c->finish_lock);
    bool r = c->time_exhausted || (c->accumulated_cpu >= c->max_cpu_time_ms);
    pthread_mutex_unlock(&c->finish_lock);
    return r;
}

/**
 * @brief Stop everything by pushing termination markers.
 */
static void force_stop(container_t* c, ready_queue_t* rq_main, ready_queue_t* rq_hpc){
    for(int i=0; i<c->nb_cores; i++){
        rq_push(rq_main, NULL);
    }
    for(int i=0; i<c->nb_hpc_threads; i++){
        rq_push(rq_hpc, NULL);
    }
}

static void check_main_arrivals(container_t* c, ready_queue_t* rq){
    pthread_mutex_lock(&c->finish_lock);
    unsigned long now = c->sim_time;
    pthread_mutex_unlock(&c->finish_lock);

    for(int i=0; i<c->main_count; i++){
        process_t* p = &c->main_procs[i];
        if(p->remaining_time>0 && p->arrival_time>0 && p->arrival_time <= now){
            fprintf(stderr, "\033[94m[MAIN ARRIVE] P%d arrives at t=%lu => push mainRQ\033[0m\n",
                    p->id, now);
            rq_push(rq, p);
            p->arrival_time = 0;
        }
    }
}

static void check_hpc_arrivals(container_t* c, ready_queue_t* rq){
    pthread_mutex_lock(&c->finish_lock);
    unsigned long now = c->sim_time;
    pthread_mutex_unlock(&c->finish_lock);

    for(int i=0; i<c->hpc_count; i++){
        process_t* p = &c->hpc_procs[i];
        if(p->remaining_time>0 && p->arrival_time>0 && p->arrival_time <= now){
            fprintf(stderr, "\033[95m[HPC ARRIVE]  P%d arrives at t=%lu => push hpcRQ\033[0m\n",
                    p->id, now);
            rq_push(rq, p);
            p->arrival_time = 0;
        }
    }
}

/**
 * @brief Perform one CPU slice for a given process `p` on core `core_id`.
 */
static void run_slice(container_t* c, ready_queue_t* main_rq, ready_queue_t* hpc_rq,
                      process_t* p, scheduler_alg_t alg,
                      int core_id, unsigned long* used_ms)
{
    *used_ms = 0;
    if(!p || p->remaining_time == 0) return;

    unsigned long quantum = get_quantum(alg, p);

    pthread_mutex_lock(&c->finish_lock);
    unsigned long start_ms = c->sim_time;
    if(!p->responded){
        p->responded = true;
        p->first_response = start_ms;
    }
    pthread_mutex_unlock(&c->finish_lock);

    bool preempted_flag = false;
    unsigned long slice_used = 0;
    unsigned long slice_remaining = quantum;

    while(slice_remaining > 0 && !c->time_exhausted && p->remaining_time > 0){
        unsigned long step = (slice_remaining < p->remaining_time)
                           ? slice_remaining
                           : p->remaining_time;

        /* Actual CPU simulation step: */
        do_cpu_work(step, core_id, p->id);

        pthread_mutex_lock(&c->finish_lock);

        p->remaining_time -= step;
        c->accumulated_cpu += step;
        c->sim_time        += step;

        slice_used       += step;
        slice_remaining  -= step;

        if(p->remaining_time == 0){
            p->end_time = p->first_response + p->burst_time;
            c->remaining_count--;
            if(c->remaining_count <= 0){
                c->time_exhausted = true;
            }
        }
        if(c->accumulated_cpu >= c->max_cpu_time_ms){
            c->time_exhausted = true;
        }
        pthread_mutex_unlock(&c->finish_lock);

        /* Preemptive check for PRIO_PREEMPT: */
        if(alg == ALG_PRIO_PREEMPT){
            bool got_preempted = try_preempt_if_needed(main_rq, p);
            if(got_preempted){
                preempted_flag = true;
                break;
            }
        }

        if(c->time_exhausted){
            break;
        }
    }

    /* MLFQ => demote if used the entire quantum but not finished. */
    if(alg == ALG_MLFQ && p->remaining_time > 0 && slice_used == quantum){
        p->mlfq_level++;
    }

    *used_ms = slice_used;
    record_timeline(c, core_id, p->id, start_ms, slice_used, preempted_flag);

    if(preempted_flag){
        fprintf(stderr, "\033[33m[CORE %d] PREEMPTED process P%d after %lu ms!\033[0m\n",
                core_id, p->id, slice_used);
    }
}

void* main_core_thread(void* arg){
    core_thread_pack_t* pack = (core_thread_pack_t*)arg;
    container_t* c         = pack->container;
    ready_queue_t* main_rq = pack->qs.main_rq;
    ready_queue_t* hpc_rq  = pack->qs.hpc_rq;
    int core_id            = pack->core_id;
    free(pack);

    while(!is_time_exhausted(c)){
        bool term_marker = false;
        process_t* p = rq_pop(main_rq, &term_marker);
        if(term_marker || !p){
            fprintf(stderr, "\033[32m[CORE %d] Termination marker => exiting.\033[0m\n", core_id);
            break;
        }
        fprintf(stderr, "\033[32m[CORE %d] Popped P%d (remaining=%lu)\033[0m\n",
                core_id, p->id, p->remaining_time);

        unsigned long used=0;
        run_slice(c, main_rq, hpc_rq, p, c->main_alg, core_id, &used);

        if(!is_time_exhausted(c) && p->remaining_time>0){
            fprintf(stderr, "\033[32m[CORE %d] Re-queue P%d (remaining=%lu)\033[0m\n",
                    core_id, p->id, p->remaining_time);
            rq_push(main_rq, p);
        }

        /* Check arrivals after the slice: */
        check_main_arrivals(c, main_rq);
        check_hpc_arrivals(c, hpc_rq);

        if(is_time_exhausted(c)){
            force_stop(c, main_rq, hpc_rq);
            break;
        }
    }
    return NULL;
}

void* hpc_thread(void* arg){
    core_thread_pack_t* pack = (core_thread_pack_t*)arg;
    container_t* c         = pack->container;
    ready_queue_t* main_rq = pack->qs.main_rq;
    ready_queue_t* hpc_rq  = pack->qs.hpc_rq;
    int hpc_idx            = pack->core_id;
    int timeline_id        = -1 - hpc_idx;
    free(pack);

    while(!is_time_exhausted(c)){
        /* 1) Check arrivals: */
        check_hpc_arrivals(c, hpc_rq);
        check_main_arrivals(c, main_rq);

        /* 2) HPC steal if HPC queue empty and allow_hpc_steal. */
        pthread_mutex_lock(&hpc_rq->lock);
        int hpc_size = hpc_rq->size;
        pthread_mutex_unlock(&hpc_rq->lock);

        if(hpc_size == 0 && c->allow_hpc_steal){
            bool dummy = false;
            process_t* stolen = rq_pop(main_rq, &dummy);
            if(stolen && !dummy){
                fprintf(stderr, "\033[35m[HPC %d] Steal from main => P%d\033[0m\n",
                        hpc_idx, stolen->id);

                unsigned long used=0;
                /* HPC BFS uses HPC scheduling, not main's. */
                run_slice(c, main_rq, hpc_rq, stolen, c->hpc_alg, timeline_id, &used);

                if(!is_time_exhausted(c) && stolen->remaining_time>0){
                    fprintf(stderr, "\033[35m[HPC %d] Done slice => re-push P%d to MAIN\033[0m\n",
                            hpc_idx, stolen->id);
                    rq_push(main_rq, stolen);
                }
            }
        }

        /* Re-check HPC queue: */
        pthread_mutex_lock(&hpc_rq->lock);
        hpc_size = hpc_rq->size;
        pthread_mutex_unlock(&hpc_rq->lock);

        /* 3) If HPC queue still empty => idle 1ms (faster idle to avoid timeouts). */
        if(hpc_size == 0){
            if(is_time_exhausted(c)) break;
            pthread_mutex_lock(&c->finish_lock);
            c->sim_time += 1;
            c->accumulated_cpu += 1;
            if(c->accumulated_cpu >= c->max_cpu_time_ms){
                c->time_exhausted = true;
            }
            pthread_mutex_unlock(&c->finish_lock);

            /* Sleep a small amount of real time to keep HPC BFS from timing out. */
            usleep(1000);  // 1ms real-time idle
            continue;
        }

        /* 4) Pop HPC queue: */
        bool term_marker=false;
        process_t* p = rq_pop(hpc_rq, &term_marker);
        if(term_marker || !p){
            fprintf(stderr, "\033[35m[HPC %d] Termination marker => exiting.\033[0m\n", hpc_idx);
            break;
        }
        fprintf(stderr, "\033[35m[HPC %d] HPC pop => P%d (remaining=%lu)\033[0m\n",
                hpc_idx, p->id, p->remaining_time);

        unsigned long used=0;
        run_slice(c, main_rq, hpc_rq, p, c->hpc_alg, timeline_id, &used);

        if(!is_time_exhausted(c) && p->remaining_time>0){
            fprintf(stderr, "\033[35m[HPC %d] Re-queue HPC P%d (remaining=%lu)\033[0m\n",
                    hpc_idx, p->id, p->remaining_time);
            rq_push(hpc_rq, p);
        }

        if(is_time_exhausted(c)){
            force_stop(c, main_rq, hpc_rq);
            break;
        }
    }
    return NULL;
}


/* Tracks slow-mode on/off globally. */
// This variable controls slow vs. fast sleep logic:
static int g_slowMode = 0;
static int g_bonusTest = 0;
void set_slow_mode(const int onOff) {
    // Just record the local preference, no shell calls:
    g_slowMode = (onOff != 0);
}
void set_bonus_test(const int onOff) {
    // *** ADDED FOR BONUS TEST ***
    g_bonusTest = (onOff != 0);
}
int is_slow_mode(void) {
    return g_slowMode;
}
int is_bonus_test(void) {
    // *** ADDED FOR BONUS TEST ***
    return g_bonusTest;
}

/**
 * @brief Simulates CPU work by sleeping. In fast mode, small microsecond sleeps.
 *        In slow mode, large sleeps. In bonus-test mode, we demonstrate concurrency
 *        via an external shell call or a longer time-based approach.
 */
void do_cpu_work(unsigned long ms, int core_id, int proc_id)
{
    if (!is_slow_mode() && !is_bonus_test()) {
        // FAST mode => microsecond-level sleeps
        log_info("do_cpu_work(FAST): %lu ms => usleep(%lu * 1000)", ms, ms);
        usleep((useconds_t)(ms * 1000U));
        return;
    }

    if (is_slow_mode() && !is_bonus_test()) {
        // SLOW mode => 2 seconds per simulated ms (increase from 1 to 2 to avoid timeouts)
        for (unsigned long i = 0; i < ms; i++) {
            log_info("do_cpu_work(SLOW): sleeping 2s for ms=%lu (core=%d, proc=%d)",
                     i, core_id, proc_id);
            sleep(2);
        }
        return;
    }

    if (is_bonus_test()) {
        /*
         * BONUS TEST mode:
         * Example approach: call an external shell that runs “timeout 10 sleep <ms>”
         * or run repeated “sleep 1” calls to mimic concurrency checks in
         * shell-tp1-implementation. The snippet below does a single big sleep with
         * an overall timeout. Adjust as desired to match your concurrency tests.
         */
        char cmd[256];
        // Example: for a 10-second limit, request “sleep <ms>”.
        // If ms is large, it will be cut short by ‘timeout 10’.
        snprintf(cmd, sizeof(cmd),
                 "echo \"timeout 10 sleep %lu\" | ../../libExtern/shell-tp1-implementation",
                 ms);

        log_info("[BONUS] do_cpu_work => %s", cmd);
        int ret = system(cmd);
        if (ret != 0) {
            log_warn("[BONUS] shell command returned non-zero (%d), might have timed out or failed", ret);
        }
        return;
    }
}
#ifndef WORKER_H
#define WORKER_H

#include "container.h"
#include "ready_queue.h"
#include <stdlib.h>
#include "scheduler.h"
#include "ready_queue.h"
#include "../lib/log.h"
#include <stdio.h>
#include <unistd.h>
#include <stdbool.h>

/**
 * @brief A small struct to pass to each core/hpc thread.
 */
typedef struct {
    container_t* container;
    struct {
        ready_queue_t* main_rq;
        ready_queue_t* hpc_rq;
    } qs;
    int core_id;
} core_thread_pack_t;

/**
 * @brief The function each "main core" thread runs.
 */
void* main_core_thread(void* arg);

/**
 * @brief The function each "HPC" thread runs.
 */
void* hpc_thread(void* arg);
int is_bonus_test(void);
void set_bonus_test(int onOff);
#endif // WORKER_H
#include "library.h"
#include "scoreboard.h"
#include "log.h"
#include <stdlib.h>
#include <signal.h>

static volatile sig_atomic_t g_skip_remaining_tests = 0;

int skip_remaining_tests_requested(void) {
    return (g_skip_remaining_tests != 0);
}

void set_skip_remaining_tests(const int val) {
    g_skip_remaining_tests = (val ? 1 : 0);
}

static volatile sig_atomic_t g_look_remaining_tests = 0;

int look_remaining_tests_requested(void) {
    return (g_look_remaining_tests != 0);
}

void set_look_remaining_tests(const int val) {
    g_look_remaining_tests = (val ? 1 : 0);
}

void handle_signal(const int signum){
    scoreboard_save();
    fflush(stdout);
    fflush(stderr);
    if(signum == SIGINT) {
        /* SIGINT => exit immediately, but save scoreboard + stats. */
        log_warn("Caught Signal to exit => exiting");
        exit(scoreboard_get_final_score());
    }

    if(signum == SIGTERM) {
        if (look_remaining_tests_requested())
        {
            set_skip_remaining_tests(1); // volatile value make an action possible
            log_warn("Caught signal to stop next concurrency");
        } else
        {
            log_warn("Caught Signal to exit => exiting");
            exit(scoreboard_get_final_score());
        }

    }
}

// Usage : if (skip_remaining_tests_requested) do#ifndef LIBRARY_H
#define LIBRARY_H
int skip_remaining_tests_requested(void);
void set_skip_remaining_tests(const int val);
void set_look_remaining_tests(const int val);
void handle_signal(int signum);
#endif //LIBRARY_H
#include "log.h"

static log_level_t g_log_level = LOG_LEVEL_INFO;

static void vlogf(log_level_t lvl, const char* prefix, const char* fmt, va_list ap){
    if(lvl < g_log_level) return;
    fprintf(stderr, "%s", prefix);
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, CLR_RESET "\n");
}

void set_log_level(log_level_t lvl){
    g_log_level = lvl;
}

void log_debug(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_DEBUG, CLR_BLUE "[DEBUG] " CLR_RESET, fmt, ap);
    va_end(ap);
}

void log_info(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_INFO, CLR_GREEN "[INFO]  " CLR_RESET, fmt, ap);
    va_end(ap);
    fflush(stdout);
    fflush(stderr);
}

void log_warn(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_WARN, CLR_YELLOW "[WARN]  " CLR_RESET, fmt, ap);
    va_end(ap);
}

void log_error(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_ERROR, CLR_RED "[ERROR] " CLR_RESET, fmt, ap);
    va_end(ap);
}
#ifndef LOG_H
#define LOG_H

#include <stdio.h>
#include <stdarg.h>

/* ======== ANSI COLORS ======== */
#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_RED     "\033[31m"
#define CLR_GREEN   "\033[32m"
#define CLR_YELLOW  "\033[33m"
#define CLR_BLUE    "\033[34m"
#define CLR_MAGENTA "\033[35m"
#define CLR_CYAN    "\033[36m"

/* You can extend with e.g. #define CLR_PURPLE or reuse CLR_MAGENTA as desired */

typedef enum {
    LOG_LEVEL_DEBUG=0,
    LOG_LEVEL_INFO,
    LOG_LEVEL_WARN,
    LOG_LEVEL_ERROR
} log_level_t;

void set_log_level(log_level_t lvl);

void log_debug(const char* fmt, ...);
void log_info(const char* fmt, ...);
void log_warn(const char* fmt, ...);
void log_error(const char* fmt, ...);

#endif
#ifndef SCHEDULER_ALG_H
#define SCHEDULER_ALG_H

/*
   Standalone definition of the scheduling algorithm enum
   to avoid circular includes between container.h and scheduler.h
*/
typedef enum {
    ALG_NONE=-1,
    ALG_FIFO=0,
    ALG_RR,
    ALG_SJF,
    ALG_PRIORITY,
    ALG_BFS,
    ALG_MLFQ,
    ALG_HPC,
    ALG_WFQ,
    ALG_PRIO_PREEMPT
} scheduler_alg_t;

#endif // SCHEDULER_ALG_H
#include "scoreboard.h"
#include "../libExtern/cJSON.h"
#include "log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static scoreboard_t gSB;

static double calc_percent(int total, int pass){
    if(total <= 0) return 0.0;
    return 100.0 * ((double)pass / (double)total);
}

static void recompute(void){
    gSB.basic_percent        = calc_percent(gSB.basic_total,      gSB.basic_pass);
    gSB.normal_percent       = calc_percent(gSB.normal_total,     gSB.normal_pass);
    gSB.edge_percent         = calc_percent(gSB.edge_total,       gSB.edge_pass);
    gSB.hidden_percent       = calc_percent(gSB.hidden_total,     gSB.hidden_pass);
    gSB.wfq_percent          = calc_percent(gSB.wfq_total,        gSB.wfq_pass);
    gSB.multi_hpc_percent    = calc_percent(gSB.multi_hpc_total,  gSB.multi_hpc_pass);
    gSB.bfs_percent          = calc_percent(gSB.bfs_total,        gSB.bfs_pass);
    gSB.mlfq_percent         = calc_percent(gSB.mlfq_total,       gSB.mlfq_pass);
    gSB.prio_preempt_percent = calc_percent(gSB.prio_preempt_total,gSB.prio_preempt_pass);
    gSB.hpc_bfs_percent      = calc_percent(gSB.hpc_bfs_total,    gSB.hpc_bfs_pass);
}

int scoreboard_get_final_score(void){
    recompute();
    // Each suite => up to 10%, HPC bonus => +10 if sc_hpc=1, capped at 100.
    double b  = gSB.basic_percent        * 0.10;
    double n  = gSB.normal_percent       * 0.10;
    double e  = gSB.edge_percent         * 0.10;
    double hi = gSB.hidden_percent       * 0.10;
    double wf = gSB.wfq_percent          * 0.10;
    double mh = gSB.multi_hpc_percent    * 0.10;
    double bf = gSB.bfs_percent          * 0.10;
    double ml = gSB.mlfq_percent         * 0.10;
    double pp = gSB.prio_preempt_percent * 0.10;
    double hb = gSB.hpc_bfs_percent      * 0.10;
    double HPC = (gSB.sc_hpc ? 10.0 : 0.0);

    double total = b + n + e + hi + wf + mh + bf + ml + pp + hb + HPC;
    if(total > 100.0) total = 100.0;
    return (int)(total + 0.5);
}

static void scoreboard_defaults(void){
    memset(&gSB, 0, sizeof(gSB));
    gSB.pass_threshold = 60.0; // Some default threshold
}

void scoreboard_load(void){
    scoreboard_defaults();
    FILE* f = fopen("scoreboard.json", "rb");
    if(!f){
        log_warn("No scoreboard.json => defaults");
        return;
    }
    fseek(f, 0, SEEK_END);
    long sz = ftell(f);
    if(sz < 0){
        fclose(f);
        return;
    }
    fseek(f, 0, SEEK_SET);
    char* buf = (char*)malloc(sz+1);
    if(!buf){
        fclose(f);
        return;
    }
    if(fread(buf,1,sz,f) != (size_t)sz){
        free(buf);
        fclose(f);
        return;
    }
    buf[sz] = '\0';
    fclose(f);

    cJSON* root = cJSON_Parse(buf);
    free(buf);
    if(!root){
        log_warn("scoreboard parse fail => defaults");
        return;
    }

    #define JGETINT(o,n,v) do{ cJSON*_t=cJSON_GetObjectItemCaseSensitive(o,n); \
        if(_t&&cJSON_IsNumber(_t)) (v)=_t->valueint;}while(0)
    #define JGETDBL(o,n,v) do{ cJSON*_t=cJSON_GetObjectItemCaseSensitive(o,n); \
        if(_t&&cJSON_IsNumber(_t)) (v)=_t->valuedouble;}while(0)

    JGETINT(root,"basic_total",        gSB.basic_total);
    JGETINT(root,"basic_pass",         gSB.basic_pass);
    JGETINT(root,"normal_total",       gSB.normal_total);
    JGETINT(root,"normal_pass",        gSB.normal_pass);
    JGETINT(root,"edge_total",         gSB.edge_total);
    JGETINT(root,"edge_pass",          gSB.edge_pass);
    JGETINT(root,"hidden_total",       gSB.hidden_total);
    JGETINT(root,"hidden_pass",        gSB.hidden_pass);
    JGETINT(root,"wfq_total",          gSB.wfq_total);
    JGETINT(root,"wfq_pass",           gSB.wfq_pass);
    JGETINT(root,"multi_hpc_total",    gSB.multi_hpc_total);
    JGETINT(root,"multi_hpc_pass",     gSB.multi_hpc_pass);
    JGETINT(root,"bfs_total",          gSB.bfs_total);
    JGETINT(root,"bfs_pass",           gSB.bfs_pass);
    JGETINT(root,"mlfq_total",         gSB.mlfq_total);
    JGETINT(root,"mlfq_pass",          gSB.mlfq_pass);
    JGETINT(root,"prio_preempt_total", gSB.prio_preempt_total);
    JGETINT(root,"prio_preempt_pass",  gSB.prio_preempt_pass);
    JGETINT(root,"hpc_bfs_total",      gSB.hpc_bfs_total);
    JGETINT(root,"hpc_bfs_pass",       gSB.hpc_bfs_pass);

    JGETINT(root,"sc_hpc",            gSB.sc_hpc);
    JGETDBL(root,"pass_threshold",    gSB.pass_threshold);

    cJSON_Delete(root);
    log_info("Scoreboard loaded");
}

void scoreboard_save(void){
    cJSON* root = cJSON_CreateObject();
    #define JADDINT(o,n,v) cJSON_AddNumberToObject(o,n,(double)(v))
    #define JADDDBL(o,n,v) cJSON_AddNumberToObject(o,n,(v))

    JADDINT(root,"basic_total",        gSB.basic_total);
    JADDINT(root,"basic_pass",         gSB.basic_pass);
    JADDINT(root,"normal_total",       gSB.normal_total);
    JADDINT(root,"normal_pass",        gSB.normal_pass);
    JADDINT(root,"edge_total",         gSB.edge_total);
    JADDINT(root,"edge_pass",          gSB.edge_pass);
    JADDINT(root,"hidden_total",       gSB.hidden_total);
    JADDINT(root,"hidden_pass",        gSB.hidden_pass);
    JADDINT(root,"wfq_total",          gSB.wfq_total);
    JADDINT(root,"wfq_pass",           gSB.wfq_pass);
    JADDINT(root,"multi_hpc_total",    gSB.multi_hpc_total);
    JADDINT(root,"multi_hpc_pass",     gSB.multi_hpc_pass);
    JADDINT(root,"bfs_total",          gSB.bfs_total);
    JADDINT(root,"bfs_pass",           gSB.bfs_pass);
    JADDINT(root,"mlfq_total",         gSB.mlfq_total);
    JADDINT(root,"mlfq_pass",          gSB.mlfq_pass);
    JADDINT(root,"prio_preempt_total", gSB.prio_preempt_total);
    JADDINT(root,"prio_preempt_pass",  gSB.prio_preempt_pass);
    JADDINT(root,"hpc_bfs_total",      gSB.hpc_bfs_total);
    JADDINT(root,"hpc_bfs_pass",       gSB.hpc_bfs_pass);

    JADDINT(root,"sc_hpc",             gSB.sc_hpc);
    JADDDBL(root,"pass_threshold",     gSB.pass_threshold);

    char* out = cJSON_Print(root);
    cJSON_Delete(root);

    FILE* f = fopen("scoreboard.json","wb");
    if(!f){
        log_error("Cannot write scoreboard.json");
        free(out);
        return;
    }
    fwrite(out,1,strlen(out),f);
    fclose(f);
    free(out);
    printf("\n");
    log_info("Scoreboard saved");
}

void scoreboard_clear(void){
    scoreboard_defaults();
    scoreboard_save();
}

/* Updaters: */
void scoreboard_update_basic(int t,int p){ gSB.basic_total=t; gSB.basic_pass=p; }
void scoreboard_update_normal(int t,int p){ gSB.normal_total=t; gSB.normal_pass=p; }
void scoreboard_update_edge(int t,int p){ gSB.edge_total=t; gSB.edge_pass=p; }
void scoreboard_update_hidden(int t,int p){ gSB.hidden_total=t; gSB.hidden_pass=p; }
void scoreboard_update_wfq(int t,int p){ gSB.wfq_total=t; gSB.wfq_pass=p; }
void scoreboard_update_multi_hpc(int t,int p){ gSB.multi_hpc_total=t; gSB.multi_hpc_pass=p; }
void scoreboard_update_bfs(int t,int p){ gSB.bfs_total=t; gSB.bfs_pass=p; }
void scoreboard_update_mlfq(int t,int p){ gSB.mlfq_total=t; gSB.mlfq_pass=p; }
void scoreboard_update_prio_preempt(int t,int p){ gSB.prio_preempt_total=t; gSB.prio_preempt_pass=p; }
void scoreboard_update_hpc_bfs(int t,int p){ gSB.hpc_bfs_total=t; gSB.hpc_bfs_pass=p; }

void scoreboard_set_sc_hpc(int v){
    gSB.sc_hpc = (v ? 1 : 0);
}

/* Check if a suite is "unlocked" by meeting pass_threshold in the previous suite. */
int scoreboard_is_unlocked(scoreboard_suite_t s){
    recompute();
    double T = gSB.pass_threshold;
    switch(s){
    case SUITE_BASIC:       return 1;
    case SUITE_NORMAL:      return (gSB.basic_percent >= T);
    case SUITE_EDGE:        return (gSB.normal_percent >= T);
    case SUITE_HIDDEN:      return (gSB.edge_percent >= T);
    case SUITE_WFQ:         return (gSB.hidden_percent >= T);
    case SUITE_MULTI_HPC:   return (gSB.wfq_percent   >= T);
    case SUITE_BFS:         return (gSB.normal_percent>= T);
    case SUITE_MLFQ:        return (gSB.normal_percent>= T);
    case SUITE_PRIO_PREEMPT:return (gSB.edge_percent  >= T);
    case SUITE_HPC_BFS:     return (gSB.hidden_percent>= T);
    default: return 0;
    }
}

void get_scoreboard(scoreboard_t* out){
    if(out) *out = gSB;
}

/* For printing with color-coded lines. */
static void print_suite_line(const char* name, int pass, int total, double percent) {
    if(total == 0) {
        printf("\033[33m%-12s => %d/%d => %.1f%% (no tests?)\033[0m\n",
               name, pass, total, percent);
        return;
    }
    if(pass == total) {
        printf("\033[32m%-12s => %d/%d => %.1f%%\033[0m\n", name, pass, total, percent);
    } else if(pass == 0) {
        printf("\033[31m%-12s => %d/%d => %.1f%%\033[0m\n", name, pass, total, percent);
    } else {
        printf("\033[33m%-12s => %d/%d => %.1f%%\033[0m\n", name, pass, total, percent);
    }
}

void show_scoreboard(void){
    scoreboard_t sb;
    get_scoreboard(&sb);
    int final = scoreboard_get_final_score();

    printf("\n\033[1m\033[36m===== SCOREBOARD =====\033[0m\n");
    print_suite_line("BASIC",        sb.basic_pass, sb.basic_total, sb.basic_percent);
    print_suite_line("NORMAL",       sb.normal_pass, sb.normal_total, sb.normal_percent);
    print_suite_line("EDGE",         sb.edge_pass,   sb.edge_total,   sb.edge_percent);
    print_suite_line("HIDDEN",       sb.hidden_pass, sb.hidden_total, sb.hidden_percent);
    print_suite_line("WFQ",          sb.wfq_pass,    sb.wfq_total,    sb.wfq_percent);
    print_suite_line("MULTI_HPC",    sb.multi_hpc_pass, sb.multi_hpc_total, sb.multi_hpc_percent);
    print_suite_line("BFS",          sb.bfs_pass,    sb.bfs_total,    sb.bfs_percent);
    print_suite_line("MLFQ",         sb.mlfq_pass,   sb.mlfq_total,   sb.mlfq_percent);
    print_suite_line("PRIO_PREEMPT", sb.prio_preempt_pass, sb.prio_preempt_total, sb.prio_preempt_percent);
    print_suite_line("HPC_BFS",      sb.hpc_bfs_pass, sb.hpc_bfs_total, sb.hpc_bfs_percent);

    printf("HPC Bonus => %s\n", (sb.sc_hpc ? "YES" : "NO"));
    printf("Final Weighted Score => %d\n", final);
    printf("=======================\n\n");
}

void show_legend(void){
    /* Provide bullet list and explicit mention of each suite & HPC bonus. */
    printf("\n\033[1m\033[35m--- Scoreboard Legend / Weights ---\033[0m\n");
    printf(" • Each suite contributes up to 10%% towards the final score.\n");
    printf(" • HPC Bonus adds an extra 10%% if HPC is enabled, capped at 100%%.\n");
    printf(" • The suites tested are:\n");
    printf("    - BASIC\n");
    printf("    - NORMAL\n");
    printf("    - EDGE\n");
    printf("    - HIDDEN\n");
    printf("    - WFQ\n");
    printf("    - MULTI_HPC\n");
    printf("    - BFS\n");
    printf("    - MLFQ\n");
    printf("    - PRIO_PREEMPT\n");
    printf("    - HPC_BFS\n");
    printf("------------------------------------\n");
}
#ifndef SCOREBOARD_H
#define SCOREBOARD_H

typedef enum {
    SUITE_BASIC=1,
    SUITE_NORMAL,
    SUITE_EDGE,
    SUITE_HIDDEN,
    SUITE_WFQ,
    SUITE_MULTI_HPC,
    SUITE_BFS,
    SUITE_MLFQ,
    SUITE_PRIO_PREEMPT,
    SUITE_HPC_BFS
} scoreboard_suite_t;

typedef struct {
    int basic_total,      basic_pass;
    int normal_total,     normal_pass;
    int edge_total,       edge_pass;
    int hidden_total,     hidden_pass;
    int wfq_total,        wfq_pass;
    int multi_hpc_total,  multi_hpc_pass;
    int bfs_total,        bfs_pass;
    int mlfq_total,       mlfq_pass;
    int prio_preempt_total, prio_preempt_pass;
    int hpc_bfs_total,      hpc_bfs_pass;

    double basic_percent,
           normal_percent,
           edge_percent,
           hidden_percent,
           wfq_percent,
           multi_hpc_percent,
           bfs_percent,
           mlfq_percent,
           prio_preempt_percent,
           hpc_bfs_percent;

    double pass_threshold;
    int    sc_hpc;
} scoreboard_t;

/* Load/save scoreboard from JSON. */
void scoreboard_load(void);
void scoreboard_save(void);
void scoreboard_clear(void);

/* Update suite test counts. */
void scoreboard_update_basic(int t,int p);
void scoreboard_update_normal(int t,int p);
void scoreboard_update_edge(int t,int p);
void scoreboard_update_hidden(int t,int p);
void scoreboard_update_wfq(int t,int p);
void scoreboard_update_multi_hpc(int t,int p);
void scoreboard_update_bfs(int t,int p);
void scoreboard_update_mlfq(int t,int p);
void scoreboard_update_prio_preempt(int t,int p);
void scoreboard_update_hpc_bfs(int t,int p);

/* HPC bonus on/off. */
void scoreboard_set_sc_hpc(int v);

/* Gate-unlocking logic. */
int  scoreboard_is_unlocked(scoreboard_suite_t s);

/* Retrieval + final scoring. */
void get_scoreboard(scoreboard_t* out);
int  scoreboard_get_final_score(void);

/* Display. */
void show_scoreboard(void);
void show_legend(void);

#endif
