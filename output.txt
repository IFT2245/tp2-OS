#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "main.h"
#include "runner.h"
#include "os.h"
#include "safe_calls_library.h"
#include "scoreboard.h"
#include "stats.h"

/* Test suite headers. */
#include "../test/basic-test.h"
#include "../test/normal-test.h"
#include "../test/modes-test.h"
#include "../test/edge-test.h"
#include "../test/hidden-test.h"

/* We use this to track whether SIGTERM was received so we can stop concurrency
   or test suites, but remain in the main menu. */
static volatile sig_atomic_t g_return_to_menu = 0;

/* ---------------------------------------------------------
   Implementation of functions declared in main.h
   --------------------------------------------------------- */

void clear_screen(void) {
#if defined(_WIN32) || defined(_WIN64)
    system("cls");
#else
    system("clear");
#endif
}

void pause_enter(void) {
    printf("\nPress ENTER to continue...");
    fflush(stdout);
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        /* discard */
    }
}

int read_line(char *buf, size_t sz) {
    if (!fgets(buf, sz, stdin)) return 0;
    buf[strcspn(buf, "\n")] = '\0';
    return 1;
}

void ascii_main_menu_header(void) {
    printf(CLR_BOLD CLR_YELLOW "┌────────────────────────────────────────────┐\n" CLR_RESET);
    printf(CLR_BOLD CLR_YELLOW "│            OS-SCHEDULING GAME            │\n" CLR_RESET);
    printf(CLR_BOLD CLR_YELLOW "└────────────────────────────────────────────┘\n" CLR_RESET);
    printf("     'A concurrency and scheduling trainer'  \n\n");
}

/* Show scoreboard in an ASCII table, with an additional row describing schedule mastery weighting. */
void menu_show_scoreboard(void) {
    scoreboard_t sb;
    get_scoreboard(&sb);

    /* For test unlocking checks: */
    int unlockedB      = scoreboard_is_unlocked(SUITE_BASIC);
    int unlockedN      = scoreboard_is_unlocked(SUITE_NORMAL);
    int unlockedExt    = scoreboard_is_unlocked(SUITE_EXTERNAL);
    int unlockedModes  = scoreboard_is_unlocked(SUITE_MODES);
    int unlockedEdge   = scoreboard_is_unlocked(SUITE_EDGE);
    int unlockedHidden = scoreboard_is_unlocked(SUITE_HIDDEN);

    clear_screen();
    printf(CLR_BOLD CLR_MAGENTA "╔════════════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_MAGENTA "║           ★ SCOREBOARD OVERVIEW ★         ║\n" CLR_RESET);
    printf("║--------------------------------------------║\n");

    printf("║ BASIC       => %.1f/100 => %s\n",
           sb.basic_percent,
           unlockedB ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ NORMAL      => %.1f/100 => %s\n",
           sb.normal_percent,
           unlockedN ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ EXTERNAL    => %.1f/100 => %s\n",
           sb.external_percent,
           unlockedExt ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ MODES       => %.1f/100 => %s\n",
           sb.modes_percent,
           unlockedModes ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ EDGE        => %.1f/100 => %s\n",
           sb.edge_percent,
           unlockedEdge ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ HIDDEN      => %.1f/100 => %s\n",
           sb.hidden_percent,
           unlockedHidden ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║--------------------------------------------║\n");
    printf("║ Schedulers Mastery [weighted up to 15 pts]:\n");
    printf("║   FIFO:%s  RR:%s  CFS:%s  CFS-SRTF:%s  BFS:%s\n",
           sb.sc_fifo? "✔":"✘",
           sb.sc_rr? "✔":"✘",
           sb.sc_cfs? "✔":"✘",
           sb.sc_cfs_srtf? "✔":"✘",
           sb.sc_bfs? "✔":"✘");
    printf("║   SJF:%s  STRF:%s  HRRN:%s  HRRN-RT:%s  PRIORITY:%s\n",
           sb.sc_sjf? "✔":"✘",
           sb.sc_strf? "✔":"✘",
           sb.sc_hrrn? "✔":"✘",
           sb.sc_hrrn_rt? "✔":"✘",
           sb.sc_priority? "✔":"✘");
    printf("║   HPC-OVER:%s  MLFQ:%s\n",
           sb.sc_hpc_over? "✔":"✘",
           sb.sc_mlfq? "✔":"✘");
    printf("║   [Weights => BFS=2, HPC=2, MLFQ=2, others=1 each] \n");

    int final_score = scoreboard_get_final_score();
    printf("║--------------------------------------------║\n");
    printf("╚═ Overall Score => %d/100\n", final_score);

    pause_enter();
}

/* Clears scoreboard data. */
void menu_clear_scoreboard(void) {
    scoreboard_clear();
    printf("\nScoreboard cleared.\n");
    pause_enter();
}

/* Toggles speed mode between 0 and 1. */
void menu_toggle_speed_mode(void) {
    int current = stats_get_speed_mode();
    int next    = (current == 0) ? 1 : 0;
    stats_set_speed_mode(next);
    printf("\nSpeed mode set to: %s\n", (next == 0) ? "NORMAL" : "FAST");
    pause_enter();
}

/* Let user pick exactly one suite to run. */
void submenu_run_single_test(void) {
    clear_screen();
    printf("Choose which suite?\n");
    printf(" 1) Basic\n");
    printf(" 2) Normal\n");
    printf(" 3) Modes\n");
    printf(" 4) Edge\n");
    printf(" 5) Hidden\n");
    printf(" 6) External\n");
    printf("Choice: ");

    char buf[256];
    if(!read_line(buf, sizeof(buf))) return;
    int suite = parse_int_strtol(buf, -1);
    if(suite < 1 || suite > 6){
        printf("Invalid.\n");
        pause_enter();
        return;
    }

    /* Check if unlocked: */
    int unlocked = 0;
    switch(suite) {
        case 1: unlocked = scoreboard_is_unlocked(SUITE_BASIC);    break;
        case 2: unlocked = scoreboard_is_unlocked(SUITE_NORMAL);   break;
        case 3: unlocked = scoreboard_is_unlocked(SUITE_MODES);    break;
        case 4: unlocked = scoreboard_is_unlocked(SUITE_EDGE);     break;
        case 5: unlocked = scoreboard_is_unlocked(SUITE_HIDDEN);   break;
        case 6: unlocked = scoreboard_is_unlocked(SUITE_EXTERNAL); break;
        default: break;
    }
    if(!unlocked) {
        printf("That suite is locked.\n");
        pause_enter();
        return;
    }

    /* For now, we run the entire suite instead of a single internal test:
       If you want to pick specific tests inside the suite, you can expand further. */
    printf("\nRunning that suite's tests...\n");
    printf(CLR_BOLD CLR_GREEN "╔══════════════════════════════════╗\n");
    printf("║   SCHEDULE BLOCK => TEST SUITE   ║\n");
    printf("╚══════════════════════════════════╝\n" CLR_RESET);

    g_return_to_menu = 0; /* reset the flag that might be set by SIGTERM */

    switch(suite){
        case 1: {
            int t=0, p=0;
            run_basic_tests(&t,&p);
            scoreboard_update_basic(t,p);
            break;
        }
        case 2: {
            int t=0, p=0;
            run_normal_tests(&t,&p);
            scoreboard_update_normal(t,p);
            break;
        }
        case 3: {
            int t=0, p=0;
            run_modes_tests(&t,&p);
            scoreboard_update_modes(t,p);
            break;
        }
        case 4: {
            int t=0, p=0;
            run_edge_tests(&t,&p);
            scoreboard_update_edge(t,p);
            break;
        }
        case 5: {
            int t=0, p=0;
            run_hidden_tests(&t,&p);
            scoreboard_update_hidden(t,p);
            break;
        }
        case 6: {
            run_external_tests_menu();
            break;
        }
        default:
            break;
    }
    scoreboard_save();

    printf(CLR_BOLD CLR_GREEN "\n╔══════════════════════════════════╗\n");
    printf("║   END SCHEDULE BLOCK => TESTS    ║\n");
    printf("╚══════════════════════════════════╝\n" CLR_RESET);

    pause_enter();
}

/* This runs all UNLOCKED test suites in ascending order. */
void submenu_run_tests(void) {
    /* Mark that we are running tests. If SIGTERM arrives, we will return to menu. */
    g_return_to_menu = 0;

    printf(CLR_BOLD CLR_CYAN "╔═══════════════════════════════════════════╗\n");
    printf("║         Running all UNLOCKED tests        ║\n");
    printf("╚═══════════════════════════════════════════╝\n" CLR_RESET);

    if(scoreboard_is_unlocked(SUITE_BASIC) && !g_return_to_menu){
        int t=0,p=0;
        printf("\n[Running BASIC suite...]\n");
        run_basic_tests(&t,&p);
        scoreboard_update_basic(t,p);
        scoreboard_save();
    }
    if(scoreboard_is_unlocked(SUITE_NORMAL) && !g_return_to_menu){
        int t=0,p=0;
        printf("\n[Running NORMAL suite...]\n");
        run_normal_tests(&t,&p);
        scoreboard_update_normal(t,p);
        scoreboard_save();
    }
    if(scoreboard_is_unlocked(SUITE_MODES) && !g_return_to_menu){
        int t=0,p=0;
        printf("\n[Running MODES suite...]\n");
        run_modes_tests(&t,&p);
        scoreboard_update_modes(t,p);
        scoreboard_save();
    }
    if(scoreboard_is_unlocked(SUITE_EDGE) && !g_return_to_menu){
        int t=0,p=0;
        printf("\n[Running EDGE suite...]\n");
        run_edge_tests(&t,&p);
        scoreboard_update_edge(t,p);
        scoreboard_save();
    }
    if(scoreboard_is_unlocked(SUITE_HIDDEN) && !g_return_to_menu){
        int t=0,p=0;
        printf("\n[Running HIDDEN suite...]\n");
        run_hidden_tests(&t,&p);
        scoreboard_update_hidden(t,p);
        scoreboard_save();
    }
    if(scoreboard_is_unlocked(SUITE_EXTERNAL) && !g_return_to_menu){
        printf("\n[Running EXTERNAL suite...]\n");
        run_external_tests_menu();
        scoreboard_save();
    }

    pause_enter();
}

/* External concurrency submenu. As requested, SIGTERM => set concurrency stop, then return. */
void menu_submenu_external_concurrency(void) {
    int unlockedExt = scoreboard_is_unlocked(SUITE_EXTERNAL);
    if(!unlockedExt) {
        printf("\n[External Concurrency] is locked.\n");
        pause_enter();
        return;
    }

    clear_screen();
    printf(CLR_BOLD CLR_CYAN "\n╔════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "║  External Shell Concurrency Menu   ║\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "╚════════════════════════════════════╝\n" CLR_RESET);

    printf("1) Run concurrency with a SINGLE scheduling mode\n");
    printf("2) Run concurrency with ALL scheduling modes\n");
    printf("\nChoice: ");
    char buf[256];
    if(!read_line(buf, sizeof(buf))) return;
    int sub = parse_int_strtol(buf, -1);
    if(sub < 1 || sub > 2){
        printf("Invalid.\n");
        pause_enter();
        return;
    }

    printf("How many concurrent shells? ");
    if(!read_line(buf, sizeof(buf))) return;
    int n = parse_int_strtol(buf, 0);
    if(n<1){
        printf("Invalid number of shells.\n");
        pause_enter();
        return;
    }

    printf("How many CPU cores? ");
    if(!read_line(buf, sizeof(buf))) return;
    int c = parse_int_strtol(buf, 2);
    if(c<1) c=2;

    printf("\nChoose concurrency test style:\n");
    printf(" 1) Short test\n");
    printf(" 2) Medium test\n");
    printf(" 3) Stress test\n");
    printf("Choice: ");
    if(!read_line(buf,sizeof(buf))) return;
    int style = parse_int_strtol(buf,1);
    if(style<1 || style>3) style=1;

    /* Create array of commands. */
    char** lines = (char**)calloc(n, sizeof(char*));
    if(!lines) return;

    /* "SCHEDULE BLOCK" for concurrency. */
    g_return_to_menu = 0; /* allow SIGTERM to break concurrency. */

    int base=2;
    switch(style) {
        case 1: base=2;  break;
        case 2: base=5;  break;
        case 3: base=10; break;
        default: base=2; break;
    }
    /* Prepare lines for concurrency. If sub=1 => single scheduling => vary the sleeps.
       If sub=2 => all scheduling => simpler pattern. */
    int i;
    if(sub==1) {
        for(i=0; i<n; i++){
            char tmp[64];
            snprintf(tmp, sizeof(tmp), "sleep %d", (i+1)*base);
            lines[i] = strdup(tmp);
        }
    } else {
        for(i=0; i<n; i++){
            char tmp[64];
            snprintf(tmp, sizeof(tmp), "sleep %d", (i+1)*2);
            lines[i] = strdup(tmp);
        }
    }

    /* If single scheduling mode, we ask user. */
    if(sub==1){
        printf("\nSelect scheduling mode:\n");
        printf(" 0=FIFO,1=RR,2=CFS,3=CFS-SRTF,4=BFS,\n");
        printf(" 5=SJF,6=STRF,7=HRRN,8=HRRN-RT,\n");
        printf(" 9=PRIORITY,10=HPC-OVER,11=MLFQ\n");
        printf("Choice: ");
        if(!read_line(buf,sizeof(buf))){
            pause_enter();
            for(i=0;i<n;i++) free(lines[i]);
            free(lines);
            return;
        }
        int mode = parse_int_strtol(buf, -1);
        if(mode<0 || mode>11){
            printf("Invalid mode.\n");
            pause_enter();
        } else {
            run_shell_commands_concurrently(n, lines, c, mode, 0);
        }
    } else {
        run_shell_commands_concurrently(n, lines, c, -1, 1);
    }

    for(i=0; i<n; i++){
        free(lines[i]);
    }
    free(lines);

    pause_enter();
}

/* Cleanup function => finalize scoreboard, print stats, exit with code. */
void cleanup_and_exit(int code) {
    os_cleanup();
    scoreboard_save();
    scoreboard_close();
    stats_print_summary();
    exit(code);
}

/* Handle signals => SIGINT => exit, SIGTERM => stop concurrency/test but remain in menu,
   SIGUSR1 => set concurrency stop as well. */
void handle_signal(int signum) {
    if(signum == SIGINT) {
        stats_inc_signal_sigint();
        printf("\n[Main] Caught SIGINT => Save scoreboard and exit.\n");
        int fs = scoreboard_get_final_score();
        cleanup_and_exit(fs);
    }
    else if(signum == SIGTERM){
        stats_inc_signal_sigterm();
        printf("\n[Main] Caught SIGTERM => concurrency/test stops => returning to menu.\n");
        set_os_concurrency_stop_flag(1);
        /* We set this so test or concurrency loops can see it and break out. */
        g_return_to_menu = 1;
    }
    else if(signum == SIGUSR1) {
        stats_inc_signal_other();
        printf("\n[Main] Caught SIGUSR1 => concurrency stop.\n");
        set_os_concurrency_stop_flag(1);
    }
}

/* ---------------------------------------------------------
   The main() entry point
   --------------------------------------------------------- */
int main(int argc, char** argv){
    (void)argc;
    (void)argv;

    /* Hook signals. */
    signal(SIGINT,  handle_signal);
    signal(SIGTERM, handle_signal);
    signal(SIGUSR1, handle_signal);

    scoreboard_init();
    scoreboard_load();
    os_init();
    stats_init();

    while(1){
        clear_screen();
        ascii_main_menu_header();

        printf(CLR_BOLD CLR_YELLOW "┌─── MAIN MENU ─────────────────────────────┐\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 1) Run All Unlocked Test Suites           │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 2) Exit                                   │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 3) External Shell Concurrency            │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 4) External Tests                         │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 5) Show Scoreboard                        │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 6) Clear Scoreboard                       │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 7) Toggle Speed Mode                      │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 8) Run Single Test (Submenu)             │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "└────────────────────────────────────────────┘\n\n" CLR_RESET);
        printf("Choice: ");

        char input[256];
        if(!read_line(input, sizeof(input))){
            printf("Exiting (EOF/read error).\n");
            int fs = scoreboard_get_final_score();
            cleanup_and_exit(fs);
        }
        int choice = parse_int_strtol(input, -1);

        switch(choice){
        case 1:
            submenu_run_tests();
            break;
        case 2: {
            int fs = scoreboard_get_final_score();
            printf("\nExiting with final score = %d.\n", fs);
            cleanup_and_exit(fs);
            break;
        }
        case 3:
            menu_submenu_external_concurrency();
            break;
        case 4: {
            if(!scoreboard_is_unlocked(SUITE_EXTERNAL)){
                printf("External tests locked.\n");
                pause_enter();
            } else {
                printf("\nRunning external tests...\n");
                run_external_tests_menu();
                scoreboard_save();
                pause_enter();
            }
            break;
        }
        case 5:
            menu_show_scoreboard();
            break;
        case 6:
            menu_clear_scoreboard();
            break;
        case 7:
            menu_toggle_speed_mode();
            break;
        case 8:
            submenu_run_single_test();
            break;
        default:
            printf("Invalid.\n");
            pause_enter();
            break;
        }
    }
    return 0;
}
#ifndef MAIN_H
#define MAIN_H

/* Main menu and related helpers for the OS Scheduling Game. */

/* Cleanup function that saves scoreboard, prints stats, and exits the program. */
void cleanup_and_exit(int code);

/* Signal handler for SIGINT, SIGTERM, SIGUSR1. */
void handle_signal(int signum);

/* Clears the terminal screen. */
void clear_screen(void);

/* Pauses until the user presses ENTER. */
void pause_enter(void);

/* Reads one line (up to sz-1 chars). Returns 1 if success, 0 if error/EOF. */
int read_line(char *buf, size_t sz);

/* Prints the ASCII art main menu header. */
void ascii_main_menu_header(void);

/* Submenu to run all unlocked tests. */
void submenu_run_tests(void);

/* Submenu to run exactly one test from a chosen suite. */
void submenu_run_single_test(void);

/* Shows the scoreboard in a "squared ASCII" format. */
void menu_show_scoreboard(void);

/* Clears the scoreboard. */
void menu_clear_scoreboard(void);

/* Toggles speed mode: 0 => normal, 1 => fast. */
void menu_toggle_speed_mode(void);

/* External concurrency submenu. */
void menu_submenu_external_concurrency(void);

#endif
#include "os.h"
#include "stats.h"

#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <pthread.h>
#include <sys/wait.h>
#include <time.h>
#include <string.h>

#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_CYAN    "\033[96m"
#define CLR_GREEN   "\033[92m"
#define CLR_YELLOW  "\033[93m"

/* If speed mode=fast => scale down sleeps heavily. */
static void sim_sleep(unsigned int us) {
    int sm = stats_get_speed_mode();
    if(sm == 1) {
        usleep(us / 10 + 1);
    } else {
        usleep(us);
    }
}

/* concurrency stop flag => set by set_os_concurrency_stop_flag(...). */
static volatile sig_atomic_t g_concurrency_stop_flag = 0;

void set_os_concurrency_stop_flag(int val) {
    g_concurrency_stop_flag = (sig_atomic_t)val;
}

int os_concurrency_stop_requested(void) {
    return (int)g_concurrency_stop_flag;
}

/* For time measurement. */
static uint64_t g_start_ms = 0;

/* Up to 32 ephemeral containers. */
static int       g_container_count = 0;
static char      g_container_paths[32][256];

/* current monotonic time in ms. */
static uint64_t now_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)(ts.tv_sec)*1000ULL + (ts.tv_nsec / 1000000ULL);
}

void os_init(void) {
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    g_start_ms = now_ms();
    g_container_count = 0;
    memset(g_container_paths, 0, sizeof(g_container_paths));

    printf(CLR_BOLD CLR_MAGENTA "╔══════════════════════════════════════════════╗\n");
    printf("║               OS INIT COMPLETE               ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");
    sim_sleep(250000);
}

void os_cleanup(void) {
    /* remove ephemeral containers in reverse order. */
    while (g_container_count > 0) {
        g_container_count--;
        const char* path = g_container_paths[g_container_count];
        if (path && path[0]) {
            rmdir(path);
            memset(g_container_paths[g_container_count], 0, sizeof(g_container_paths[g_container_count]));
            printf(CLR_CYAN "[-] Container removed (cleanup): %s\n" CLR_RESET, path);
            sim_sleep(200000);
            stats_inc_containers_removed();
        }
    }
    printf(CLR_BOLD CLR_MAGENTA "╔══════════════════════════════════════════════╗\n");
    printf(               "║             OS CLEANUP COMPLETE             ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");
    sim_sleep(250000);
}

uint64_t os_time(void) {
    uint64_t now = now_ms();
    if (now < g_start_ms) return 0ULL;
    return (now - g_start_ms);
}

void os_log(const char* msg) {
    /* normal => print, fast => skip to reduce spam. */
    if (stats_get_speed_mode() == 0 && msg) {
        printf("%s\n", msg);
        sim_sleep(150000);
    }
}

void os_create_ephemeral_container(void) {
    if (g_container_count >= 32) return;
    char tmpl[] = "/tmp/os_cont_XXXXXX";
    if (mkdtemp(tmpl)) {
        strncpy(g_container_paths[g_container_count], tmpl, 255);
        g_container_count++;
        printf(CLR_CYAN "[+] Container created: %s (count=%d)\n" CLR_RESET,
               tmpl, g_container_count);
        sim_sleep(250000);
        stats_inc_containers_created();
    }
}

void os_remove_ephemeral_container(void) {
    if (g_container_count <= 0) return;
    g_container_count--;
    const char* path = g_container_paths[g_container_count];
    if (path[0]) {
        rmdir(path);
        memset(g_container_paths[g_container_count], 0, sizeof(g_container_paths[g_container_count]));
        printf(CLR_CYAN "[-] Container removed: %s (remaining=%d)\n" CLR_RESET,
               path, g_container_count);
        sim_sleep(250000);
        stats_inc_containers_removed();
    }
}

/* HPC overshadow => CPU-bound threads. */

static void* overshadow_thread(void* arg) {
    long *ret = (long*)arg;
    long sum = 0;
    for (long i=0; i<700000; i++) {
        sum += (i % 17) + (i % 11);
    }
    *ret = sum;
    return NULL;
}

void os_run_hpc_overshadow(void) {
    printf(CLR_CYAN "╔══════════════════════════════════════════════╗\n");
    printf("║      HPC-OVERSHADOW BLOCK START             ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");
    sim_sleep(200000);

    int n=4;
    long* results = (long*)calloc(n, sizeof(long));
    pthread_t* th = (pthread_t*)malloc(n*sizeof(pthread_t));

    for (int i=0; i<n; i++) {
        pthread_create(&th[i], NULL, overshadow_thread, &results[i]);
        printf(CLR_GREEN "   HPC Overshadow Thread #%d => time=%llu ms => started.\n" CLR_RESET,
               i+1, (unsigned long long)os_time());
        sim_sleep(300000);
    }
    for (int i=0; i<n; i++) {
        pthread_join(th[i], NULL);
        printf(CLR_GREEN "   HPC Overshadow Thread #%d => time=%llu ms => finished.\n" CLR_RESET,
               i+1, (unsigned long long)os_time());
        sim_sleep(300000);
    }

    free(th);
    free(results);

    printf(CLR_CYAN "╔══════════════════════════════════════════════╗\n");
    printf("║       HPC-OVERSHADOW BLOCK END              ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");
    sim_sleep(200000);
    printf("HPC overshadow done\n");
    sim_sleep(200000);
}

/* pipeline => fork child, do minimal logs. */
void os_pipeline_example(void) {
    printf(CLR_CYAN "╔══════════════════════════════════════════════╗\n");
    printf("║             PIPELINE BLOCK START            ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");
    sim_sleep(200000);

    pid_t c = fork();
    if (c == 0) {
        printf(CLR_GREEN "   [Pipeline child => started => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        sim_sleep(50000);
        printf(CLR_GREEN "   [Pipeline child => finishing => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        _exit(0);
    } else if (c > 0) {
        printf(CLR_GREEN "   [Pipeline parent => waiting child => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        sim_sleep(200000);
        waitpid(c, NULL, 0);
    }

    printf(CLR_CYAN "╔══════════════════════════════════════════════╗\n");
    printf("║             PIPELINE BLOCK END              ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");
    sim_sleep(200000);
    printf("Pipeline end\n");
    sim_sleep(200000);
}

/* distributed => fork child that runs HPC overshadow. */
void os_run_distributed_example(void) {
    printf(CLR_CYAN "╔══════════════════════════════════════════════╗\n");
    printf("║          DISTRIBUTED BLOCK START            ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");
    sim_sleep(200000);

    pid_t c = fork();
    if (c == 0) {
        printf(CLR_GREEN "   [Distributed child => HPC overshadow => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        sim_sleep(200000);
        os_run_hpc_overshadow();
        _exit(0);
    } else if (c > 0) {
        printf(CLR_GREEN "   [Distributed parent => waiting => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        sim_sleep(200000);
        waitpid(c, NULL, 0);
    }

    printf(CLR_CYAN "╔══════════════════════════════════════════════╗\n");
    printf("║           DISTRIBUTED BLOCK END             ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");
    sim_sleep(200000);
}
#ifndef OS_H
#define OS_H

#include <stdint.h>

/*
  OS-level stubs and abstractions:
   - ephemeral containers
   - HPC overshadow
   - pipeline
   - distributed example
   - time logging for user display logs
   - concurrency stop check (used by SIGUSR1/SIGTERM)
*/

/* Sets the concurrency stop flag (e.g. after SIGUSR1 or SIGTERM). */
void set_os_concurrency_stop_flag(int val);

/* Returns if concurrency stop was requested. */
int os_concurrency_stop_requested(void);

/* Initialize OS environment (buffers, times, etc.). */
void os_init(void);

/* Cleanup OS environment (remove ephemeral containers, etc.). */
void os_cleanup(void);

/* Returns real-world time in ms since os_init(). */
uint64_t os_time(void);

/* Optionally log a message with a short delay for user-friendly pacing in normal mode. */
void os_log(const char* msg);

/* Ephemeral container operations. */
void os_create_ephemeral_container(void);
void os_remove_ephemeral_container(void);

/* HPC overshadow => spawns multiple CPU-bound threads to demonstrate concurrency. */
void os_run_hpc_overshadow(void);

/* Pipeline example => fork a child, show pipeline start/end with ASCII. */
void os_pipeline_example(void);

/* Distributed example => fork a child that itself runs HPC overshadow. */
void os_run_distributed_example(void);

#endif
#include "process.h"
#include <string.h>

void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival) {
    if (!p) return;
    memset(p, 0, sizeof(*p));
    p->burst_time     = burst;
    p->remaining_time = burst;
    p->priority       = priority;
    p->arrival_time   = arrival;
    p->times_owning_core = 0;
}
#ifndef PROCESS_H
#define PROCESS_H

#include <stdint.h>

/*
  Single "process" (or "task") structure for scheduling.
  Fields:
   - burst_time
   - priority
   - vruntime
   - arrival_time
   - remaining_time
   - stats (start_time, end_time, first_response, responded)
   - MLFQ queue level
   - times_owning_core
*/

typedef struct process_s {
    uint64_t burst_time;       /* total CPU time needed (ms) */
    int      priority;         /* smaller => higher priority (some algs) */
    uint64_t vruntime;         /* used by CFS / CFS-SRTF */
    uint64_t arrival_time;     /* simulation "arrival" time */
    uint64_t remaining_time;   /* how many ms remain for this process */

    /* Additional fields to track stats: */
    uint64_t start_time;       /* sim time of first CPU usage */
    uint64_t end_time;         /* sim time of finishing */
    uint64_t first_response;   /* sim time of first CPU usage */
    int      responded;        /* 0 if not responded yet, 1 if yes */
    int      mlfq_level;       /* queue level for MLFQ */
    int      times_owning_core;/* how many times scheduled on a core so far */
} process_t;

/* Initialize a process with the given burst, priority, arrival_time. */
void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival);

#endif
#include "ready_queue.h"
#include <pthread.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/* We'll keep up to 10 MLFQ levels. */
#define MLFQ_MAX_QUEUES 10

typedef struct node_s {
    process_t*       proc;
    struct node_s*   next;
} node_t;

static struct {
    node_t           sentinel;   /* for normal queue usage */
    size_t           size;
    pthread_mutex_t  m;
    pthread_cond_t   c;
    scheduler_alg_t  alg;
    node_t           ml_queues[MLFQ_MAX_QUEUES]; /* heads for MLFQ */
} gQ;

/* no forward declarations => define static helper functions before usage. */

/* For HRRN ratio => need global sim time from scheduler. */
extern uint64_t get_global_sim_time(void);

static pthread_mutex_t* pm(void) { return &gQ.m; }
static pthread_cond_t*  pc(void) { return &gQ.c; }

static process_t* pop_head(void) {
    node_t* head = gQ.sentinel.next;
    if (!head) return NULL;
    gQ.sentinel.next = head->next;
    gQ.size--;
    process_t* p = head->proc;
    free(head);
    return p;
}

static void push_tail(process_t* p) {
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;
    node_t* cur = &gQ.sentinel;
    while (cur->next) {
        cur = cur->next;
    }
    cur->next = n;
    gQ.size++;
}

static void push_priority(process_t* p) {
    /* smaller priority => earlier in the list */
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;

    node_t* cur = &gQ.sentinel;
    while (cur->next && (p->priority >= cur->next->proc->priority)) {
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

static void push_cfs(process_t* p) {
    /* sorted by vruntime ascending */
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;

    node_t* cur = &gQ.sentinel;
    while (cur->next && (p->vruntime >= cur->next->proc->vruntime)) {
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

static void push_sjf(process_t* p) {
    /* sorted by original burst_time ascending */
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;

    node_t* cur = &gQ.sentinel;
    while (cur->next && (p->burst_time >= cur->next->proc->burst_time)) {
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

/* HRRN ratio => (waiting + remain) / remain => bigger => earlier.
   We'll store only numerator for comparison => waiting+remain. */
static uint64_t hrrn_val(process_t* p, uint64_t now) {
    uint64_t wait = (now > p->arrival_time) ? (now - p->arrival_time) : 0ULL;
    uint64_t remain = (p->remaining_time > 0) ? p->remaining_time : 1ULL;
    return (wait + remain);
}

static void push_hrrn(process_t* p, int preemptive) {
    (void)preemptive; /* same insertion logic, preempt is handled in scheduler runner. */

    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;

    uint64_t now = get_global_sim_time();
    uint64_t new_ratio = hrrn_val(p, now);

    node_t* cur = &gQ.sentinel;
    while (cur->next) {
        uint64_t c_ratio = hrrn_val(cur->next->proc, now);
        if (new_ratio > c_ratio) {
            break;
        }
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

/* MLFQ => multiple queues => pop from highest non-empty queue. */
static process_t* pop_mlfq(void) {
    for (int i=0; i<MLFQ_MAX_QUEUES; i++) {
        if (gQ.ml_queues[i].next) {
            node_t* n = gQ.ml_queues[i].next;
            gQ.ml_queues[i].next = n->next;
            gQ.size--;
            process_t* p = n->proc;
            free(n);
            return p;
        }
    }
    return NULL;
}

static void push_mlfq(process_t* p) {
    int level = p->mlfq_level;
    if (level < 0) level=0;
    if (level >= MLFQ_MAX_QUEUES) level = MLFQ_MAX_QUEUES - 1;

    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;

    node_t* cur = &gQ.ml_queues[level];
    while (cur->next) {
        cur = cur->next;
    }
    cur->next = n;
    gQ.size++;
}

/* We'll store function pointers for push/pop. */
static process_t* (*f_pop)(void) = NULL;
static void       (*f_push)(process_t*) = NULL;
static int        g_preemptive = 0;

void ready_queue_init_policy(scheduler_alg_t alg) {
    memset(&gQ, 0, sizeof(gQ));
    pthread_mutex_init(pm(), NULL);
    pthread_cond_init(pc(), NULL);
    gQ.alg = alg;

    switch(alg) {
    case ALG_FIFO:
    case ALG_RR:
    case ALG_BFS:
        f_push = push_tail;
        f_pop  = pop_head;
        g_preemptive = (alg == ALG_RR || alg == ALG_BFS) ? 1 : 0;
        break;

    case ALG_PRIORITY:
        f_push = push_priority;
        f_pop  = pop_head;
        g_preemptive = 0;
        break;

    case ALG_CFS:
        f_push = push_cfs;
        f_pop  = pop_head;
        g_preemptive = 0;
        break;

    case ALG_CFS_SRTF:
        f_push = push_cfs;
        f_pop  = pop_head;
        g_preemptive = 1;
        break;

    case ALG_SJF:
        f_push = push_sjf;
        f_pop  = pop_head;
        g_preemptive = 0;
        break;

    case ALG_STRF:
        f_push = push_sjf;
        f_pop  = pop_head;
        g_preemptive = 1;
        break;

    case ALG_HRRN:
        f_push = (void (*)(process_t*))push_hrrn;
        f_pop  = (process_t* (*)(void))pop_head;
        g_preemptive = 0;
        break;

    case ALG_HRRN_RT:
        f_push = (void (*)(process_t*))push_hrrn;
        f_pop  = (process_t* (*)(void))pop_head;
        g_preemptive = 1;
        break;

    case ALG_MLFQ:
        f_push = (void (*)(process_t*))push_mlfq;
        f_pop  = (process_t* (*)(void))pop_mlfq;
        g_preemptive = 1;
        break;

    default:
        /* HPC overshadow or unknown => just tail. HPC overshadow is handled outside. */
        f_push = push_tail;
        f_pop  = pop_head;
        g_preemptive = 0;
        break;
    }
}

void ready_queue_destroy(void) {
    pthread_cond_destroy(pc());
    pthread_mutex_destroy(pm());
    memset(&gQ, 0, sizeof(gQ));
}

void ready_queue_push(process_t* p) {
    pthread_mutex_lock(pm());
    if (p) {
        if (gQ.alg == ALG_HRRN || gQ.alg == ALG_HRRN_RT) {
            push_hrrn(p, (gQ.alg==ALG_HRRN_RT)?1:0);
        } else if (gQ.alg == ALG_MLFQ) {
            push_mlfq(p);
        } else {
            f_push(p);
        }
    }
    pthread_cond_broadcast(pc());
    pthread_mutex_unlock(pm());
}

process_t* ready_queue_pop(void) {
    pthread_mutex_lock(pm());
    while(1) {
        if(gQ.size>0) {
            process_t* r = f_pop();
            pthread_mutex_unlock(pm());
            return r;
        }
        pthread_cond_wait(pc(), pm());
    }
    /* never reached */
    pthread_mutex_unlock(pm());
    return NULL;
}

size_t ready_queue_size(void) {
    pthread_mutex_lock(pm());
    size_t s = gQ.size;
    pthread_mutex_unlock(pm());
    return s;
}
#ifndef READY_QUEUE_H
#define READY_QUEUE_H

#include <stddef.h>
#include "process.h"
#include "scheduler.h"

/*
  "ready_queue" data structure, with policy determined by scheduler_alg_t.
  Thread-safe with mutex + cond.
*/

/* Initialize the ready queue with a given scheduling algorithm. */
void ready_queue_init_policy(scheduler_alg_t alg);

/* Destroy the ready queue, freeing resources. */
void ready_queue_destroy(void);

/* Push a process into the queue. (thread-safe) */
void ready_queue_push(process_t* proc);

/* Pop a process from the queue. (thread-safe, blocks if empty) */
process_t* ready_queue_pop(void);

/* Returns the current size. (thread-safe) */
size_t ready_queue_size(void);

#endif
#include "runner.h"
#include "scheduler.h"
#include "scoreboard.h"
#include "os.h"
#include "safe_calls_library.h"
#include "stats.h"

#include <stdio.h>
#include <string.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/ptrace.h>
#include <unistd.h>
#include <signal.h>
#include "../test/external-test.h"

/* We keep a table of mode enumerations and strings: */
static scheduler_alg_t modes_arr[] = {
    ALG_FIFO, ALG_RR, ALG_CFS, ALG_CFS_SRTF, ALG_BFS,
    ALG_SJF, ALG_STRF, ALG_HRRN, ALG_HRRN_RT, ALG_PRIORITY,
    ALG_HPC_OVERSHADOW, ALG_MLFQ
};
static const char* modeNames[] = {
    "FIFO","RR","CFS","CFS-SRTF","BFS",
    "SJF","STRF","HRRN","HRRN-RT","PRIORITY",
    "HPC-OVER","MLFQ"
};

void run_all_levels(void) {
    /* Previously used, now a stub or replaced by menu logic. */
    printf("[runner] run_all_levels => replaced by main menu logic.\n");
}

void run_external_tests_menu(void) {
    if(!scoreboard_is_unlocked(SUITE_EXTERNAL)) {
        return;
    }
    /* Single call that runs the entire external suite. */
    run_external_tests();
}

/*
  We'll reorder the concurrency child debug routine so there's no forward decl.
*/

/* Child debugging logic with ptrace to show advanced concurrency. */
static void advanced_debug_child(pid_t pid) {
    /* We do not print anything in FAST mode to keep concurrency short. */
    int sm = stats_get_speed_mode();
    if(ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1) {
        if(sm==0) {
            fprintf(stderr,"[Runner] ptrace attach fail (pid=%d): %s\n",
                    pid, strerror(errno));
        }
        return;
    }
    waitpid(pid, NULL, 0);

    if(ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) == -1) {
        if(sm==0) {
            fprintf(stderr,"[Runner] ptrace singlestep fail: %s\n", strerror(errno));
        }
    }
    waitpid(pid, NULL, 0);

    ptrace(PTRACE_DETACH, pid, NULL, NULL);
}

/* Child info structure. */
typedef struct {
    pid_t   pid;
    char*   cmd;
    int     core;
    uint64_t start_ms;
    int     p_out[2];
    int     p_err[2];
    int     p_in[2];
} child_t;

/* Spawn a child => set up pipes => run shell => advanced ptrace => return child. */
static pid_t spawn_child(const char* cmd, child_t* ch, int core) {
    pipe(ch->p_out);
    pipe(ch->p_err);
    pipe(ch->p_in);

    pid_t c = fork();
    if (c < 0) {
        fprintf(stderr,"fork() error\n");
        return -1;
    } else if (c == 0) {
        /* Child side => redirect stdio to pipes. */
        close(ch->p_out[0]);
        close(ch->p_err[0]);
        close(ch->p_in[0]);
        dup2(ch->p_out[1], STDOUT_FILENO);
        dup2(ch->p_err[1], STDERR_FILENO);
        dup2(ch->p_in[1],  STDIN_FILENO);
        close(ch->p_out[1]);
        close(ch->p_err[1]);
        close(ch->p_in[1]);

        /* This is the shell we are spawning. Must exist in CWD. */
        execl("./shell-tp1-implementation", "shell-tp1-implementation", (char*)NULL);
        _exit(127);
    } else {
        /* Parent side => advanced ptrace attach. */
        ch->pid = c;
        ch->cmd = (cmd ? strdup(cmd) : NULL);
        ch->core = core;
        ch->start_ms = os_time();

        stats_inc_processes_spawned();

        close(ch->p_out[1]);
        close(ch->p_err[1]);
        close(ch->p_in[0]);

        dprintf(ch->p_in[1], "%s\nexit\n", cmd ? cmd : "");
        close(ch->p_in[1]);

        advanced_debug_child(c);
    }
    return c;
}

/* If FAST mode => skip concurrency logs. If normal => show them. */
static void concurrency_log(const char* fmt, ...) {
    if(stats_get_speed_mode() == 1) {
        /* FAST => skip */
        return;
    }
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
}

/* Actually run concurrency with a certain set of commands. */
void run_shell_commands_concurrently(int count,
                                     char** lines,
                                     int coreCount,
                                     int mode,
                                     int allModes) {
    if(count <= 0 || !lines) return;
    if(access("./shell-tp1-implementation", X_OK) != 0){
        printf("No shell-tp1-implementation found (expected in CWD).\n");
        return;
    }

    /* Each call => concurrency run => track in stats. */
    stats_inc_concurrency_runs();

    /* Indicate schedule block start. */
    printf(CLR_MAGENTA "\n╔══════════════════════════════════════════════╗\n");
    printf(             "║ CONCURRENCY => Shell Commands Scheduling     ║\n");
    printf(             "╚══════════════════════════════════════════════╝\n" CLR_RESET);

    int from = 0;
    int to   = (int)(sizeof(modes_arr)/sizeof(modes_arr[0])) - 1;
    if(!allModes) {
        if(mode<0 || mode>to) {
            printf("Invalid scheduling mode for concurrency.\n");
            return;
        }
        from = mode;
        to   = mode;
    }

    for(int m = from; m <= to; m++) {
        if(os_concurrency_stop_requested()) {
            concurrency_log("[runner] concurrency stop requested => returning.\n");
            break;
        }

        concurrency_log(CLR_MAGENTA "\n╔═════════════════════════════════════════════════════════════╗\n");
        concurrency_log("║ SCHEDULE BLOCK START => %s\n", modeNames[m]);
        concurrency_log("╚═════════════════════════════════════════════════════════════╝" CLR_RESET "\n");

        child_t* ch = (child_t*)calloc(count, sizeof(child_t));
        if(!ch) return;

        uint64_t global_start = os_time();
        int next_core = 0;

        /* spawn each child. */
        for(int i=0; i<count; i++){
            if(os_concurrency_stop_requested()){
                concurrency_log("[runner] concurrency stop => skip remaining spawns.\n");
                break;
            }
            spawn_child(lines[i], &ch[i], next_core);
            concurrency_log(CLR_GREEN"[time=%llu ms] container=1 core=%d => Launch child#%d cmd=\"%s\"\n"CLR_RESET,
                   (unsigned long long)os_time(),
                   next_core, i+1, lines[i] ? lines[i] : "");
            next_core = (next_core + 1) % coreCount;
        }

        /* wait each child. If stop requested, kill the rest. */
        for(int i=0; i<count; i++){
            if(!ch[i].pid) continue;
            if(os_concurrency_stop_requested()){
                concurrency_log("[runner] concurrency stop => kill remaining children.\n");
                kill(ch[i].pid, SIGKILL);
                continue;
            }
            waitpid(ch[i].pid, NULL, 0);
            uint64_t end_ms = os_time();
            concurrency_log(CLR_YELLOW"[time=%llu ms] container=1 core=%d => Child#%d ended => cmd=\"%s\" total_duration=%llums\n"CLR_RESET,
                   (unsigned long long)os_time(),
                   ch[i].core, i+1,
                   (ch[i].cmd ? ch[i].cmd : ""),
                   (unsigned long long)(end_ms - ch[i].start_ms));
        }

        uint64_t global_end = os_time();
        uint64_t total_time = (global_end > global_start) ? (global_end - global_start) : 0ULL;

        /* Drain leftover output, close pipes. */
        for(int i=0; i<count; i++){
            if(!ch[i].pid) continue;
            char outb[256]={0}, errb[256]={0};
            read(ch[i].p_out[0], outb, sizeof(outb)-1);
            read(ch[i].p_err[0], errb, sizeof(errb)-1);
            close(ch[i].p_out[0]);
            close(ch[i].p_err[0]);
            if(ch[i].cmd) free(ch[i].cmd);
        }
        free(ch);

        concurrency_log(CLR_MAGENTA"╔═════════════════════════════════════════════════════════════╗\n");
        concurrency_log("║ SCHEDULE BLOCK END => %s, total_time=%llums\n",
               modeNames[m], (unsigned long long)total_time);
        concurrency_log("╚═════════════════════════════════════════════════════════════╝"CLR_RESET"\n");
    }

    printf(CLR_MAGENTA "\n╔══════════════════════════════════════════════╗\n");
    printf(             "║ END CONCURRENCY SCHEDULE BLOCK               ║\n");
    printf(             "╚══════════════════════════════════════════════╝\n" CLR_RESET);
    set_os_concurrency_stop_flag(0);
}
#ifndef RUNNER_H
#define RUNNER_H

/*
  runner.h => code to run entire test suites or concurrency commands
              with chosen scheduling modes.
*/

/* Replaces the old run_all_levels with a no-op or stub. */
void run_all_levels(void);

/* Runs the external tests menu, checks scoreboard, etc. */
void run_external_tests_menu(void);

/*
  Run shell commands concurrently with a chosen scheduling mode or all modes.
  - count        => how many commands
  - lines        => array of string commands
  - coreCount    => how many CPU cores
  - mode         => which mode to use; if -1 => run all
  - allModes     => 1 => run all modes, 0 => single mode
*/
void run_shell_commands_concurrently(int count,
                                     char** lines,
                                     int coreCount,
                                     int mode,
                                     int allModes);

#endif
#include "safe_calls_library.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <string.h>

int parse_int_strtol(const char* in, int fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    long v=strtol(in, &e, 10);
    if(e==in || errno==ERANGE || v<INT_MIN || v>INT_MAX) return fb;
    return (int)v;
}

long parse_long_strtol(const char* in, long fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    long v=strtol(in, &e, 10);
    if(e==in || errno==ERANGE) return fb;
    return v;
}

float parse_float_strtof(const char* in, float fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    float v=strtof(in, &e);
    if(e==in || errno==ERANGE) return fb;
    return v;
}

double parse_double_strtod(const char* in, double fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    double v=strtod(in, &e);
    if(e==in || errno==ERANGE) return fb;
    return v;
}

int safe_pthread_create(void*(*f)(void*), void* arg) {
    pthread_t t;
    int r = pthread_create(&t, NULL, f, arg);
    if(r) {
        fprintf(stderr,"pthread_create fail: %s\n", strerror(r));
        return -1;
    }
    pthread_detach(t);
    return 0;
}
#ifndef SAFE_CALLS_LIBRARY_H
#define SAFE_CALLS_LIBRARY_H

int    safe_pthread_create(void*(*f)(void*), void* arg);
int    parse_int_strtol(const char* input, int fallback);
long   parse_long_strtol(const char* input, long fallback);
float  parse_float_strtof(const char* input, float fallback);
double parse_double_strtod(const char* input, double fallback);

#endif
#include "scheduler.h"
#include "ready_queue.h"
#include "worker.h"
#include "os.h"
#include "stats.h"

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

/* number of cores limit */
#ifndef MAX_CORES
#define MAX_CORES 4
#endif

static scheduler_alg_t g_current_alg = ALG_CFS;
static int             g_num_cores   = 1;
static int             g_running     = 0;

/* global sim_time => increment by slices to compute wait, TAT, etc. */
static uint64_t        g_sim_time = 0;
static pthread_mutex_t g_sim_time_lock = PTHREAD_MUTEX_INITIALIZER;

/* HPC overshadow mode => no normal stats. */
static int HPC_over_mode = 0;

/* store processes pointer and count for final stats. */
static process_t* g_process_list = NULL;
static int        g_list_count   = 0;

/* accumulators for stats. */
static double gAvgWait = 0.0, gAvgTAT = 0.0, gAvgResp = 0.0;
static unsigned long long gPreemptions = 0ULL, gProcs = 0ULL;

static uint64_t g_total_wait = 0ULL;
static uint64_t g_total_tat  = 0ULL;
static uint64_t g_total_resp = 0ULL;
static unsigned long long g_total_preempts = 0ULL;
static int                g_total_count    = 0;

uint64_t get_global_sim_time(void) {
    pthread_mutex_lock(&g_sim_time_lock);
    uint64_t t = g_sim_time;
    pthread_mutex_unlock(&g_sim_time_lock);
    return t;
}

static void reset_accumulators(void) {
    gAvgWait       = 0.0;
    gAvgTAT        = 0.0;
    gAvgResp       = 0.0;
    gPreemptions   = 0ULL;
    gProcs         = 0ULL;

    g_total_wait   = 0ULL;
    g_total_tat    = 0ULL;
    g_total_resp   = 0ULL;
    g_total_preempts = 0ULL;
    g_total_count  = 0;

    HPC_over_mode  = 0;
    g_sim_time     = 0;
}

/* in normal mode => we slow down to show steps, in fast => minimal wait. */
static void sim_sleep_scheduler(unsigned int us){
    int sm = stats_get_speed_mode();
    if(sm==1){
        usleep(us/10 + 1);
    } else {
        usleep(us);
    }
}

void scheduler_select_algorithm(scheduler_alg_t a) {
    g_current_alg = a;
}

static void finalize_stats(void) {
    if(HPC_over_mode || g_list_count <= 0) {
        return;
    }
    for(int i=0; i<g_list_count; i++) {
        process_t* P = &g_process_list[i];
        uint64_t at = P->arrival_time;
        uint64_t st = P->first_response;
        uint64_t et = P->end_time;

        uint64_t wait = (st > at) ? (st - at) : 0ULL;
        uint64_t tat  = (et > at) ? (et - at) : 0ULL;
        uint64_t resp = wait;

        g_total_wait += wait;
        g_total_tat  += tat;
        g_total_resp += resp;
    }
    g_total_count = g_list_count;

    if(g_total_count > 0) {
        gAvgWait = (double)g_total_wait / (double)g_total_count;
        gAvgTAT  = (double)g_total_tat  / (double)g_total_count;
        gAvgResp = (double)g_total_resp / (double)g_total_count;
    }
    gPreemptions = g_total_preempts;
    gProcs       = g_total_count;
}

/* thread function => continuously pop from queue => run partial => push back or finalize. */
static void* core_thread_func(void* arg) {
    long core_id = (long)arg;
    unsigned long quantum = 2; /* small quantum for preemptive algs */

    while(g_running) {
        process_t* p = ready_queue_pop();
        if(!g_running || !p) {
            /* might be shutting down => break. */
            continue;
        }
        uint64_t real_t = os_time();

        /* skip printing if speed=fast => reduce spam. */
        if(stats_get_speed_mode()==0) {
            printf("\033[93m[time=%llu ms] => container=1 core=%ld => scheduling processPtr=%p\n"
                   "   => burst_time=%lu, prio=%d, vruntime=%llu, remain=%llu, timesScheduled=%d\033[0m\n",
                   (unsigned long long)real_t,
                   core_id, (void*)p,
                   (unsigned long)p->burst_time,
                   p->priority,
                   (unsigned long long)p->vruntime,
                   (unsigned long long)p->remaining_time,
                   p->times_owning_core);
            sim_sleep_scheduler(300000);
        }

        if(!p->responded) {
            p->responded = 1;
            p->first_response = get_global_sim_time();
        }
        p->times_owning_core++;

        int preemptive = 0;
        switch(g_current_alg) {
        case ALG_RR:
        case ALG_BFS:
        case ALG_CFS_SRTF:
        case ALG_STRF:
        case ALG_HRRN_RT:
        case ALG_MLFQ:
            preemptive = 1;
            break;
        default:
            preemptive = 0;
            break;
        }

        unsigned long slice = 0;
        if(preemptive) {
            if(p->remaining_time > quantum) {
                slice = quantum;
            } else {
                slice = p->remaining_time;
            }
        } else {
            slice = p->remaining_time;
        }

        simulate_process_partial(p, slice, (int)core_id);

        /* increment g_sim_time by 'slice' for scheduling. */
        pthread_mutex_lock(&g_sim_time_lock);
        g_sim_time += slice;
        uint64_t now_sim = g_sim_time;
        pthread_mutex_unlock(&g_sim_time_lock);

        p->remaining_time -= slice;
        if(g_current_alg == ALG_CFS || g_current_alg == ALG_CFS_SRTF) {
            p->vruntime += slice;
        }

        if(preemptive && p->remaining_time > 0) {
            __sync_fetch_and_add(&g_total_preempts, 1ULL);
            if(stats_get_speed_mode()==0) {
                printf("\033[94m   => PREEMPT => processPtr=%p => new remain=%llu => preemptions=%llu\033[0m\n",
                       (void*)p,
                       (unsigned long long)p->remaining_time,
                       (unsigned long long)g_total_preempts);
                sim_sleep_scheduler(300000);
            }

            if(g_current_alg == ALG_MLFQ) {
                p->mlfq_level++;
            }
            ready_queue_push(p);
        } else {
            p->end_time = now_sim;
            if(stats_get_speed_mode()==0) {
                printf("\033[92m   => FINISH => processPtr=%p => total CPU used=%lu ms => time=%llu ms\033[0m\n",
                       (void*)p,
                       (unsigned long)slice,
                       (unsigned long long)os_time());
                sim_sleep_scheduler(300000);
            }
        }
    }
    return NULL;
}

void scheduler_run(process_t* list, int count) {
    reset_accumulators();
    if(!list || count <= 0) return;

    if(g_current_alg == ALG_HPC_OVERSHADOW) {
        HPC_over_mode = 1;
        /* Just run HPC overshadow, no stats. */
        printf("\n\033[95m╔══════════════════════════════════════════════╗\n");
        printf(         "║       SCHEDULE NAME => HPC-OVERSHADOW        ║\n");
        printf(         "╚══════════════════════════════════════════════╝\033[0m\n");
        sim_sleep_scheduler(300000);

        os_run_hpc_overshadow();

        printf("\033[96m╔══════════════════════════════════════════════╗\n");
        printf(       "║  SCHEDULE END => HPC-OVERSHADOW => no stats  ║\n");
        printf(       "╚══════════════════════════════════════════════╝\033[0m\n");
        sim_sleep_scheduler(300000);
        return;
    }

    /* For display. */
    printf("\n\033[95m╔══════════════════════════════════════════════╗\n");
    printf(         "║   SCHEDULE NAME => %d (enum)                 ║\n", g_current_alg);
    printf(         "║   Number of processes => %d                  ║\n", count);
    printf(         "║   Time start => %llu ms                      ║\n", (unsigned long long)os_time());
    printf(         "╚══════════════════════════════════════════════╝\033[0m\n");
    sim_sleep_scheduler(300000);

    /* Decide number of cores. BFS or MLFQ => 2 cores, else 1. (example) */
    switch(g_current_alg) {
    case ALG_BFS:
    case ALG_MLFQ:
        g_num_cores = 2;
        break;
    default:
        g_num_cores = 1;
        break;
    }

    ready_queue_init_policy(g_current_alg);

    g_process_list = list;
    g_list_count   = count;
    g_running      = 1;

    /* push all procs. */
    for(int i=0; i<count; i++) {
        ready_queue_push(&list[i]);
    }

    pthread_t tid[MAX_CORES];
    int n = (g_num_cores > MAX_CORES) ? MAX_CORES : g_num_cores;
    for(int i=0; i<n; i++) {
        pthread_create(&tid[i], NULL, core_thread_func, (void*)(long)i);
    }

    while(ready_queue_size() > 0) {
        sim_sleep_scheduler(200000);
        if(os_concurrency_stop_requested()) {
            /* if concurrency stop => break early. The leftover queue gets free popped. */
            break;
        }
    }

    g_running = 0;
    /* push NULL to unblock threads. */
    for(int i=0; i<n; i++) {
        ready_queue_push(NULL);
    }
    for(int i=0; i<n; i++) {
        pthread_join(tid[i], NULL);
    }

    ready_queue_destroy();
    finalize_stats();

    uint64_t total_time = get_global_sim_time();
    printf("\033[96m╔══════════════════════════════════════════════╗\n");
    printf(       "║ SCHEDULE END => alg=%d => totalTime=%llums    ║\n", g_current_alg, (unsigned long long)total_time);
    printf(       "║ Stats: preemptions=%llu, totalProcs=%llu     ║\n", (unsigned long long)gPreemptions, (unsigned long long)gProcs);
    printf(       "║ AvgWait=%.2f, AvgTAT=%.2f, AvgResp=%.2f       ║\n", gAvgWait, gAvgTAT, gAvgResp);
    printf(       "╚══════════════════════════════════════════════╝\033[0m\n");
    sim_sleep_scheduler(300000);

    g_process_list = NULL;
    g_list_count   = 0;
}

void scheduler_fetch_report(sched_report_t* out) {
    if(!out) return;
    if(HPC_over_mode) {
        out->avg_wait       = 0.0;
        out->avg_turnaround = 0.0;
        out->avg_response   = 0.0;
        out->preemptions    = 0ULL;
        out->total_procs    = 0ULL;
    } else {
        out->avg_wait       = gAvgWait;
        out->avg_turnaround = gAvgTAT;
        out->avg_response   = gAvgResp;
        out->preemptions    = gPreemptions;
        out->total_procs    = gProcs;
    }
}
#ifndef SCHEDULER_H
#define SCHEDULER_H

#include "process.h"
#include <stdint.h>

/*
  Recognized scheduling algorithms
*/
typedef enum {
    ALG_CFS = 0,
    ALG_CFS_SRTF,
    ALG_FIFO,
    ALG_RR,
    ALG_SJF,
    ALG_STRF,
    ALG_HRRN,
    ALG_HRRN_RT,
    ALG_BFS,
    ALG_PRIORITY,
    ALG_HPC_OVERSHADOW,
    ALG_MLFQ
} scheduler_alg_t;

typedef struct {
    double avg_wait;
    double avg_turnaround;
    double avg_response;
    unsigned long long preemptions;
    unsigned long long total_procs;
} sched_report_t;

/* Select an algorithm. */
void scheduler_select_algorithm(scheduler_alg_t a);

/* Run the scheduling simulation on an array of processes. */
void scheduler_run(process_t* list, int count);

/* Retrieve final stats from last run. */
void scheduler_fetch_report(sched_report_t* out);

/* Accessor so the ready-queue can see current simulated time for HRRN. */
uint64_t get_global_sim_time(void);

#endif
#include "scoreboard.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

/* We'll keep a static scoreboard in memory. */
static scoreboard_t gSB = {
    0,0,0,0,0,0,  0,0,0,0,0,0,
    0,0,0,0,0,0,
    60.0 /* pass_threshold default => 60% */
};

static char* read_file_all(const char* path) {
    FILE* f = fopen(path, "rb");
    if(!f) return NULL;
    fseek(f, 0, SEEK_END);
    long sz = ftell(f);
    if(sz<0) {
        fclose(f);
        return NULL;
    }
    fseek(f, 0, SEEK_SET);
    char* buf = (char*)malloc(sz+1);
    if(!buf) {
        fclose(f);
        return NULL;
    }
    if(fread(buf,1,sz,f) != (size_t)sz) {
        fclose(f);
        free(buf);
        return NULL;
    }
    buf[sz] = '\0';
    fclose(f);
    return buf;
}

static int parse_json_int(const char* json, const char* key, int def) {
    if(!json || !key) return def;
    char pattern[128];
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    char* found = strstr(json, pattern);
    if(!found) return def;
    char* colon = strstr(found, ":");
    if(!colon) return def;
    colon++;
    while(*colon && (*colon==' '||*colon=='\t')) colon++;
    int val = def;
    sscanf(colon, "%d", &val);
    return val;
}

static double parse_json_double(const char* json, const char* key, double def) {
    if(!json || !key) return def;
    char pattern[128];
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    char* found = strstr(json, pattern);
    if(!found) return def;
    char* colon = strstr(found, ":");
    if(!colon) return def;
    colon++;
    while(*colon && (*colon==' '||*colon=='\t')) colon++;
    double val = def;
    sscanf(colon, "%lf", &val);
    return val;
}

static void write_scoreboard_json(const scoreboard_t* sb) {
    FILE* f = fopen("scoreboard.json", "w");
    if(!f) return;

    fprintf(f, "{\n");
    fprintf(f, "  \"basic_total\": %d,\n", sb->basic_total);
    fprintf(f, "  \"basic_pass\": %d,\n", sb->basic_pass);
    fprintf(f, "  \"normal_total\": %d,\n", sb->normal_total);
    fprintf(f, "  \"normal_pass\": %d,\n", sb->normal_pass);
    fprintf(f, "  \"external_total\": %d,\n", sb->external_total);
    fprintf(f, "  \"external_pass\": %d,\n", sb->external_pass);
    fprintf(f, "  \"modes_total\": %d,\n", sb->modes_total);
    fprintf(f, "  \"modes_pass\": %d,\n", sb->modes_pass);
    fprintf(f, "  \"edge_total\": %d,\n", sb->edge_total);
    fprintf(f, "  \"edge_pass\": %d,\n", sb->edge_pass);
    fprintf(f, "  \"hidden_total\": %d,\n", sb->hidden_total);
    fprintf(f, "  \"hidden_pass\": %d,\n", sb->hidden_pass);

    fprintf(f, "  \"sc_fifo\": %d,\n",      sb->sc_fifo);
    fprintf(f, "  \"sc_rr\": %d,\n",        sb->sc_rr);
    fprintf(f, "  \"sc_cfs\": %d,\n",       sb->sc_cfs);
    fprintf(f, "  \"sc_cfs_srtf\": %d,\n",  sb->sc_cfs_srtf);
    fprintf(f, "  \"sc_bfs\": %d,\n",       sb->sc_bfs);
    fprintf(f, "  \"sc_sjf\": %d,\n",       sb->sc_sjf);
    fprintf(f, "  \"sc_strf\": %d,\n",      sb->sc_strf);
    fprintf(f, "  \"sc_hrrn\": %d,\n",      sb->sc_hrrn);
    fprintf(f, "  \"sc_hrrn_rt\": %d,\n",   sb->sc_hrrn_rt);
    fprintf(f, "  \"sc_priority\": %d,\n",  sb->sc_priority);
    fprintf(f, "  \"sc_hpc_over\": %d,\n",  sb->sc_hpc_over);
    fprintf(f, "  \"sc_mlfq\": %d,\n",      sb->sc_mlfq);

    fprintf(f, "  \"basic_percent\": %.3f,\n",    sb->basic_percent);
    fprintf(f, "  \"normal_percent\": %.3f,\n",   sb->normal_percent);
    fprintf(f, "  \"external_percent\": %.3f,\n", sb->external_percent);
    fprintf(f, "  \"modes_percent\": %.3f,\n",    sb->modes_percent);
    fprintf(f, "  \"edge_percent\": %.3f,\n",     sb->edge_percent);
    fprintf(f, "  \"hidden_percent\": %.3f,\n",   sb->hidden_percent);

    fprintf(f, "  \"pass_threshold\": %.1f\n",    sb->pass_threshold);
    fprintf(f, "}\n");
    fclose(f);
}

void scoreboard_init(void) {
    /* no-op */
}

void scoreboard_close(void) {
    /* no-op */
}

void scoreboard_load(void) {
    char* json = read_file_all("scoreboard.json");
    if(!json) {
        return;
    }

    gSB.basic_total    = parse_json_int(json,"basic_total",    gSB.basic_total);
    gSB.basic_pass     = parse_json_int(json,"basic_pass",     gSB.basic_pass);
    gSB.normal_total   = parse_json_int(json,"normal_total",   gSB.normal_total);
    gSB.normal_pass    = parse_json_int(json,"normal_pass",    gSB.normal_pass);
    gSB.external_total = parse_json_int(json,"external_total", gSB.external_total);
    gSB.external_pass  = parse_json_int(json,"external_pass",  gSB.external_pass);
    gSB.modes_total    = parse_json_int(json,"modes_total",    gSB.modes_total);
    gSB.modes_pass     = parse_json_int(json,"modes_pass",     gSB.modes_pass);
    gSB.edge_total     = parse_json_int(json,"edge_total",     gSB.edge_total);
    gSB.edge_pass      = parse_json_int(json,"edge_pass",      gSB.edge_pass);
    gSB.hidden_total   = parse_json_int(json,"hidden_total",   gSB.hidden_total);
    gSB.hidden_pass    = parse_json_int(json,"hidden_pass",    gSB.hidden_pass);

    gSB.sc_fifo      = parse_json_int(json,"sc_fifo",      gSB.sc_fifo);
    gSB.sc_rr        = parse_json_int(json,"sc_rr",        gSB.sc_rr);
    gSB.sc_cfs       = parse_json_int(json,"sc_cfs",       gSB.sc_cfs);
    gSB.sc_cfs_srtf  = parse_json_int(json,"sc_cfs_srtf",  gSB.sc_cfs_srtf);
    gSB.sc_bfs       = parse_json_int(json,"sc_bfs",       gSB.sc_bfs);
    gSB.sc_sjf       = parse_json_int(json,"sc_sjf",       gSB.sc_sjf);
    gSB.sc_strf      = parse_json_int(json,"sc_strf",      gSB.sc_strf);
    gSB.sc_hrrn      = parse_json_int(json,"sc_hrrn",      gSB.sc_hrrn);
    gSB.sc_hrrn_rt   = parse_json_int(json,"sc_hrrn_rt",   gSB.sc_hrrn_rt);
    gSB.sc_priority  = parse_json_int(json,"sc_priority",  gSB.sc_priority);
    gSB.sc_hpc_over  = parse_json_int(json,"sc_hpc_over",  gSB.sc_hpc_over);
    gSB.sc_mlfq      = parse_json_int(json,"sc_mlfq",      gSB.sc_mlfq);

    gSB.basic_percent    = parse_json_double(json,"basic_percent",    gSB.basic_percent);
    gSB.normal_percent   = parse_json_double(json,"normal_percent",   gSB.normal_percent);
    gSB.external_percent = parse_json_double(json,"external_percent", gSB.external_percent);
    gSB.modes_percent    = parse_json_double(json,"modes_percent",    gSB.modes_percent);
    gSB.edge_percent     = parse_json_double(json,"edge_percent",     gSB.edge_percent);
    gSB.hidden_percent   = parse_json_double(json,"hidden_percent",   gSB.hidden_percent);
    gSB.pass_threshold   = parse_json_double(json,"pass_threshold",   gSB.pass_threshold);

    free(json);
}

/* Recompute pass% => locked/unlocked logic => we store in scoreboard for easy usage. */
static void recompute_pass_percents(void) {
    if(gSB.basic_total>0)
        gSB.basic_percent = (gSB.basic_pass  *100.0)/(double)gSB.basic_total;
    else
        gSB.basic_percent = 0.0;

    if(gSB.normal_total>0)
        gSB.normal_percent = (gSB.normal_pass *100.0)/(double)gSB.normal_total;
    else
        gSB.normal_percent = 0.0;

    if(gSB.external_total>0)
        gSB.external_percent = (gSB.external_pass*100.0)/(double)gSB.external_total;
    else
        gSB.external_percent = 0.0;

    if(gSB.modes_total>0)
        gSB.modes_percent = (gSB.modes_pass  *100.0)/(double)gSB.modes_total;
    else
        gSB.modes_percent = 0.0;

    if(gSB.edge_total>0)
        gSB.edge_percent = (gSB.edge_pass   *100.0)/(double)gSB.edge_total;
    else
        gSB.edge_percent = 0.0;

    if(gSB.hidden_total>0)
        gSB.hidden_percent = (gSB.hidden_pass *100.0)/(double)gSB.hidden_total;
    else
        gSB.hidden_percent = 0.0;
}

static int is_suite_unlocked(scoreboard_suite_t suite) {
    double T = gSB.pass_threshold;
    switch(suite) {
    case SUITE_BASIC:
        return (gSB.basic_percent >= T) ? 1 : 0;
    case SUITE_NORMAL:
        return (gSB.normal_percent >= T) ? 1 : 0;
    case SUITE_EXTERNAL:
        return (gSB.external_percent >= T) ? 1 : 0;
    case SUITE_MODES:
        return (gSB.modes_percent >= T) ? 1 : 0;
    case SUITE_EDGE:
        return (gSB.edge_percent >= T) ? 1 : 0;
    case SUITE_HIDDEN:
        return (gSB.hidden_percent >= T) ? 1 : 0;
    default:
        return 0;
    }
}

/* BFS=2, HPC=2, MLFQ=2, others=1 => up to 15 total => form 10% of overall. */
static int get_scheduler_points(void) {
    int points = 0;
    if(gSB.sc_fifo)         points += 1;
    if(gSB.sc_rr)           points += 1;
    if(gSB.sc_cfs)          points += 1;
    if(gSB.sc_cfs_srtf)     points += 1;
    if(gSB.sc_bfs)          points += 2;
    if(gSB.sc_sjf)          points += 1;
    if(gSB.sc_strf)         points += 1;
    if(gSB.sc_hrrn)         points += 1;
    if(gSB.sc_hrrn_rt)      points += 1;
    if(gSB.sc_priority)     points += 1;
    if(gSB.sc_hpc_over)     points += 2;
    if(gSB.sc_mlfq)         points += 2;
    return points;
}

void scoreboard_save(void) {
    recompute_pass_percents();
    write_scoreboard_json(&gSB);
}

void scoreboard_clear(void) {
    memset(&gSB, 0, sizeof(gSB));
    gSB.pass_threshold = 60.0;
    scoreboard_save();
}

void get_scoreboard(scoreboard_t* out) {
    if(out) *out = gSB;
}

int scoreboard_get_final_score(void) {
    recompute_pass_percents();

    double b  = gSB.basic_percent     * 0.32; /* basic => 32% */
    double n  = gSB.normal_percent    * 0.20; /* normal => 20% */
    double e  = gSB.external_percent  * 0.10; /* external => 10% */
    double m  = gSB.modes_percent     * 0.10; /* modes => 10% */
    double ed = gSB.edge_percent      * 0.10; /* edge => 10% */
    double h  = gSB.hidden_percent    * 0.08; /* hidden => 8% */

    int sched_pts = get_scheduler_points();
    double sched_percent = ((double)sched_pts / 15.0)*100.0;
    double s = sched_percent * 0.10;  /* scheduling mastery => 10% of overall */

    double total = b + n + e + m + ed + h + s;
    if(total>100.0) total=100.0;
    if(total<0.0)   total=0.0;
    return (int)(total+0.5);
}

int scoreboard_is_unlocked(scoreboard_suite_t suite) {
    recompute_pass_percents();
    return is_suite_unlocked(suite);
}

void scoreboard_set_sc_mastered(scheduler_alg_t alg) {
    switch(alg) {
    case ALG_FIFO:          gSB.sc_fifo      = 1; break;
    case ALG_RR:            gSB.sc_rr        = 1; break;
    case ALG_CFS:           gSB.sc_cfs       = 1; break;
    case ALG_CFS_SRTF:      gSB.sc_cfs_srtf  = 1; break;
    case ALG_BFS:           gSB.sc_bfs       = 1; break;
    case ALG_SJF:           gSB.sc_sjf       = 1; break;
    case ALG_STRF:          gSB.sc_strf      = 1; break;
    case ALG_HRRN:          gSB.sc_hrrn      = 1; break;
    case ALG_HRRN_RT:       gSB.sc_hrrn_rt   = 1; break;
    case ALG_PRIORITY:      gSB.sc_priority  = 1; break;
    case ALG_HPC_OVERSHADOW:gSB.sc_hpc_over  = 1; break;
    case ALG_MLFQ:          gSB.sc_mlfq      = 1; break;
    default:                break;
    }
}

void scoreboard_update_basic(int total, int pass) {
    gSB.basic_total += total;
    gSB.basic_pass  += pass;
}
void scoreboard_update_normal(int total, int pass) {
    gSB.normal_total += total;
    gSB.normal_pass  += pass;
}
void scoreboard_update_external(int total,int pass) {
    gSB.external_total += total;
    gSB.external_pass  += pass;
}
void scoreboard_update_modes(int total,int pass) {
    gSB.modes_total += total;
    gSB.modes_pass  += pass;
}
void scoreboard_update_edge(int total,int pass) {
    gSB.edge_total += total;
    gSB.edge_pass  += pass;
}
void scoreboard_update_hidden(int total,int pass) {
    gSB.hidden_total += total;
    gSB.hidden_pass  += pass;
}
#ifndef SCOREBOARD_H
#define SCOREBOARD_H

#include "scheduler.h"

/* Enum to identify a test suite. */
typedef enum {
    SUITE_BASIC = 0,
    SUITE_NORMAL,
    SUITE_EXTERNAL,
    SUITE_MODES,
    SUITE_EDGE,
    SUITE_HIDDEN,
    SUITE_COUNT
} scoreboard_suite_t;

/*
  Structure for scoreboard data.
*/
typedef struct {
    int basic_total,    basic_pass;
    int normal_total,   normal_pass;
    int external_total, external_pass;
    int modes_total,    modes_pass;
    int edge_total,     edge_pass;
    int hidden_total,   hidden_pass;

    /* Mastery flags for scheduling algorithms. */
    int sc_fifo, sc_rr, sc_cfs, sc_cfs_srtf, sc_bfs;
    int sc_sjf, sc_strf, sc_hrrn, sc_hrrn_rt, sc_priority;
    int sc_hpc_over, sc_mlfq;

    double basic_percent;
    double normal_percent;
    double external_percent;
    double modes_percent;
    double edge_percent;
    double hidden_percent;

    double pass_threshold;
} scoreboard_t;

/* Initialize scoreboard (no-op). */
void scoreboard_init(void);

/* Close scoreboard (no-op). */
void scoreboard_close(void);

/* Load from scoreboard.json -> internal scoreboard. */
void scoreboard_load(void);

/* Save scoreboard -> scoreboard.json. */
void scoreboard_save(void);

/* Clear scoreboard entirely. */
void scoreboard_clear(void);

/* Retrieve scoreboard snapshot. */
void get_scoreboard(scoreboard_t* out);

/* Returns final overall score (0..100). */
int  scoreboard_get_final_score(void);

/* Mark that we have "mastered" a scheduling algorithm. */
void scoreboard_set_sc_mastered(scheduler_alg_t alg);

/* Update raw counts for each test suite. */
void scoreboard_update_basic(int total, int pass);
void scoreboard_update_normal(int total, int pass);
void scoreboard_update_external(int total,int pass);
void scoreboard_update_modes(int total,int pass);
void scoreboard_update_edge(int total,int pass);
void scoreboard_update_hidden(int total,int pass);

/* Check if suite is unlocked (pass% >= pass_threshold). */
int scoreboard_is_unlocked(scoreboard_suite_t suite);

#endif
#include "stats.h"
#include <stdio.h>
#include <string.h>

static stats_t g_stats;

void stats_init(void) {
    memset(&g_stats, 0, sizeof(g_stats));
    g_stats.speed_mode = 0; /* default normal mode */
}

void stats_get(stats_t* out) {
    if(out) {
        *out = g_stats;
    }
}

void stats_set_speed_mode(int mode) {
    g_stats.speed_mode = (mode != 0) ? 1 : 0;
}

int stats_get_speed_mode(void) {
    return g_stats.speed_mode;
}

void stats_inc_signal_sigint(void) {
    g_stats.signals_received_sigint++;
}
void stats_inc_signal_sigterm(void) {
    g_stats.signals_received_sigterm++;
}
void stats_inc_signal_other(void) {
    g_stats.signals_received_others++;
}
void stats_inc_concurrency_runs(void) {
    g_stats.concurrency_runs++;
}
void stats_inc_processes_spawned(void) {
    g_stats.processes_spawned++;
}
void stats_inc_containers_created(void) {
    g_stats.containers_created++;
}
void stats_inc_containers_removed(void) {
    g_stats.containers_removed++;
}
void stats_inc_tests_passed(int count) {
    g_stats.tests_passed += count;
}
void stats_inc_tests_failed(int count) {
    g_stats.tests_failed += count;
}

void stats_print_summary(void) {
    printf("╔═══════════════════ STATS ═════════════════╗\n");
    printf("║ Speed Mode            : %s\n", g_stats.speed_mode ? "FAST" : "NORMAL");
    printf("║ Signals (SIGINT)      : %d\n", g_stats.signals_received_sigint);
    printf("║ Signals (SIGTERM)     : %d\n", g_stats.signals_received_sigterm);
    printf("║ Signals (Others)      : %d\n", g_stats.signals_received_others);
    printf("║ Concurrency Runs      : %d\n", g_stats.concurrency_runs);
    printf("║ Processes Spawned     : %d\n", g_stats.processes_spawned);
    printf("║ Containers Created    : %d\n", g_stats.containers_created);
    printf("║ Containers Removed    : %d\n", g_stats.containers_removed);
    printf("║ Tests Passed          : %d\n", g_stats.tests_passed);
    printf("║ Tests Failed          : %d\n", g_stats.tests_failed);
    printf("╚═══════════════════════════════════════════╝\n");
}
#ifndef STATS_H
#define STATS_H

/* Colors for ASCII art convenience. */
#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GREEN   "\033[92m"
#define CLR_GRAY    "\033[90m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

/*
   stats.h => a global struct tracking concurrency usage, signals, tests, etc.
*/

typedef struct {
    int signals_received_sigint;
    int signals_received_sigterm;
    int signals_received_others;

    int concurrency_runs;
    int processes_spawned;
    int containers_created;
    int containers_removed;

    int tests_passed;
    int tests_failed;

    /* speed_mode: 0 => normal, 1 => fast */
    int speed_mode;
} stats_t;

/* Initialize. */
void stats_init(void);

/* Get the global stats. */
void stats_get(stats_t* out);

/* set speed_mode (0 or 1). */
void stats_set_speed_mode(int mode);

/* get speed_mode. */
int stats_get_speed_mode(void);

/* increments. */
void stats_inc_signal_sigint(void);
void stats_inc_signal_sigterm(void);
void stats_inc_signal_other(void);
void stats_inc_concurrency_runs(void);
void stats_inc_processes_spawned(void);
void stats_inc_containers_created(void);
void stats_inc_containers_removed(void);
void stats_inc_tests_passed(int count);
void stats_inc_tests_failed(int count);

/* Print them in a block. */
void stats_print_summary(void);

#endif
#include "worker.h"
#include "stats.h"
#include <stdio.h>
#include <unistd.h>

#define CLR_RESET "\033[0m"
#define CLR_BOLD  "\033[1m"
#define CLR_BLUE  "\033[94m"

/* scaled sleep to reflect the timeslice in real-time. */
static void sim_sleep(unsigned int us){
    int sm = stats_get_speed_mode();
    if(sm==1){
        usleep(us/10 + 1);
    } else {
        usleep(us);
    }
}

/* Provide partial CPU usage simulation. */
void simulate_process_partial(process_t* p, unsigned long slice_ms, int core_id) {
    if(!p || slice_ms==0) return;
    if(stats_get_speed_mode()==0) {
        printf(CLR_BLUE "[Worker] Core=%d => Partial run => priority=%d, slice=%lu ms\n" CLR_RESET,
               core_id, p->priority, slice_ms);
    }
    unsigned int real_us = (unsigned int)(slice_ms * 220000);
    sim_sleep(real_us);
}
#ifndef WORKER_H
#define WORKER_H

#include "process.h"

/*
  Worker simulation => runs a process for some (partial) timeslice
  by sleeping that many ms in real-time (scaled for concurrency).
*/

void simulate_process_partial(process_t* p, unsigned long slice_ms, int core_id);

#endif
#include "basic-test.h"
#include "test_common.h"

#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include "../src/worker.h"

#include <stdio.h>
#include <math.h>

static int tests_run=0, tests_failed=0;
static char g_test_fail_reason[256];

static int almost_equal(double a, double b, double eps) {
    return (fabs(a - b) < eps);
}

/* We define all test functions here (no forward declarations needed). */

TEST(fifo) {
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 1, 0);
    init_process(&p[1], 5, 1, 0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.5, t=5.5, r=1.5;
    if (!almost_equal(rep.avg_wait, w, 0.01) ||
        !almost_equal(rep.avg_turnaround, t, 0.01) ||
        !almost_equal(rep.avg_response, r, 0.01) ||
        rep.preemptions != 0ULL) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_fifo => mismatch, got W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_FIFO);
    return true;
}

TEST(rr) {
    os_init();
    process_t p[2];
    init_process(&p[0], 2, 1, 0);
    init_process(&p[1], 2, 1, 0);

    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.0, t=3.0, r=1.0;
    if (!almost_equal(rep.avg_wait, w, 0.01) ||
        !almost_equal(rep.avg_turnaround, t, 0.01) ||
        !almost_equal(rep.avg_response, r, 0.01) ||
        rep.preemptions != 0ULL) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_rr => mismatch, got W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_RR);
    return true;
}

TEST(cfs) {
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 0, 0);
    init_process(&p[1], 4, 0, 0);

    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.5, t=5.0, r=1.5;
    if (!almost_equal(rep.avg_wait, w, 0.01) ||
        !almost_equal(rep.avg_turnaround, t, 0.01) ||
        !almost_equal(rep.avg_response, r, 0.01) ||
        rep.preemptions != 0ULL) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_cfs => mismatch, got W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS);
    return true;
}

TEST(bfs) {
    os_init();
    process_t p[3];
    init_process(&p[0], 2, 1, 0);
    init_process(&p[1], 3, 1, 0);
    init_process(&p[2], 4, 1, 0);

    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p, 3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.total_procs != 3 || rep.preemptions < 1) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_bfs => mismatch => expected procs=3, preempt>0, got procs=%llu, preempts=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_BFS);
    return true;
}

TEST(pipeline) {
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}

TEST(distributed) {
    os_init();
    os_run_distributed_example();
    os_cleanup();
    return true;
}

TEST(fifo_strict) {
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 10, 0);
    init_process(&p[1], 4, 20, 0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.5, t=5.0, r=1.5;
    if (!almost_equal(rep.avg_wait, w, 0.01) ||
        !almost_equal(rep.avg_turnaround, t, 0.01) ||
        !almost_equal(rep.avg_response, r, 0.01) ||
        rep.preemptions != 0ULL) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_fifo_strict => mismatch => W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    return true;
}

void run_basic_tests(int* total, int* passed){
    tests_run=0;
    tests_failed=0;

    printf("\n" CLR_BOLD CLR_YELLOW "╔════════════ BASIC TESTS START ═════════════╗" CLR_RESET "\n");

    RUN_TEST(fifo);
    RUN_TEST(rr);
    RUN_TEST(cfs);
    RUN_TEST(bfs);
    RUN_TEST(pipeline);
    RUN_TEST(distributed);
    RUN_TEST(fifo_strict);

    *total  = tests_run;
    *passed = (tests_run - tests_failed);

    /* Show final block. */
    printf(CLR_BOLD CLR_YELLOW "╔══════════════════════════════════════════════╗\n");
    printf("║       BASIC TESTS RESULTS: %d / %d passed      ║\n", *passed, *total);
    if(*passed < *total) {
        printf("║    FAILURES => see above logs for reasons    ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\n" CLR_RESET);
}
#ifndef BASIC_TEST_H
#define BASIC_TEST_H

/*
  Basic tests: FIFO, RR, CFS, BFS, pipeline, distributed, etc.
  We also provide single-test picking if needed.
*/

void run_basic_tests(int* total,int* passed);

#endif
#include "edge-test.h"
#include "test_common.h"

#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int tests_run=0, tests_failed=0;
static char g_test_fail_reason[256];

static int almost_equal(double a, double b, double eps) {
    return (fabs(a - b) < eps);
}

TEST(extreme_long) {
    os_init();
    process_t p[1];
    init_process(&p[0],50,2,0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.total_procs!=1 || rep.preemptions!=0ULL) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_extreme_long => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    if (!almost_equal(rep.avg_wait, 0.0, 0.001) ||
        !almost_equal(rep.avg_turnaround, 50.0, 0.1)) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_extreme_long => stats mismatch => W=%.2f,T=%.2f",
                 rep.avg_wait, rep.avg_turnaround);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    return true;
}

TEST(extreme_short) {
    os_init();
    process_t p[1];
    init_process(&p[0],1,2,0);

    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.total_procs!=1 || rep.preemptions!=0ULL) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_extreme_short => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    if (!almost_equal(rep.avg_wait, 0.0, 0.001) ||
        !almost_equal(rep.avg_turnaround, 1.0, 0.01)) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_extreme_short => stats mismatch => W=%.2f,T=%.2f",
                 rep.avg_wait, rep.avg_turnaround);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    return true;
}

TEST(high_load) {
    os_init();
    process_t arr[10];
    for (int i=0; i<10; i++) {
        init_process(&arr[i], 3+(i%3), 1, 0);
    }
    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(arr,10);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.total_procs != 10) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_high_load => mismatch => total=%llu, expected=10",
                 rep.total_procs);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    return true;
}

TEST(hpc_under_load) {
    os_init();
    os_run_hpc_overshadow();
    os_cleanup();
    return true;
}

TEST(container_spam) {
    os_init();
    for (int i=0;i<3;i++) {
        os_create_ephemeral_container();
    }
    for (int i=0;i<3;i++) {
        os_remove_ephemeral_container();
    }
    os_cleanup();
    return true;
}

TEST(pipeline_edge) {
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}

TEST(multi_distrib) {
    os_init();
    for (int i=0;i<3;i++) {
        os_run_distributed_example();
    }
    os_cleanup();
    return true;
}

void run_edge_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    printf("\n\033[1m\033[93m╔════════════ EDGE TESTS START ═══════════╗\033[0m\n");

    RUN_TEST(extreme_long);
    RUN_TEST(extreme_short);
    RUN_TEST(high_load);
    RUN_TEST(hpc_under_load);
    RUN_TEST(container_spam);
    RUN_TEST(pipeline_edge);
    RUN_TEST(multi_distrib);

    *total=tests_run;
    *passed=(tests_run - tests_failed);

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║      EDGE TESTS RESULTS: %d / %d passed        ║\n", *passed, *total);
    if(*passed < *total) {
        printf("║    FAILURES => see above logs for reasons    ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef EDGE_TEST_H
#define EDGE_TEST_H

/* Edge tests: extreme bursts, HPC under load, container spam, pipeline, etc. */

void run_edge_tests(int* total,int* passed);

#endif
#include "external-test.h"
#include "test_common.h"

#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/scoreboard.h"
#include "../src/runner.h"

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;
static char g_test_fail_reason[256];

/* Prototypes for local test functions: */
static bool test_external_hpc(void);
static bool test_external_bfs(void);
static bool test_run_shell_concurrency(void);

/* We do not forward-declare the run tests in .c if they're used below this point.
   We'll define them before usage. */

static bool test_external_hpc(void)
{
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    tests_run++;
    if(rep.total_procs!=0){
        tests_failed++;
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_external_hpc => expected total_procs=0, got %llu",
                 (unsigned long long)rep.total_procs);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    return true;
}

static bool test_external_bfs(void)
{
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    tests_run++;
    if(rep.total_procs!=2 || rep.preemptions<1){
        tests_failed++;
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_external_bfs => mismatch => procs=%llu, preempt=%llu",
                 (unsigned long long)rep.total_procs,
                 (unsigned long long)rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    return true;
}

static bool test_run_shell_concurrency(void)
{
    tests_run++;
    int count=2;
    char* lines[2];
    lines[0] = "sleep 2";
    lines[1] = "sleep 3";

    /* single core, FIFO mode => run concurrency => pass if no crash. */
    run_shell_commands_concurrently(count, lines, 1, ALG_FIFO, 0);
    return true;
}

void run_external_tests(void)
{
    printf("\n\033[1m\033[93m╔═════════ EXTERNAL TESTS START ═════════╗\033[0m\n");

    /* We'll run all external tests here. */
    tests_run=0;
    tests_failed=0;

    bool ok1 = test_external_hpc();
    bool ok2 = test_external_bfs();
    bool ok3 = test_run_shell_concurrency();

    scoreboard_update_external(tests_run, (tests_run - tests_failed));
    scoreboard_save();

    printf("\033[1m\033[93m╔════════════════════════════════════════════╗\n");
    printf("║   EXTERNAL TESTS RESULTS: %d / %d passed     ║\n", (tests_run - tests_failed), tests_run);
    if(tests_failed>0) {
        printf("║   FAILURES => see reason above logs        ║\n");
    }
    printf("╚════════════════════════════════════════════╝\033[0m\n");
}
#ifndef EXTERNAL_TEST_H
#define EXTERNAL_TEST_H

/*
  External tests: HPC overshadow, BFS partial, concurrency.
*/

void run_external_tests(void);

#endif
#include "hidden-test.h"
#include "test_common.h"

#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int tests_run=0, tests_failed=0;
static char g_test_fail_reason[256];

static int almost_equal(double a, double b, double eps){
    return fabs(a - b) < eps;
}

TEST(distrib_heavy) {
    os_init();
    for(int i=0;i<4;i++){
        os_run_distributed_example();
    }
    os_cleanup();
    return true;
}

TEST(hpc_heavy) {
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0,0,0);

    for(int i=0;i<2;i++){
        scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
        scheduler_run(dummy,1);
        sched_report_t rep;
        scheduler_fetch_report(&rep);
        if(rep.total_procs != 0){
            snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                     "test_hpc_heavy => overshadow => expected 0 procs, got %llu",
                     rep.total_procs);
            test_set_fail_reason(g_test_fail_reason);
            os_cleanup();
            return false;
        }
    }
    os_cleanup();
    return true;
}

TEST(container_combo) {
    os_init();
    os_create_ephemeral_container();
    os_run_distributed_example();
    os_run_hpc_overshadow();
    os_remove_ephemeral_container();
    os_cleanup();
    return true;
}

TEST(scheduling_variety) {
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,0);
    init_process(&p[1],6,2,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs!=2 || r1.preemptions!=0ULL){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_scheduling_variety => SJF => mismatch => total=%llu, pre=%llu",
                 r1.total_procs, r1.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        os_cleanup();
        return false;
    }

    init_process(&p[0],2,3,0);
    init_process(&p[1],6,1,0);
    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,2);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    os_cleanup();

    if(r2.total_procs!=2 || r2.preemptions!=0ULL){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_scheduling_variety => Priority => mismatch => total=%llu, pre=%llu",
                 r2.total_procs, r2.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }

    return true;
}

TEST(auto_logic) {
    /* dummy => pass */
    return true;
}

TEST(final_integration) {
    os_init();
    os_log("Final synergy HPC + container + pipeline + distributed");
    os_create_ephemeral_container();
    os_run_hpc_overshadow();
    os_run_distributed_example();
    os_pipeline_example();
    os_remove_ephemeral_container();
    os_cleanup();
    return true;
}

TEST(multi_stage_distributed) {
    os_init();
    os_run_distributed_example();

    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs != 0){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_multi_stage_distributed => overshadow #1 => got %llu procs, expected 0",
                 r1.total_procs);
        test_set_fail_reason(g_test_fail_reason);
        os_cleanup();
        return false;
    }

    os_run_distributed_example();
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    os_cleanup();

    if(r2.total_procs != 0){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_multi_stage_distributed => overshadow #2 => got %llu procs, expected 0",
                 r2.total_procs);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    return true;
}

void run_hidden_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    printf("\n\033[1m\033[93m╔══════════ HIDDEN TESTS START ══════════╗\033[0m\n");

    RUN_TEST(distrib_heavy);
    RUN_TEST(hpc_heavy);
    RUN_TEST(container_combo);
    RUN_TEST(scheduling_variety);
    RUN_TEST(auto_logic);
    RUN_TEST(final_integration);
    RUN_TEST(multi_stage_distributed);

    *total = tests_run;
    *passed= (tests_run - tests_failed);

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║      HIDDEN TESTS RESULTS: %d / %d passed       ║\n", *passed, *total);
    if(*passed < *total) {
        printf("║    FAILURES => see above logs for reasons    ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef HIDDEN_TEST_H
#define HIDDEN_TEST_H

/* Hidden tests: synergy HPC + containers + distributed, advanced scheduling variety, etc. */

void run_hidden_tests(int* total,int* passed);

#endif
#include "modes-test.h"
#include "test_common.h"

#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/process.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int tests_run=0, tests_failed=0;
static char g_test_fail_reason[256];

static int almost_equal(double a, double b, double eps) {
    return (fabs(a - b) < eps);
}

TEST(hpc_over) {
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy, 1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.total_procs != 0 || rep.preemptions != 0ULL ||
        rep.avg_wait != 0.0 || rep.avg_turnaround != 0.0 || rep.avg_response != 0.0) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_hpc_over => HPC overshadow => expected 0 stats, got procs=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HPC_OVERSHADOW);
    return true;
}

TEST(multi_containers) {
    os_init();
    for (int i=0; i<2; i++) os_create_ephemeral_container();
    for (int i=0; i<2; i++) os_remove_ephemeral_container();
    os_cleanup();
    return true;
}

TEST(multi_distrib) {
    os_init();
    os_run_distributed_example();
    os_run_distributed_example();
    os_cleanup();
    return true;
}

TEST(pipeline_modes) {
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}

TEST(mix_algos) {
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);
    sched_report_t r1;
    scheduler_fetch_report(&r1);

    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,2);
    sched_report_t r2;
    scheduler_fetch_report(&r2);

    os_cleanup();

    if (r1.total_procs != 2 || r1.preemptions != 0ULL) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_mix_algos => FIFO part => mismatch => total=%llu, pre=%llu",
                 r1.total_procs, r1.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    if (r2.total_procs != 2 || r2.preemptions < 1) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_mix_algos => BFS part => mismatch => total=%llu, preempts=%llu",
                 r2.total_procs, r2.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    return true;
}

TEST(double_hpc) {
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r1;
    scheduler_fetch_report(&r1);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r2;
    scheduler_fetch_report(&r2);

    os_cleanup();

    if (r1.total_procs != 0 || r2.total_procs != 0) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_double_hpc => overshadow => expected 0 procs, got r1=%llu,r2=%llu",
                 r1.total_procs, r2.total_procs);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    return true;
}

TEST(mlfq_check) {
    os_init();
    process_t p[3];
    init_process(&p[0],2,10,0);
    init_process(&p[1],3,20,0);
    init_process(&p[2],4,30,0);

    scheduler_select_algorithm(ALG_MLFQ);
    scheduler_run(p,3);

    sched_report_t r;
    scheduler_fetch_report(&r);
    os_cleanup();

    if (r.total_procs != 3 || r.preemptions < 1) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_mlfq_check => mismatch => total=%llu, preempt=%llu",
                 r.total_procs, r.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_MLFQ);
    return true;
}

void run_modes_tests(int* total, int* passed) {
    tests_run   = 0;
    tests_failed= 0;

    printf("\n\033[1m\033[93m╔══════════ MODES TESTS START ══════════╗\033[0m\n");

    RUN_TEST(hpc_over);
    RUN_TEST(multi_containers);
    RUN_TEST(multi_distrib);
    RUN_TEST(pipeline_modes);
    RUN_TEST(mix_algos);
    RUN_TEST(double_hpc);
    RUN_TEST(mlfq_check);

    *total  = tests_run;
    *passed = tests_run - tests_failed;

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║       MODES TESTS RESULTS: %d / %d passed       ║\n", *passed, *total);
    if(*passed < *total) {
        printf("║    FAILURES => see above logs for reasons    ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef MODES_TEST_H
#define MODES_TEST_H

/* Modes test: HPC overshadow, BFS, MLFQ, pipeline, containers, etc.*/

void run_modes_tests(int* total,int* passed);

#endif
#include "normal-test.h"
#include "test_common.h"

#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/os.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int tests_run=0, tests_failed=0;
static char g_test_fail_reason[256];

static int almost_equal(double a, double b, double eps) {
    return (fabs(a-b) < eps);
}
static bool check_stats(const sched_report_t* r, double w, double t, double resp,
                        unsigned long long pre, double eps)
{
    if (!almost_equal(r->avg_wait, w, eps)) return false;
    if (!almost_equal(r->avg_turnaround, t, eps)) return false;
    if (!almost_equal(r->avg_response, resp, eps)) return false;
    if (r->preemptions != pre) return false;
    return true;
}

TEST(sjf) {
    os_init();
    process_t p[3];
    init_process(&p[0],1,1,0);
    init_process(&p[1],5,1,0);
    init_process(&p[2],2,1,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* sum waits => 0+1+3=4 => avg=1.33..., sum TAT => 1+3+8=12 => avg=4.0 */
    if (!check_stats(&rep, 1.3333, 4.0, 1.3333, 0ULL, 0.02)) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_sjf => mismatch => W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_SJF);
    return true;
}

TEST(strf) {
    os_init();
    process_t p[2];
    init_process(&p[0],4,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_STRF);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.total_procs != 2 || rep.preemptions < 1) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_strf => mismatch => procs=%llu, preempt=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_STRF);
    return true;
}

TEST(hrrn) {
    os_init();
    process_t p[3];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    init_process(&p[2],4,1,0);

    scheduler_select_algorithm(ALG_HRRN);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.total_procs != 3 || rep.preemptions != 0ULL) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_hrrn => mismatch => total=%llu, preempt=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN);
    return true;
}

TEST(hrrn_rt) {
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,0);
    init_process(&p[1],4,1,0);

    scheduler_select_algorithm(ALG_HRRN_RT);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.total_procs!=2 || rep.preemptions<1) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_hrrn_rt => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN_RT);
    return true;
}

TEST(priority_test) {
    os_init();
    process_t p[3];
    init_process(&p[0],2,3,0);
    init_process(&p[1],2,1,0);
    init_process(&p[2],2,2,0);

    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=2.0, t=4.0, r=2.0;
    if (!almost_equal(rep.avg_wait, w, 0.01) ||
        !almost_equal(rep.avg_turnaround, t, 0.01) ||
        !almost_equal(rep.avg_response, r, 0.01) ||
        rep.preemptions != 0ULL) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_priority => mismatch => W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_PRIORITY);
    return true;
}

TEST(cfs_srtf) {
    os_init();
    process_t p[3];
    init_process(&p[0],2,1,0);
    init_process(&p[1],4,1,0);
    init_process(&p[2],6,1,0);

    scheduler_select_algorithm(ALG_CFS_SRTF);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.total_procs!=3 || rep.preemptions<1) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_cfs_srtf => mismatch => total=%llu, preempt=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS_SRTF);
    return true;
}

TEST(sjf_strict) {
    os_init();
    process_t p[2];
    init_process(&p[0],2,10,0);
    init_process(&p[1],5,20,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.0, t=4.5, r=1.0;
    if (!almost_equal(rep.avg_wait, w, 0.01) ||
        !almost_equal(rep.avg_turnaround, t, 0.01) ||
        !almost_equal(rep.avg_response, r, 0.01) ||
        rep.preemptions != 0ULL) {
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "test_sjf_strict => mismatch => got W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_test_fail_reason);
        return false;
    }
    return true;
}

void run_normal_tests(int* total, int* passed) {
    tests_run  = 0;
    tests_failed = 0;

    printf("\n\033[1m\033[93m╔══════════ NORMAL TESTS START ══════════╗\033[0m\n");

    RUN_TEST(sjf);
    RUN_TEST(strf);
    RUN_TEST(hrrn);
    RUN_TEST(hrrn_rt);
    RUN_TEST(priority_test);
    RUN_TEST(cfs_srtf);
    RUN_TEST(sjf_strict);

    *total  = tests_run;
    *passed = tests_run - tests_failed;

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║      NORMAL TESTS RESULTS: %d / %d passed       ║\n", *passed, *total);
    if(*passed < *total) {
        printf("║    FAILURES => see above logs for reasons    ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef NORMAL_TEST_H
#define NORMAL_TEST_H

/* Normal tests: SJF, STRF, HRRN, HRRN-RT, PRIORITY, CFS-SRTF, etc. */

void run_normal_tests(int* total,int* passed);

#endif
#include "test_common.h"
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <errno.h>
#include <stdarg.h>

static char g_fail_reason[256] = {0};

void test_set_fail_reason(const char* msg) {
    if(!msg) {
        g_fail_reason[0] = '\0';
        return;
    }
    strncpy(g_fail_reason, msg, sizeof(g_fail_reason)-1);
    g_fail_reason[sizeof(g_fail_reason)-1] = '\0';
}

const char* test_get_fail_reason(void) {
    if(g_fail_reason[0] == '\0') {
        return "???";
    }
    return g_fail_reason;
}

static ssize_t read_all_fd(int fd, char* buf, size_t cap) {
    size_t used = 0;
    while(used + 1 < cap) {
        ssize_t r = read(fd, buf + used, cap - 1 - used);
        if(r < 0 && errno == EINTR) continue;
        if(r <= 0) break;
        used += (size_t)r;
    }
    buf[used] = '\0';
    return (ssize_t)used;
}

int run_function_capture_output(void(*fn)(void), struct captured_output* out) {
    if(!fn || !out) return -1;
    int p_out[2], p_err[2];
    if(pipe(p_out)==-1 || pipe(p_err)==-1) return -1;
    int save_out = dup(STDOUT_FILENO);
    int save_err = dup(STDERR_FILENO);
    if(save_out<0 || save_err<0) return -1;

    pid_t c = fork();
    if(c<0) {
        return -1;
    }
    if(c==0) {
        close(p_out[0]);
        close(p_err[0]);
        dup2(p_out[1], STDOUT_FILENO);
        dup2(p_err[1], STDERR_FILENO);
        close(p_out[1]);
        close(p_err[1]);

        fn();
        _exit(0);
    } else {
        close(p_out[1]);
        close(p_err[1]);
        read_all_fd(p_out[0], out->stdout_buf, sizeof(out->stdout_buf));
        read_all_fd(p_err[0], out->stderr_buf, sizeof(out->stderr_buf));
        close(p_out[0]);
        close(p_err[0]);

        dup2(save_out, STDOUT_FILENO);
        dup2(save_err, STDERR_FILENO);
        close(save_out);
        close(save_err);

        int st=0;
        waitpid(c,&st,0);
        return st;
    }
    return 0;
}
#ifndef TEST_COMMON_H
#define TEST_COMMON_H

#include <stdbool.h>

/* Colors for ASCII art convenience. */
#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GREEN   "\033[92m"
#define CLR_GRAY    "\033[90m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

/* Provide a macro for test definitions and a reason buffer. */

void test_set_fail_reason(const char* msg);
const char* test_get_fail_reason(void);

struct captured_output {
  char stdout_buf[8192];
  char stderr_buf[8192];
};

/*
  run_function_capture_output():
    Creates pipes, forks, runs fn() in child, captures output in out.
*/
int run_function_capture_output(void(*fn)(void), struct captured_output* out);

#define TEST(name) static bool test_##name(void)

/* RUN_TEST macro to unify pass/fail printing. */
#define RUN_TEST(name) do {                                    \
bool ok = test_##name();                                   \
tests_run++;                                               \
if(!ok){                                                   \
tests_failed++;                                        \
printf("  FAIL: %s => %s\n", #name, test_get_fail_reason()); \
} else {                                                   \
printf("  PASS: %s\n", #name);                         \
}                                                          \
} while(0)

#endif
