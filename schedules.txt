```c
/******************************************************************************
 * File: futex_deadlock.c
 *
 * Objectif :
 *   1) Illustrer un deadlock classique en C (pthreads) avec lockA, lockB.
 *   2) Démontrer un verrou "maison" basé sur futex() pour comprendre la synchro.
 *   3) Intégrer des "genius" commandes Bash pour diagnostiquer/arrêter proprement.
 *
 * Compilation :
 *   gcc -Wall -O0 -g futex_deadlock.c -o futex_deadlock -lpthread
 *     - -O0 (désactive optimisations, facilite le debug)
 *     - -g   (inclut symboles de debug pour GDB)
 *
 * Exécution standard (bloquante) :
 *   ./futex_deadlock
 *   -> Deadlock probable entre Thread1 et Thread2.
 *
 * Éviter un blocage permanent (Timeout) :
 *   timeout 5s ./futex_deadlock
 *   -> Tue le programme après 5s si encore bloqué.
 *
 * Diagnostics Bash “Genius” en Temps Réel :
 *
 *   1) Repérer le PID du process :
 *      ps -ef | grep futex_deadlock  # ou pgrep futex_deadlock
 *
 *   2) Attacher strace pour voir les appels système en direct :
 *      strace -p $(pgrep futex_deadlock) -s 100 -T -o trace.log
 *      - -s 100 : capture jusqu'à 100 caractères par appel
 *      - -T     : affiche le temps passé dans chaque appel
 *      - -o trace.log : redirige la sortie vers un fichier
 *
 *   3) Afficher les piles de chaque thread (si pstack est disponible) :
 *      pstack $(pgrep futex_deadlock)
 *      - Montre instantanément où chaque thread est bloqué
 *
 *   4) GDB : attacher, observer, modifier l’exécution :
 *      gdb -p $(pgrep futex_deadlock) -ex "thread apply all bt"
 *      - Accès direct aux backtraces de tous les threads
 *      - Possibilité de "break pthread_mutex_lock" (si lancé depuis le début)
 *
 *   5) Script de surveillance, kill automatique si bloqué (exemple) :
 *      #!/bin/bash
 *      # monitor_deadlock.sh
 *      PID=$(pgrep futex_deadlock)
 *      while kill -0 "$PID" 2>/dev/null; do
 *        echo "Process $PID alive..."
 *        sleep 2
 *        # pstack $PID
 *      done
 *      echo "Process terminé ou tué."
 *
 * Prévention du deadlock (conseils rapides) :
 *   - Ordre cohérent de prise de locks (ex. lockA puis lockB partout).
 *   - pthread_mutex_timedlock() au lieu de pthread_mutex_lock().
 *   - Sections critiques courtes, éviter la double acquisition imbriquée.
 *   - Logs, asserts, ou breakpoints GDB pour surveiller l’ordre de verrouillage.
 *****************************************************************************/

#define _GNU_SOURCE  /* Nécessaire pour SYS_futex */
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <linux/futex.h>
#include <signal.h>

/* ------------------------------ Deadlock Pthread ------------------------------
 * Thread 1 : lockA -> sleep(1) -> lockB
 * Thread 2 : lockB -> sleep(1) -> lockA
 * => Attente mutuelle : chacun bloque l’autre.
 */
pthread_mutex_t lockA = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t lockB = PTHREAD_MUTEX_INITIALIZER;

void* threadFunc1(void* arg) {
    pthread_mutex_lock(&lockA);  // T1 détient lockA
    sleep(1);                    // Permet à T2 de prendre lockB
    pthread_mutex_lock(&lockB);  // Bloqué si T2 a lockB

    printf("[Thread 1] a acquis A+B (uniquement si pas de deadlock)\n");
    pthread_mutex_unlock(&lockB);
    pthread_mutex_unlock(&lockA);
    return NULL;
}

void* threadFunc2(void* arg) {
    pthread_mutex_lock(&lockB);  // T2 détient lockB
    sleep(1);                    // Permet à T1 de prendre lockA
    pthread_mutex_lock(&lockA);  // Bloqué si T1 a lockA

    printf("[Thread 2] a acquis B+A (uniquement si pas de deadlock)\n");
    pthread_mutex_unlock(&lockA);
    pthread_mutex_unlock(&lockB);
    return NULL;
}

/* ------------------------------ Futex Lock Maison ------------------------------
 * - futex_var = 0 => libre, 1 => verrouillé.
 * - Utilise l’appel système futex(FUTEX_WAIT,FUTEX_WAKE).
 */
static int futex_var = 0;

/* Bloquer le thread tant que *addr == val */
static int futex_wait(int *addr, int val) {
    return syscall(SYS_futex, addr, FUTEX_WAIT, val, NULL, NULL, 0);
}

/* Réveiller 'count' threads bloqués sur *addr */
static int futex_wake(int *addr, int count) {
    return syscall(SYS_futex, addr, FUTEX_WAKE, count, NULL, NULL, 0);
}

/* Tente de passer fvar de 0->1 (test_and_set). Si déjà 1, on attend futex. */
static void futex_lock(int *fvar) {
    while (__sync_lock_test_and_set(fvar, 1) != 0) {
        futex_wait(fvar, 1);
    }
}

/* Libérer (fvar=0), réveiller un thread en attente */
static void futex_unlock(int *fvar) {
    __sync_lock_release(fvar);
    futex_wake(fvar, 1);
}

/* -------------------------------- Main --------------------------------
 * - Lance 2 threads => deadlock sur lockA/lockB.
 * - Teste en parallèle le lock futex (non deadlock).
 * - Joins bloqués si le deadlock est effectif.
 */
int main(void) {
    /*
     * Pour auto-kill après 5s (côté C) :
     * signal(SIGALRM, [](int){ fprintf(stderr,"[ALARM] Deadlock suspecté.\n"); _exit(1); });
     * alarm(5);
     *
     * Equivalent Bash :
     *   timeout 5s ./futex_deadlock
     */

    pthread_t t1, t2;
    pthread_create(&t1, NULL, threadFunc1, NULL);
    pthread_create(&t2, NULL, threadFunc2, NULL);

    /* Verrou futex en parallèle : pas de deadlock ici */
    sleep(1);
    printf("[Main] Tente d'acquérir futex_lock...\n");
    futex_lock(&futex_var);
    printf("[Main] futex_lock acquis!\n");
    sleep(2);
    futex_unlock(&futex_var);
    printf("[Main] futex_lock libéré!\n");

    pthread_join(t1, NULL);   // Bloquera si T1 ne libère jamais
    pthread_join(t2, NULL);   // Bloquera si T2 ne libère jamais
    return 0;
}
```

### Explications “Inline” + Commandes Bash “Genius” :

1. **Trouver le PID d’un programme bloqué**  
   ```bash
   pgrep futex_deadlock     # Récupère le PID simplement
   ```

2. **Attacher `strace` pour suivre les appels système en direct**  
   ```bash
   strace -p $(pgrep futex_deadlock) -s 100 -T -o trace.log
   # -s 100 : capture jusqu'à 100 caractères par appel (utile si arguments)
   # -T     : affiche le temps passé dans chaque appel
   # -o trace.log : enregistre la sortie dans un fichier
   ```

3. **Surveiller l’état des threads avec `pstack`**  
   ```bash
   pstack $(pgrep futex_deadlock)
   # Montre exactement la pile de chaque thread, révélant le point de blocage
   ```

4. **Analyser en profondeur avec GDB**  
   ```bash
   gdb -p $(pgrep futex_deadlock) -ex "thread apply all bt"
   # Se connecte au processus, exécute la commande "thread apply all bt"
   # Affiche les backtraces de tous les threads (montrant le lock bloquant).
   ```

5. **Combinaison Magic :** Lancer & Diagnostiquer en séquence  
   ```bash
   # 1) Lancer en arrière-plan
   ./futex_deadlock &
   sleep 2
   # 2) Surveiller en direct (strace + pstack)
   strace -p $(pgrep futex_deadlock) -T &
   sleep 2
   pstack $(pgrep futex_deadlock)
   ```

6. **Arrêter à la volée le programme**  
   ```bash
   kill $(pgrep futex_deadlock)
   # ou plus radical : kill -9 $(pgrep futex_deadlock)
   ```

7. **Script Bash de monitoring simplifié** (exemple)  
   ```bash
   # monitor_deadlock.sh
   #!/usr/bin/env bash
   PROCESS="./futex_deadlock"
   $PROCESS &             # Lance le process en arrière-plan
   PID=$!

   while kill -0 $PID 2>/dev/null; do
       echo "Process $PID is still running..."
       sleep 2
       # Optionnel: pstack $PID
   done

   echo "Process $PID terminated or killed."
   ```

### Conclusion

- Ce code **futex_deadlock.c** illustre la **source du deadlock** (ordre de prise de locks inversé).  
- Les commandes Bash “genius” décrites ci-dessus aident à **localiser**, **surveiller**, et **terminer** un processus bloqué.  
- Pour **prévenir** le deadlock, adoptez toujours un **ordre unique** d’acquisition de verrous, ou utilisez des verrous **temporisés**.  
- Si vous soupçonnez un blocage, **GDB**, **strace**, **pstack** et **timeout** sont des alliés précieux pour le **debug** en temps réel.