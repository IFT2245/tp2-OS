#include <sys/types.h>
#include <stdlib.h>
#include <string.h>

#include "main.h"
#include "runner.h"
#include "os.h"
#include "safe_calls_library.h"
#include "scoreboard.h"
#include "stats.h"

/* Each suite's public test functions */
#include <stdio.h>

#include "../test/basic-test.h"
#include "../test/normal-test.h"
#include "../test/modes-test.h"
#include "../test/edge-test.h"
#include "../test/hidden-test.h"
#include "../test/external-test.h"

/*
  Flag set by SIGTERM to stop concurrency or test suites
  but remain in the main menu.
*/
static volatile sig_atomic_t g_return_to_menu = 0;

/* The chain of suites we might unlock in order. */
static scoreboard_suite_t g_suite_chain[] = {
    SUITE_BASIC,
    SUITE_NORMAL,
    SUITE_EXTERNAL,
    SUITE_MODES,
    SUITE_EDGE,
    SUITE_HIDDEN
};
static const int g_suite_chain_count = 6;

/* ----------------------------------------------------------------
   PLATFORM-SPECIFIC CLEAR SCREEN
   ----------------------------------------------------------------
*/
void clear_screen(void) {
#if defined(_WIN32) || defined(_WIN64)
    system("cls");
#else
    system("clear");
#endif
}

/* ----------------------------------------------------------------
   Wait for ENTER so user can read output
   ----------------------------------------------------------------
*/
void pause_enter(void) {
    printf( CLR_CYAN CLR_BOLD"\nPress ENTER to continue..." CLR_RESET);
    fflush(stdout);
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        /* discard leftover */
    }
}

/* ----------------------------------------------------------------
   Read line safely from stdin
   ----------------------------------------------------------------
*/
int read_line(char *buf, size_t sz) {
    // If we've requested a return to menu, skip reading altogether
    if (g_return_to_menu) {
        return 0;  // signals "no input" so caller can exit
    }

    if (!fgets(buf, sz, stdin)) {
        return 0;  // error or EOF
    }

    buf[strcspn(buf, "\n")] = '\0'; // remove newline
    return 1;
}


/* ----------------------------------------------------------------
   Print the fancy main menu header + speed mode status
   ----------------------------------------------------------------
*/
void ascii_main_menu_header(void) {
    clear_screen();

    int sp = stats_get_speed_mode(); /* 0 => NORMAL, 1 => FAST */
    const char* sp_text = (sp == 0) ? "NORMAL" : "FAST";

    printf(CLR_BOLD CLR_YELLOW " ┌────────────────────────────────────────────┐\n" CLR_RESET);
    printf(CLR_BOLD CLR_YELLOW " │             OS-SCHEDULING GAME             │\n" CLR_RESET);
    printf(CLR_BOLD CLR_YELLOW " └────────────────────────────────────────────┘\n" CLR_RESET);
    printf(CLR_RED "     A concurrency and scheduling trainer   \n" CLR_RESET);
    printf(CLR_BOLD CLR_RED"          [Current Speed Mode: %s]\n\n" CLR_RESET, sp_text);
}

/* ----------------------------------------------------------------
   Display scoreboard with fancy ASCII framing + progress bar
   ----------------------------------------------------------------
*/
void menu_show_scoreboard(void) {
    scoreboard_t sb;
    get_scoreboard(&sb);

    int unlockedB      = scoreboard_is_unlocked(SUITE_BASIC);
    int unlockedN      = scoreboard_is_unlocked(SUITE_NORMAL);
    int unlockedExt    = scoreboard_is_unlocked(SUITE_EXTERNAL);
    int unlockedModes  = scoreboard_is_unlocked(SUITE_MODES);
    int unlockedEdge   = scoreboard_is_unlocked(SUITE_EDGE);
    int unlockedHidden = scoreboard_is_unlocked(SUITE_HIDDEN);

    clear_screen();
    printf(CLR_BOLD CLR_MAGENTA "╔════════════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_MAGENTA "║           ★ SCOREBOARD OVERVIEW ★          ║\n" CLR_RESET);
    printf("║--------------------------------------------║\n");

    printf("║ BASIC       => %.1f/100 => %s\n",
           sb.basic_percent,
           unlockedB ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ NORMAL      => %.1f/100 => %s\n",
           sb.normal_percent,
           unlockedN ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ EXTERNAL    => %.1f/100 => %s\n",
           sb.external_percent,
           unlockedExt ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ MODES       => %.1f/100 => %s\n",
           sb.modes_percent,
           unlockedModes ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ EDGE        => %.1f/100 => %s\n",
           sb.edge_percent,
           unlockedEdge ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ HIDDEN      => %.1f/100 => %s\n",
           sb.hidden_percent,
           unlockedHidden ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║--------------------------------------------║\n");
    printf("║  FIFO:%s RR:%s CFS:%s CFS-SRTF:%s BFS:%s\n",
           sb.sc_fifo? "✔":"✘",
           sb.sc_rr? "✔":"✘",
           sb.sc_cfs? "✔":"✘",
           sb.sc_cfs_srtf? "✔":"✘",
           sb.sc_bfs? "✔":"✘");
    printf("║  SJF:%s STRF:%s HRRN:%s HRRN-RT:%s PRIORITY:%s\n",
           sb.sc_sjf? "✔":"✘",
           sb.sc_strf? "✔":"✘",
           sb.sc_hrrn? "✔":"✘",
           sb.sc_hrrn_rt? "✔":"✘",
           sb.sc_priority? "✔":"✘");
    printf("║  HPC-OVER:%s MLFQ:%s\n",
           sb.sc_hpc_over? "✔":"✘",
           sb.sc_mlfq? "✔":"✘");

    const int final_score = scoreboard_get_final_score();
    printf("║--------------------------------------------║\n");
    printf("╠═"CLR_BOLD CLR_CYAN" Overall Score => " CLR_RESET CLR_BOLD CLR_RED "%d/100" CLR_RESET "\n", final_score);

    /* Simple progress bar for final score */
    printf("╠═" CLR_BOLD CLR_CYAN" Progress: " CLR_RESET);
    int barLength = final_score / 10; /* each block = 10 points */
    printf("[");
    for(int i=0; i<barLength; i++){
        printf("█");
    }
    for(int i=barLength; i<10; i++){
        printf(" ");
    }
    printf("]" CLR_RED "%d%%\n" CLR_RESET, final_score);

    printf("╚════════════════════════════════════════════╝\n");

    pause_enter();
}

/* ----------------------------------------------------------------
   Clears scoreboard entirely
   ----------------------------------------------------------------
*/
void menu_clear_scoreboard(void) {
    scoreboard_clear();
    printf(CLR_BOLD CLR_CYAN "\n╔════════════════════════════════════════════╗\n");
    printf("║ Scoreboard cleared.                        ║\n");
    printf("╚════════════════════════════════════════════╝\n" CLR_RESET);
    pause_enter();
}

/* ----------------------------------------------------------------
   Toggles 0=>normal, 1=>fast
   ----------------------------------------------------------------
*/
void menu_toggle_speed_mode(void) {
    int current = stats_get_speed_mode();
    int next    = (current == 0) ? 1 : 0;
    stats_set_speed_mode(next);

    printf(CLR_BOLD CLR_CYAN "\n╔═════════════════════════════════════╗\n");
    printf("║ Speed mode set to: %s\n", (next == 0) ? "NORMAL" : "FAST");
    printf("╚═════════════════════════════════════╝\n" CLR_RESET);

    pause_enter();
}

/* ----------------------------------------------------------------
   Attempt to prompt user to run the next suite if newly unlocked
   (the chain: Basic->Normal->External->Modes->Edge->Hidden).
   Called after finishing a single suite or single test in that suite.
   ----------------------------------------------------------------
*/
static void attempt_run_next_suite(scoreboard_suite_t currentSuite) {
    int found_idx = -1;
    for(int i=0; i<g_suite_chain_count; i++){
        if(g_suite_chain[i] == currentSuite){
            found_idx = i;
            break;
        }
    }
    if(found_idx < 0) return; /* not found in chain */
    if(found_idx == g_suite_chain_count-1) return; /* last suite => no next */

    scoreboard_suite_t next = g_suite_chain[found_idx+1];
    if(scoreboard_is_unlocked(next)) {
        printf(CLR_BOLD CLR_GREEN "\n┌───────────────────────────────────────────────────────────┐\n");
        printf("│"CLR_GREEN" Good job! Next suite is now unlocked"CLR_RESET"                │\n");
        printf("│"CLR_GREEN CLR_BOLD" Do you want to run the next suite immediately? (y/n)"CLR_RESET"      │\n");
        printf("└───────────────────────────────────────────────────────────┘\n" CLR_RESET);
        printf("Choice: ");

        char buf[256];
        if(!read_line(buf, sizeof(buf))) {
            return;
        }
        if(buf[0] == 'y' || buf[0] == 'Y') {
            /* directly run that suite (all its tests) as if single suite run */
            switch(next) {
                case SUITE_NORMAL: {
                    int t=0, p=0;
                    run_normal_tests(&t,&p);
                    scoreboard_update_normal(t,p);
                    scoreboard_save();
                    break;
                }
                case SUITE_EXTERNAL: {
                    run_external_tests_menu();
                    scoreboard_save();
                    break;
                }
                case SUITE_MODES: {
                    int t=0, p=0;
                    run_modes_tests(&t,&p);
                    scoreboard_update_modes(t,p);
                    scoreboard_save();
                    break;
                }
                case SUITE_EDGE: {
                    int t=0, p=0;
                    run_edge_tests(&t,&p);
                    scoreboard_update_edge(t,p);
                    scoreboard_save();
                    break;
                }
                case SUITE_HIDDEN: {
                    int t=0, p=0;
                    run_hidden_tests(&t,&p);
                    scoreboard_update_hidden(t,p);
                    scoreboard_save();
                    break;
                }
                default: /* no-op */ break;
            }
            /* chain further if that unlocked more */
            attempt_run_next_suite(next);
        }
    }
}

/* ----------------------------------------------------------------
   Runs exactly one test from the chosen suite, i.e. not the entire suite.
   We ask the suite for how many tests it has, then which one to run.
   We update scoreboard by +1 test total, and +1 pass if it passed.
   Then save, and see if next suite unlocks.
   ----------------------------------------------------------------
*/
static void run_single_test_in_suite(scoreboard_suite_t chosen) {
    /* we must see how many test-cases are in that suite, let user pick. */
    int count = 0;
    switch(chosen) {
        case SUITE_BASIC:   count = basic_test_count();   break;
        case SUITE_NORMAL:  count = normal_test_count();  break;
        case SUITE_MODES:   count = modes_test_count();   break;
        case SUITE_EDGE:    count = edge_test_count();    break;
        case SUITE_HIDDEN:  count = hidden_test_count();  break;
        case SUITE_EXTERNAL:count = external_test_count();break;
        default: count=0; break;
    }
    if(count<=0) {
        printf("No tests found in that suite or suite missing.\n");
        pause_enter();
        return;
    }

    printf("\nWhich single test do you want to run (1..%d)? ", count);
    char buf[256];
    if(!read_line(buf, sizeof(buf))) return;
    int pick = parse_int_strtol(buf, -1);
    if(pick<1 || pick>count) {
        printf("Invalid test index.\n");
        pause_enter();
        return;
    }

    /* run that single test now. We'll get pass/fail result. */
    printf("\nRunning test #%d in that suite...\n\n", pick);

    int passResult = 0; /* 0 => fail, 1 => pass */
    switch(chosen){
        case SUITE_BASIC:
            basic_test_run_single(pick-1, &passResult); /* 0-based index */
            scoreboard_update_basic(1, passResult);
            scoreboard_save();
            attempt_run_next_suite(SUITE_BASIC);
            break;
        case SUITE_NORMAL:
            normal_test_run_single(pick-1, &passResult);
            scoreboard_update_normal(1, passResult);
            scoreboard_save();
            attempt_run_next_suite(SUITE_NORMAL);
            break;
        case SUITE_MODES:
            modes_test_run_single(pick-1, &passResult);
            scoreboard_update_modes(1, passResult);
            scoreboard_save();
            attempt_run_next_suite(SUITE_MODES);
            break;
        case SUITE_EDGE:
            edge_test_run_single(pick-1, &passResult);
            scoreboard_update_edge(1, passResult);
            scoreboard_save();
            attempt_run_next_suite(SUITE_EDGE);
            break;
        case SUITE_HIDDEN:
            hidden_test_run_single(pick-1, &passResult);
            scoreboard_update_hidden(1, passResult);
            scoreboard_save();
            attempt_run_next_suite(SUITE_HIDDEN);
            break;
        case SUITE_EXTERNAL:
            external_test_run_single(pick-1, &passResult);
            scoreboard_update_external(1, passResult);
            scoreboard_save();
            attempt_run_next_suite(SUITE_EXTERNAL);
            break;
        default:
            break;
    }

    pause_enter();
}

/* ----------------------------------------------------------------
   Menu option "Run Single Test (Submenu)" => asks user which suite,
   then calls run_single_test_in_suite(). If suite locked => fail.
   ----------------------------------------------------------------
*/
void submenu_run_single_test(void) {
    clear_screen();
    printf(CLR_BOLD CLR_CYAN "╔════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN "║ RUN SINGLE TEST - SUITE SELECTION  ║\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN "╚════════════════════════════════════╝\n" CLR_RESET);

    printf("Choose which suite?\n");
    printf(" 1) Basic\n");
    printf(" 2) Normal\n");
    printf(" 3) Modes\n");
    printf(" 4) Edge\n");
    printf(" 5) Hidden\n");
    printf(" 6) External\n");
    printf("Choice: ");

    char buf[256];
    if(!read_line(buf, sizeof(buf))) return;
    int suite = parse_int_strtol(buf, -1);
    if(suite < 1 || suite > 6){
        printf("Invalid.\n");
        pause_enter();
        return;
    }

    scoreboard_suite_t chosen;
    switch(suite){
        case 1: chosen = SUITE_BASIC;   break;
        case 2: chosen = SUITE_NORMAL;  break;
        case 3: chosen = SUITE_MODES;   break;
        case 4: chosen = SUITE_EDGE;    break;
        case 5: chosen = SUITE_HIDDEN;  break;
        case 6: chosen = SUITE_EXTERNAL;break;
        default: return;
    }

    int unlocked = scoreboard_is_unlocked(chosen);
    if(!unlocked && chosen!=SUITE_BASIC) {
        /*
          Basic is always unlocked by design.
          Others must meet scoreboard pass threshold from the previous suite.
        */
        printf("\nThat suite is currently locked (need 60%% pass on the previous suite).\n");
        pause_enter();
        return;
    }

    run_single_test_in_suite(chosen);
}

/* ----------------------------------------------------------------
   "Run All Unlocked Test Suites" but skip re-running those at 100%.
   We run them in chain order, each suite's entire test set.
   If user sends SIGTERM => we break early.
   ----------------------------------------------------------------
*/
void submenu_run_tests(void) {
    g_return_to_menu = 0;
    scoreboard_t sb;
    get_scoreboard(&sb);

    printf(CLR_BOLD CLR_CYAN "╔═══════════════════════════════════════════╗\n");
    printf("║     Running all UNLOCKED (unpassed) tests ║\n");
    printf("╚═══════════════════════════════════════════╝\n" CLR_RESET);

    scoreboard_load(); /* refresh scoreboard just in case */

    for(int i=0; i<g_suite_chain_count; i++){
        scoreboard_suite_t st = g_suite_chain[i];
        if(!scoreboard_is_unlocked(st)) {
            /* skip locked */
            continue;
        }
        /* skip if that suite is fully at 100% pass */
        switch(st){
            case SUITE_BASIC:
                if(sb.basic_percent >= 100.0)  continue;
                break;
            case SUITE_NORMAL:
                if(sb.normal_percent >= 100.0) continue;
                break;
            case SUITE_EXTERNAL:
                if(sb.external_percent>=100.0) continue;
                break;
            case SUITE_MODES:
                if(sb.modes_percent>=100.0)    continue;
                break;
            case SUITE_EDGE:
                if(sb.edge_percent>=100.0)     continue;
                break;
            case SUITE_HIDDEN:
                if(sb.hidden_percent>=100.0)   continue;
                break;
            default:
                break;
        }

        /* if user used SIGTERM => break out */
        if(g_return_to_menu) {
            printf("[RunAllUnlocked] SIGTERM => returning.\n");
            break;
        }

        /* run that entire suite's test set now. */
        switch(st){
            case SUITE_BASIC: {
                int t=0,p=0;
                printf("\n[Running BASIC suite...]\n");
                run_basic_tests(&t,&p);
                scoreboard_update_basic(t,p);
                scoreboard_save();
                attempt_run_next_suite(SUITE_BASIC);
                break;
            }
            case SUITE_NORMAL: {
                int t=0,p=0;
                printf("\n[Running NORMAL suite...]\n");
                run_normal_tests(&t,&p);
                scoreboard_update_normal(t,p);
                scoreboard_save();
                attempt_run_next_suite(SUITE_NORMAL);
                break;
            }
            case SUITE_EXTERNAL: {
                printf("\n[Running EXTERNAL suite...]\n");
                run_external_tests_menu();
                scoreboard_save();
                attempt_run_next_suite(SUITE_EXTERNAL);
                break;
            }
            case SUITE_MODES: {
                int t=0,p=0;
                printf("\n[Running MODES suite...]\n");
                run_modes_tests(&t,&p);
                scoreboard_update_modes(t,p);
                scoreboard_save();
                attempt_run_next_suite(SUITE_MODES);
                break;
            }
            case SUITE_EDGE: {
                int t=0,p=0;
                printf("\n[Running EDGE suite...]\n");
                run_edge_tests(&t,&p);
                scoreboard_update_edge(t,p);
                scoreboard_save();
                attempt_run_next_suite(SUITE_EDGE);
                break;
            }
            case SUITE_HIDDEN: {
                int t=0,p=0;
                printf("\n[Running HIDDEN suite...]\n");
                run_hidden_tests(&t,&p);
                scoreboard_update_hidden(t,p);
                scoreboard_save();
                attempt_run_next_suite(SUITE_HIDDEN);
                break;
            }
            default:
                break;
        }
        get_scoreboard(&sb); /* re-check scoreboard for next iteration */
    }

    pause_enter();
}

/* ----------------------------------------------------------------
   External concurrency menu
   ----------------------------------------------------------------
*/
void menu_submenu_external_concurrency(void) {
    int unlockedExt = scoreboard_is_unlocked(SUITE_EXTERNAL);
    if(!unlockedExt) {
        printf(CLR_BOLD CLR_RED "\n[External Concurrency] is locked (need 60%% pass on EXTERNAL suite).\n" CLR_RESET);
        pause_enter();
        return;
    }

    clear_screen();
    printf(CLR_BOLD CLR_CYAN "\n╔════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "║  External Shell Concurrency Menu   ║\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "╚════════════════════════════════════╝\n" CLR_RESET);

    printf("1) Run concurrency with a SINGLE scheduling mode\n");
    printf("2) Run concurrency with ALL scheduling modes\n");
    printf("\nChoice: ");

    char buf[256];
    if(!read_line(buf, sizeof(buf))) return;
    int sub = parse_int_strtol(buf, -1);
    if(sub < 1 || sub > 2){
        printf("Invalid.\n");
        pause_enter();
        return;
    }

    printf("How many concurrent shells? ");
    if(!read_line(buf, sizeof(buf))) return;
    int n = parse_int_strtol(buf, 0);
    if(n<1){
        printf("Invalid number of shells.\n");
        pause_enter();
        return;
    }

    printf("How many CPU cores? ");
    if(!read_line(buf, sizeof(buf))) return;
    int c = parse_int_strtol(buf, 2);
    if(c<1) c=2;

    printf("\nChoose concurrency test style:\n");
    printf(" 1) Short test\n");
    printf(" 2) Medium test\n");
    printf(" 3) Stress test\n");
    printf("Choice: ");
    if(!read_line(buf,sizeof(buf))) return;
    int style = parse_int_strtol(buf,1);
    if(style<1 || style>3) style=1;

    char** lines = (char**)calloc(n, sizeof(char*));
    if(!lines) return;

    g_return_to_menu = 0;

    int base=2;
    switch(style) {
        case 1: base=2;  break;  /* short */
        case 2: base=5;  break;  /* medium */
        case 3: base=10; break;  /* stress */
        default: base=2; break;
    }

    /* Build commands for each shell: "sleep X" */
    for(int i=0; i<n; i++){
        char tmp[64];
        if(sub == 1) {
            /* single mode => small differences in durations */
            snprintf(tmp, sizeof(tmp), "sleep %d", (i+1)*base);
        } else {
            /* all modes => short uniform sleeps */
            snprintf(tmp, sizeof(tmp), "sleep %d", (i+1)*2);
        }
        lines[i] = strdup(tmp);
    }

    if(sub==1){
        printf("\nSelect scheduling mode:\n");
        printf(" 0=FIFO,1=RR,2=CFS,3=CFS-SRTF,4=BFS,\n");
        printf(" 5=SJF,6=STRF,7=HRRN,8=HRRN-RT,\n");
        printf(" 9=PRIORITY,10=HPC-OVER,11=MLFQ\n");
        printf("Choice: ");
        if(!read_line(buf,sizeof(buf))){
            pause_enter();
            for(int i=0;i<n;i++) free(lines[i]);
            free(lines);
            return;
        }
        int mode = parse_int_strtol(buf, -1);
        if(mode<0 || mode>11){
            printf("Invalid mode.\n");
            pause_enter();
        } else {
            run_shell_commands_concurrently(n, lines, c, mode, 0);
        }
    } else {
        run_shell_commands_concurrently(n, lines, c, -1, 1);
    }

    for(int i=0; i<n; i++){
        free(lines[i]);
    }
    free(lines);

    pause_enter();
}

/* ----------------------------------------------------------------
   Final cleanup => exit code.
   Print a final stats summary.
   ----------------------------------------------------------------
*/
void cleanup_and_exit(int code) {
    printf(CLR_BOLD CLR_YELLOW "\n╔════════════════════════════════════════════╗\n");
    printf("║        Exiting => Saving scoreboard        ║\n");
    printf("╚════════════════════════════════════════════╝\n" CLR_RESET);

    os_cleanup();
    scoreboard_save();
    scoreboard_close();
    stats_print_summary();
    exit(code);
}

/* ----------------------------------------------------------------
   Our signal handler
   ----------------------------------------------------------------
*/
void handle_signal(int signum) {
    if(signum == SIGINT) {
        stats_inc_signal_sigint();
        printf(CLR_BOLD CLR_RED "\n[Main] Caught SIGINT => Save scoreboard and exit.\n" CLR_RESET);
        int fs = scoreboard_get_final_score();
        cleanup_and_exit(fs);
    }
    else if(signum == SIGTERM){
        stats_inc_signal_sigterm();
        printf(CLR_BOLD CLR_RED "\n[Main] Caught SIGTERM => concurrency/test stops => returning to menu.\n" CLR_RESET);
        set_os_concurrency_stop_flag(1);
        g_return_to_menu = 1;
    }
    else if(signum == SIGUSR1) {
        stats_inc_signal_other();
        printf(CLR_BOLD CLR_RED "\n[Main] Caught SIGUSR1 => concurrency stop.\n" CLR_RESET);
        set_os_concurrency_stop_flag(1);
    }
}

/* ----------------------------------------------------------------
   main() => scoreboard init, os init, stats init
   Show main menu until user chooses exit
   ----------------------------------------------------------------
*/
int main(int argc, char** argv){
    (void)argc;
    (void)argv;

    signal(SIGINT,  handle_signal);
    signal(SIGTERM, handle_signal);
    signal(SIGUSR1, handle_signal);

    scoreboard_init();
    scoreboard_load();
    os_init();
    stats_init();

    while(1){
        ascii_main_menu_header();
        printf(CLR_BOLD CLR_YELLOW " ┌─── MAIN MENU ─────────────────────────────┐\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " │ 1) Run All Failed Internal Suites         │\n" CLR_RESET);
        printf(CLR_BOLD CLR_GRAY   " │ 2) Exit                                   │\n" CLR_RESET);
        printf(CLR_BOLD CLR_GRAY   " │ 3) External Shell Concurrency DEMO        │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " │ 4) Run External Tests                     │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " │ 5) Show Scoreboard                        │\n" CLR_RESET);
        printf(CLR_BOLD CLR_GRAY   " │ 6) Clear Scoreboard                       │\n" CLR_RESET);
        printf(CLR_BOLD CLR_GRAY   " │ 7) Toggle Speed Mode                      │\n" CLR_RESET);
        printf(CLR_BOLD CLR_GRAY   " │ 8) Run Single Test (Submenu)              │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW " └───────────────────────────────────────────┘\n\n" CLR_RESET);
        printf("Choice: ");

        char input[256];
        if(!read_line(input, sizeof(input))){
            printf("Exiting (EOF/read error).\n");
            int fs = scoreboard_get_final_score();
            cleanup_and_exit(fs);
        }
        int choice = parse_int_strtol(input, -1);

        switch(choice){
        case 1:
            submenu_run_tests();
            break;
        case 2: {
            int fs = scoreboard_get_final_score();
            printf("\nExiting with final score = %d.\n", fs);
            cleanup_and_exit(fs);
            break;
        }
        case 3:
            menu_submenu_external_concurrency();
            break;
        case 4: {
            if(!scoreboard_is_unlocked(SUITE_EXTERNAL)){
                printf("External tests locked (need 60%% pass on EXTERNAL suite).\n");
                pause_enter();
            } else {
                printf("\nRunning external tests...\n");
                run_external_tests_menu();
                scoreboard_save();
                pause_enter();
            }
            break;
        }
        case 5:
            menu_show_scoreboard();
            break;
        case 6:
            menu_clear_scoreboard();
            break;
        case 7:
            menu_toggle_speed_mode();
            break;
        case 8:
            submenu_run_single_test();
            break;
        default:
            printf("Invalid.\n");
            pause_enter();
            break;
        }
    }
    return 0;
}
#ifndef MAIN_H
#define MAIN_H

#include <stddef.h>

/*
 * main.h => Declarations for menu and utility functions used by main.c
 */

/* Cleanup function that saves scoreboard, prints stats, and exits the program. */
void cleanup_and_exit(int code);

/* Signal handler for SIGINT, SIGTERM, SIGUSR1. */
void handle_signal(int signum);

/* Clears the terminal screen. */
void clear_screen(void);

/* Pauses until the user presses ENTER. */
void pause_enter(void);

/* Reads one line (up to sz-1 chars). Returns 1 if success, 0 if error/EOF. */
int read_line(char *buf, size_t sz);

/* Prints the ASCII art main menu header (includes speed mode info). */
void ascii_main_menu_header(void);

/* Submenu to run all unlocked tests (skipping already 100% passed). */
void submenu_run_tests(void);

/* Submenu to run exactly one test from a chosen suite. */
void submenu_run_single_test(void);

/* Shows the scoreboard in a "squared ASCII" format with progress bar. */
void menu_show_scoreboard(void);

/* Clears the scoreboard. */
void menu_clear_scoreboard(void);

/* Toggles speed mode: 0 => normal, 1 => fast. */
void menu_toggle_speed_mode(void);

/* External concurrency submenu. */
void menu_submenu_external_concurrency(void);

#endif
#include "os.h"
#include "stats.h"

#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <pthread.h>
#include <sys/wait.h>
#include <time.h>
#include <string.h>

/*
  Global concurrency stop flag. If set, any concurrency loop stops early.
*/
static volatile sig_atomic_t g_concurrency_stop_flag = 0;

/* For measuring time since os_init() */
static uint64_t g_start_ms = 0;

/* Up to 32 ephemeral containers. */
static int       g_container_count = 0;
static char      g_container_paths[32][256];

/* Returns monotonic current time in ms */
static uint64_t now_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)(ts.tv_sec)*1000ULL + (ts.tv_nsec / 1000000ULL);
}

void set_os_concurrency_stop_flag(int val) {
    g_concurrency_stop_flag = (sig_atomic_t)val;
}

int os_concurrency_stop_requested(void) {
    return (int)g_concurrency_stop_flag;
}

/* ----------------------------------------------------------------
   Initialize "OS"
   ----------------------------------------------------------------
*/
void os_init(void) {
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    g_start_ms = now_ms();
    g_container_count = 0;
    memset(g_container_paths, 0, sizeof(g_container_paths));

    /* OS init block in normal mode */
    printf(CLR_BOLD CLR_MAGENTA "╔══════════════════════════════════════════════╗\n");
    printf("║               OS INIT COMPLETE               ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");

    if(stats_get_speed_mode() == 0) {
        usleep(200000); /* short pause in normal mode */
    }
}

/* ----------------------------------------------------------------
   Cleanup: remove ephemeral containers, etc.
   ----------------------------------------------------------------
*/
void os_cleanup(void) {
    while (g_container_count > 0) {
        g_container_count--;
        const char* path = g_container_paths[g_container_count];
        if (path && path[0]) {
            rmdir(path);
            memset(g_container_paths[g_container_count], 0, sizeof(g_container_paths[g_container_count]));
            printf(CLR_CYAN "[-] Container removed (cleanup): %s\n" CLR_RESET, path);
            stats_inc_containers_removed();

            if(stats_get_speed_mode()==0) {
                usleep(200000);
            }
        }
    }
    printf(CLR_BOLD CLR_MAGENTA "╔══════════════════════════════════════════════╗\n");
    printf(               "║             OS CLEANUP COMPLETE              ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");

    if(stats_get_speed_mode() == 0) {
        usleep(250000);
    }
}

uint64_t os_time(void) {
    uint64_t now = now_ms();
    if(now < g_start_ms) return 0ULL;
    return (now - g_start_ms);
}

/* Minimal logging with a small delay in normal mode only */
void os_log(const char* msg) {
    if(!msg) return;
    if(stats_get_speed_mode() == 0) {
        printf("%s\n", msg);
        usleep(150000);
    }
}

/* ----------------------------------------------------------------
   Container creation
   ----------------------------------------------------------------
*/
void os_create_ephemeral_container(void) {
    if(g_container_count >= 32) return;
    char tmpl[] = "/tmp/os_cont_XXXXXX";
    if(mkdtemp(tmpl)) {
        strncpy(g_container_paths[g_container_count], tmpl, 255);
        g_container_count++;
        printf(CLR_CYAN "[+] Container created: %s (count=%d)\n" CLR_RESET,
               tmpl, g_container_count);
        stats_inc_containers_created();

        if(stats_get_speed_mode()==0) {
            usleep(250000);
        }
    }
}

/* Container removal */
void os_remove_ephemeral_container(void) {
    if(g_container_count <= 0) return;
    g_container_count--;
    const char* path = g_container_paths[g_container_count];
    if(path[0]) {
        rmdir(path);
        memset(g_container_paths[g_container_count], 0, sizeof(g_container_paths[g_container_count]));
        printf(CLR_CYAN "[-] Container removed: %s (remaining=%d)\n" CLR_RESET,
               path, g_container_count);
        stats_inc_containers_removed();

        if(stats_get_speed_mode()==0) {
            usleep(250000);
        }
    }
}

/* HPC overshadow => spawn CPU-bound threads */
static void* overshadow_thread(void* arg) {
    long *ret = (long*)arg;
    long sum = 0;
    for (long i=0; i<700000; i++) {
        if(os_concurrency_stop_requested()) break;
        sum += (i % 17) + (i % 11);
    }
    *ret = sum;
    return NULL;
}

/* HPC overshadow: run multiple CPU-bound threads to show concurrency. */
void os_run_hpc_overshadow(void) {
    if(os_concurrency_stop_requested()) {
        printf(CLR_YELLOW "[OS] concurrency stop => skipping HPC overshadow.\n" CLR_RESET);
        return;
    }

    int n=4; /* 4 CPU-bound threads */
    long* results = (long*)calloc(n, sizeof(long));
    pthread_t* th = (pthread_t*)malloc(n*sizeof(pthread_t));

    for (int i=0; i<n; i++) {
        pthread_create(&th[i], NULL, overshadow_thread, &results[i]);
        if(stats_get_speed_mode()==0){
            printf(CLR_GREEN "   HPC Overshadow Thread #%d => time=%llu ms => started.\n" CLR_RESET,
                   i+1, (unsigned long long)os_time());
            usleep(200000);
        }
    }
    for (int i=0; i<n; i++) {
        pthread_join(th[i], NULL);
        if(stats_get_speed_mode()==0){
            printf(CLR_GREEN "   HPC Overshadow Thread #%d => time=%llu ms => finished.\n" CLR_RESET,
                   i+1, (unsigned long long)os_time());
            usleep(200000);
        }
    }

    free(th);
    free(results);

    printf(CLR_MAGENTA "╔══════════════════════════════════════════════╗\n");
    printf("║       HPC-OVERSHADOW BLOCK END               ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");

    if(stats_get_speed_mode()==0){
        usleep(200000);
    }
}

/* Pipeline => single child fork + wait. */
void os_pipeline_example(void) {
    printf(CLR_MAGENTA "╔══════════════════════════════════════════════╗\n");
    printf("║             PIPELINE BLOCK START             ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");

    if(os_concurrency_stop_requested()) {
        printf(CLR_YELLOW "[OS] concurrency stop => skipping pipeline.\n" CLR_RESET);
        return;
    }

    pid_t c = fork();
    if (c == 0) {
        if(stats_get_speed_mode()==0){
            printf(CLR_GREEN "   [Pipeline child => start => time=%llu ms]\n" CLR_RESET,
                   (unsigned long long)os_time());
            usleep(50000);
            printf(CLR_GREEN "   [Pipeline child => end => time=%llu ms]\n" CLR_RESET,
                   (unsigned long long)os_time());
        }
        _exit(0);
    } else if (c > 0) {
        if(stats_get_speed_mode()==0){
            printf(CLR_GREEN "   [Pipeline parent => waiting => time=%llu ms]\n" CLR_RESET,
                   (unsigned long long)os_time());
            usleep(200000);
        }
        waitpid(c, NULL, 0);
    }

    printf(CLR_CYAN "╔══════════════════════════════════════════════╗\n");
    printf("║             PIPELINE BLOCK END               ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");

    if(stats_get_speed_mode()==0){
        usleep(200000);
    }
}

/* Distributed => fork child that runs HPC overshadow. */
void os_run_distributed_example(void) {
    printf(CLR_MAGENTA "╔══════════════════════════════════════════════╗\n");
    printf("║          DISTRIBUTED BLOCK START             ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");

    if(os_concurrency_stop_requested()) {
        printf(CLR_YELLOW "[OS] concurrency stop => skipping distributed.\n" CLR_RESET);
        return;
    }

    pid_t c = fork();
    if (c == 0) {
        if(stats_get_speed_mode()==0){
            printf(CLR_GREEN "   [Distributed child => HPC overshadow => time=%llu ms]\n" CLR_RESET,
                   (unsigned long long)os_time());
            usleep(200000);
        }
        os_run_hpc_overshadow();
        _exit(0);
    } else if (c > 0) {
        if(stats_get_speed_mode()==0){
            printf(CLR_GREEN "   [Distributed parent => waiting => time=%llu ms]\n" CLR_RESET,
                   (unsigned long long)os_time());
            usleep(200000);
        }
        waitpid(c, NULL, 0);
    }

    printf(CLR_CYAN "╔══════════════════════════════════════════════╗\n");
    printf("║           DISTRIBUTED BLOCK END              ║\n");
    printf("╚══════════════════════════════════════════════╝" CLR_RESET "\n");
}
#ifndef OS_H
#define OS_H

#include <stdint.h>

/*
  OS-level stubs and abstractions:
   - ephemeral containers
   - HPC overshadow
   - pipeline
   - distributed example
   - time logging for user display logs
   - concurrency stop check (used by SIGUSR1/SIGTERM)
*/

/* Sets the concurrency stop flag (e.g. after SIGUSR1 or SIGTERM). */
void set_os_concurrency_stop_flag(int val);

/* Returns if concurrency stop was requested. */
int os_concurrency_stop_requested(void);

/* Initialize OS environment (buffers, times, etc.). */
void os_init(void);

/* Cleanup OS environment (remove ephemeral containers, etc.). */
void os_cleanup(void);

/* Returns real-world time in ms since os_init(). */
uint64_t os_time(void);

/* Optionally log a message with a short delay for user-friendly pacing in normal mode. */
void os_log(const char* msg);

/* Ephemeral container operations. */
void os_create_ephemeral_container(void);
void os_remove_ephemeral_container(void);

/* HPC overshadow => spawns multiple CPU-bound threads to demonstrate concurrency. */
void os_run_hpc_overshadow(void);

/* Pipeline example => fork a child, show pipeline start/end with ASCII. */
void os_pipeline_example(void);

/* Distributed example => fork a child that itself runs HPC overshadow. */
void os_run_distributed_example(void);

#endif
#include "process.h"
#include <string.h>

/* Initialize a process with given burst, priority, arrival_time. */
void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival) {
    if (!p) return;
    memset(p, 0, sizeof(*p));
    p->burst_time     = burst;
    p->remaining_time = burst;
    p->priority       = priority;
    p->arrival_time   = arrival;
    p->times_owning_core = 0;
}
#ifndef PROCESS_H
#define PROCESS_H

#include <stdint.h>

/*
  Single "process" (or "task") structure for scheduling.
  Fields:
   - burst_time
   - priority
   - vruntime
   - arrival_time
   - remaining_time
   - stats (start_time, end_time, first_response, responded)
   - MLFQ queue level
   - times_owning_core
*/

typedef struct process_s {
    uint64_t burst_time;       /* total CPU time needed (ms) */
    int      priority;         /* smaller => higher priority (for some algs) */
    uint64_t vruntime;         /* used by CFS / CFS-SRTF */
    uint64_t arrival_time;     /* simulation "arrival" time */
    uint64_t remaining_time;   /* how many ms remain for this process */

    /* Additional fields to track stats: */
    uint64_t start_time;
    uint64_t end_time;
    uint64_t first_response;
    int      responded;
    int      mlfq_level;
    int      times_owning_core;
} process_t;

/* Initialize a process with the given burst, priority, arrival_time. */
void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival);

#endif
#include "ready_queue.h"
#include "scheduler.h"
#include "process.h"

#include <pthread.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/* We'll keep up to 10 MLFQ levels. */
#define MLFQ_MAX_QUEUES 10

typedef struct node_s {
    process_t*       proc;
    struct node_s*   next;
} node_t;

/*
  We store everything in a single static struct 'gQ' with:
  - sentinel for main list
  - ml_queues[] for MLFQ
  - size
  - chosen alg
  - locks/conds
*/
static struct {
    node_t           sentinel;
    size_t           size;
    pthread_mutex_t  m;
    pthread_cond_t   c;
    scheduler_alg_t  alg;
    node_t           ml_queues[MLFQ_MAX_QUEUES];
} gQ;

/* Helper accessors for mutex/cond. */
static pthread_mutex_t* pm(void) { return &gQ.m; }
static pthread_cond_t*  pc(void) { return &gQ.c; }

/*
 * Some local static push/pop functions for each scheduling approach.
 */

/* ---------- Linked-list queue basics ---------- */
static process_t* pop_head(void) {
    node_t* head = gQ.sentinel.next;
    if (!head) return NULL;
    gQ.sentinel.next = head->next;
    gQ.size--;
    process_t* p = head->proc;
    free(head);
    return p;
}

static void push_tail(process_t* p) {
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;
    node_t* cur = &gQ.sentinel;
    while (cur->next) {
        cur = cur->next;
    }
    cur->next = n;
    gQ.size++;
}

/* For priority-based insertion. */
static void push_priority(process_t* p) {
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;

    node_t* cur = &gQ.sentinel;
    while (cur->next && (p->priority >= cur->next->proc->priority)) {
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

/* For CFS => insert by ascending vruntime. */
static void push_cfs(process_t* p) {
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;

    node_t* cur = &gQ.sentinel;
    while (cur->next && (p->vruntime >= cur->next->proc->vruntime)) {
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

/* For SJF => insert by ascending burst_time. */
static void push_sjf(process_t* p) {
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;

    node_t* cur = &gQ.sentinel;
    while (cur->next && (p->burst_time >= cur->next->proc->burst_time)) {
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

/* Helper for HRRN. ratio = (wait + remain). Higher => schedule sooner. */
static uint64_t hrrn_val(process_t* p, uint64_t now) {
    uint64_t wait   = (now > p->arrival_time) ? (now - p->arrival_time) : 0ULL;
    uint64_t remain = (p->remaining_time > 0) ? p->remaining_time : 1ULL;
    return (wait + remain);
}

static void push_hrrn(process_t* p, int preemptive) {
    (void)preemptive; /* not used for the insertion itself */

    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;

    uint64_t now = get_global_sim_time();
    uint64_t new_ratio = hrrn_val(p, now);

    node_t* cur = &gQ.sentinel;
    while (cur->next) {
        uint64_t c_ratio = hrrn_val(cur->next->proc, now);
        if (new_ratio > c_ratio) {
            break;
        }
        cur = cur->next;
    }
    n->next = cur->next;
    cur->next = n;
    gQ.size++;
}

/* MLFQ => multiple queues. We pop from the highest priority queue that is non-empty. */
static process_t* pop_mlfq(void) {
    for (int i = 0; i < MLFQ_MAX_QUEUES; i++) {
        if (gQ.ml_queues[i].next) {
            node_t* n = gQ.ml_queues[i].next;
            gQ.ml_queues[i].next = n->next;
            gQ.size--;
            process_t* p = n->proc;
            free(n);
            return p;
        }
    }
    return NULL;
}

static void push_mlfq(process_t* p) {
    int level = p->mlfq_level;
    if (level < 0) level = 0;
    if (level >= MLFQ_MAX_QUEUES) level = MLFQ_MAX_QUEUES - 1;

    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;

    node_t* cur = &gQ.ml_queues[level];
    while (cur->next) {
        cur = cur->next;
    }
    cur->next = n;
    gQ.size++;
}

/* We'll choose function pointers at init. */
static process_t* (*f_pop)(void) = NULL;
static void       (*f_push)(process_t*) = NULL;

/* Preemptive indicates if the scheduler preempts after a quantum or not. */
static int g_preemptive = 0;

/* Implementation of ready_queue public API */

void ready_queue_init_policy(scheduler_alg_t alg) {
    memset(&gQ, 0, sizeof(gQ));
    pthread_mutex_init(pm(), NULL);
    pthread_cond_init(pc(), NULL);
    gQ.alg = alg;

    switch (alg) {
    case ALG_FIFO:
    case ALG_RR:
    case ALG_BFS:
        f_push = push_tail;
        f_pop  = pop_head;
        g_preemptive = (alg == ALG_RR || alg == ALG_BFS) ? 1 : 0;
        break;

    case ALG_PRIORITY:
        f_push = push_priority;
        f_pop  = pop_head;
        g_preemptive = 0;
        break;

    case ALG_CFS:
        f_push = push_cfs;
        f_pop  = pop_head;
        g_preemptive = 0;
        break;

    case ALG_CFS_SRTF:
        f_push = push_cfs;
        f_pop  = pop_head;
        g_preemptive = 1;
        break;

    case ALG_SJF:
        f_push = push_sjf;
        f_pop  = pop_head;
        g_preemptive = 0;
        break;

    case ALG_STRF:
        f_push = push_sjf;
        f_pop  = pop_head;
        g_preemptive = 1;
        break;

    case ALG_HRRN:
        f_push = (void (*)(process_t*))push_hrrn;
        f_pop  = (process_t* (*)(void))pop_head;
        g_preemptive = 0;
        break;

    case ALG_HRRN_RT:
        f_push = (void (*)(process_t*))push_hrrn;
        f_pop  = (process_t* (*)(void))pop_head;
        g_preemptive = 1;
        break;

    case ALG_MLFQ:
        f_push = push_mlfq;
        f_pop  = pop_mlfq;
        g_preemptive = 1;
        break;

    case ALG_HPC_OVERSHADOW:
    default:
        /* HPC overshadow doesn't use the queue in normal sense */
        f_push = push_tail;
        f_pop  = pop_head;
        g_preemptive = 0;
        break;
    }
}

void ready_queue_destroy(void) {
    pthread_cond_destroy(pc());
    pthread_mutex_destroy(pm());
    memset(&gQ, 0, sizeof(gQ));
}

void ready_queue_push(process_t* p) {
    pthread_mutex_lock(pm());
    if (p) {
        if (gQ.alg == ALG_HRRN || gQ.alg == ALG_HRRN_RT) {
            push_hrrn(p, (gQ.alg == ALG_HRRN_RT) ? 1 : 0);
        } else if (gQ.alg == ALG_MLFQ) {
            push_mlfq(p);
        } else {
            f_push(p);
        }
    }
    pthread_cond_broadcast(pc());
    pthread_mutex_unlock(pm());
}

process_t* ready_queue_pop(void) {
    pthread_mutex_lock(pm());
    while(1) {
        if (gQ.size > 0) {
            process_t* r = f_pop();
            pthread_mutex_unlock(pm());
            return r;
        }
        pthread_cond_wait(pc(), pm());
    }
    /* theoretically unreachable, but let's keep it */
    pthread_mutex_unlock(pm());
    return NULL;
}

size_t ready_queue_size(void) {
    pthread_mutex_lock(pm());
    size_t s = gQ.size;
    pthread_mutex_unlock(pm());
    return s;
}
#ifndef READY_QUEUE_H
#define READY_QUEUE_H

#include <stddef.h>
#include "process.h"
#include "scheduler.h"

/*
  "ready_queue" data structure, with policy determined by scheduler_alg_t.
  Thread-safe with mutex + cond.
*/

/* Initialize the ready queue with a given scheduling algorithm. */
void ready_queue_init_policy(scheduler_alg_t alg);

/* Destroy the ready queue, freeing resources. */
void ready_queue_destroy(void);

/* Push a process into the queue. (thread-safe) */
void ready_queue_push(process_t* proc);

/* Pop a process from the queue. (thread-safe, blocks if empty) */
process_t* ready_queue_pop(void);

/* Returns the current size. (thread-safe) */
size_t ready_queue_size(void);

#endif
#include "runner.h"
#include "scheduler.h"
#include "scoreboard.h"
#include "os.h"
#include "safe_calls_library.h"
#include "stats.h"

#include <stdio.h>
#include <string.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/ptrace.h>
#include <unistd.h>
#include <signal.h>
#include <stdarg.h>

#include "../test/external-test.h"  /* so we can call run_external_tests() */


/* Private: map of scheduling mode enums to string names. */
static const char* modeNames[] = {
    "FIFO","RR","CFS","CFS-SRTF","BFS",
    "SJF","STRF","HRRN","HRRN-RT","PRIORITY",
    "HPC-OVER","MLFQ"
};

/* We no longer implement run_all_levels(); replaced by menu. */
void run_all_levels(void) {
    printf("[runner] run_all_levels => replaced by main menu logic.\n");
}

/*
  Runs external tests if unlocked.
*/
void run_external_tests_menu(void) {
    if(!scoreboard_is_unlocked(SUITE_EXTERNAL)) {
        return;
    }
    run_external_tests();
}

/*
  Child info structure for concurrency tests.
*/
typedef struct {
    pid_t   pid;
    char*   cmd;
    int     core;
    uint64_t start_ms;
    int     p_out[2];
    int     p_err[2];
    int     p_in[2];
} child_t;

/* For concurrency logs, skip if speed=FAST. */
static void concurrency_log(const char* fmt, ...) {
    if(stats_get_speed_mode() == 1) {
        return; /* FAST => skip printing to accelerate */
    }
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
}

/* Use ptrace to attach and single-step for demonstration. */
static void advanced_debug_child(pid_t pid) {
    int sm = stats_get_speed_mode();
    if(ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1) {
        if(sm==0) {
            fprintf(stderr,"[Runner] ptrace attach fail (pid=%d): %s\n",
                    pid, strerror(errno));
        }
        return;
    }
    waitpid(pid, NULL, 0);

    /* Single step */
    if(ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) == -1) {
        if(sm==0) {
            fprintf(stderr,"[Runner] ptrace singlestep fail: %s\n", strerror(errno));
        }
    }
    waitpid(pid, NULL, 0);

    /* Syscall step */
    if(ptrace(PTRACE_SYSCALL, pid, NULL, NULL) == -1) {
        if(sm==0) {
            fprintf(stderr,"[Runner] ptrace syscall fail: %s\n", strerror(errno));
        }
    }
    waitpid(pid, NULL, 0);

    ptrace(PTRACE_DETACH, pid, NULL, NULL);
}

/*
  Spawns a child running the external "shell-tp1-implementation" binary,
  sets up pipes, sends the command, attaches with ptrace for one step, etc.
*/
static pid_t spawn_child(const char* cmd, child_t* ch, int core) {
    pipe(ch->p_out);
    pipe(ch->p_err);
    pipe(ch->p_in);

    pid_t c = fork();
    if (c < 0) {
        fprintf(stderr,"fork() error\n");
        return -1;
    } else if (c == 0) {
        close(ch->p_out[0]);
        close(ch->p_err[0]);
        close(ch->p_in[0]);

        dup2(ch->p_out[1], STDOUT_FILENO);
        dup2(ch->p_err[1], STDERR_FILENO);
        dup2(ch->p_in[1],  STDIN_FILENO);

        close(ch->p_out[1]);
        close(ch->p_err[1]);
        close(ch->p_in[1]);

        execl("../../shell-tp1-implementation", "shell-tp1-implementation", (char*)NULL);
        _exit(0);
    } else {
        ch->pid = c;
        ch->cmd = (cmd ? strdup(cmd) : NULL);
        ch->core = core;
        ch->start_ms = os_time();
        stats_inc_processes_spawned();

        close(ch->p_out[1]);
        close(ch->p_err[1]);
        close(ch->p_in[0]);

        /* send the command + exit to child's stdin */
        dprintf(ch->p_in[1], "%s\nexit\n", cmd ? cmd : "");
        close(ch->p_in[1]);

        advanced_debug_child(c);
    }
    return c;
}

/*
  Run shell commands concurrently with a chosen scheduling mode
  or all modes. We produce schedule blocks around each mode run
  in normal mode. In fast mode, we skip the schedule block prints.
*/
void run_shell_commands_concurrently(int count,
                                     char** lines,
                                     int coreCount,
                                     int mode,
                                     int allModes)
{
    if(count <= 0 || !lines) return;

    /* check if external shell is present */
    if(access("./shell-tp1-implementation", X_OK) != 0){
        printf(CLR_RED "\n╔══════════════════════════════════════════════╗\n");
        printf("║shell-tp1-implementation NOT FOUND in root dir║\n");
        printf("║Concurrency test cannot run.                  ║\n");
        printf("╚══════════════════════════════════════════════╝\n" CLR_RESET);
        return;
    }

    stats_inc_concurrency_runs();

    /* Overall concurrency block */
    if(stats_get_speed_mode()==0) {
        printf(CLR_MAGENTA "\n╔═══════════════════════════════════════════════════════════════╗\n");
        printf(             "║                  Shell Commands SCHEDULE BLOCK                ║\n");
        printf(             "╚═══════════════════════════════════════════════════════════════╝\n" CLR_RESET);
    }

    /* Single mode => from=mode..mode, All => from=0..11 */
    int from = 0;
    int to   = 11;
    if(!allModes) {
        if(mode<0 || mode>to) {
            /* invalid mode => skip */
            if(stats_get_speed_mode()==0) {
                printf(CLR_MAGENTA "\n╔═════════════════════════════════════════════════════════════╗\n");
                printf("║ CONCURRENCY BLOCK => Invalid mode specified                 ║\n");
                printf("╚═════════════════════════════════════════════════════════════╝\n" CLR_RESET);
            }
            return;
        }
        from = mode;
        to   = mode;
    }

    /* track concurrency commands run */
    stats_inc_concurrency_commands(count * ((allModes)? (to-from+1):1));

    for(int m = from; m <= to; m++) {
        if(os_concurrency_stop_requested()) {
            concurrency_log(CLR_MAGENTA "\n╔═════════════════════════════════════════════════════════════╗\n");
            concurrency_log("║ CONCURRENCY STOP REQUESTED => returning...                  ║\n");
            concurrency_log("╚═════════════════════════════════════════════════════════════╝\n" CLR_RESET);
            break;
        }

        /* Show mode name if normal speed */
        if(stats_get_speed_mode()==0){
            concurrency_log(CLR_MAGENTA "\n╔═════════════════════════════════════════════════════════════╗\n");
            concurrency_log("║ SCHEDULE BLOCK START => %s\n", modeNames[m]);
            concurrency_log("╚═════════════════════════════════════════════════════════════╝" CLR_RESET "\n");
        }

        child_t* ch = (child_t*)calloc(count, sizeof(child_t));
        if(!ch) return;

        uint64_t global_start = os_time();
        int next_core = 0;

        /* spawn each child process */
        for(int i=0; i<count; i++){
            if(os_concurrency_stop_requested()){
                concurrency_log("[runner] concurrency stop => skip remaining spawns.\n");
                break;
            }
            spawn_child(lines[i], &ch[i], next_core);

            concurrency_log(CLR_GREEN"[time=%llu ms] container=1 core=%d => Launch child#%d cmd=\"%s\"\n"CLR_RESET,
                            (unsigned long long)os_time(),
                            next_core, i+1, lines[i] ? lines[i] : "");
            next_core = (next_core + 1) % coreCount;
        }

        /* wait each child. If stop requested => kill the rest. */
        for(int i=0; i<count; i++){
            if(!ch[i].pid) continue;
            if(os_concurrency_stop_requested()){
                concurrency_log("[runner] concurrency stop => kill remaining children.\n");
                kill(ch[i].pid, SIGKILL);
                continue;
            }
            waitpid(ch[i].pid, NULL, 0);
            uint64_t end_ms = os_time();
            concurrency_log(CLR_YELLOW"[time=%llu ms] container=1 core=%d => Child#%d ended => cmd=\"%s\" total_duration=%llums\n"CLR_RESET,
                            (unsigned long long)os_time(),
                            ch[i].core, i+1,
                            (ch[i].cmd ? ch[i].cmd : ""),
                            (unsigned long long)(end_ms - ch[i].start_ms));
        }

        uint64_t global_end = os_time();
        uint64_t total_time = (global_end > global_start) ? (global_end - global_start) : 0ULL;

        /* read from child pipes to consume output, then free */
        for(int i=0; i<count; i++){
            if(!ch[i].pid) continue;
            char outb[256]={0}, errb[256]={0};
            read(ch[i].p_out[0], outb, sizeof(outb)-1);
            read(ch[i].p_err[0], errb, sizeof(errb)-1);
            close(ch[i].p_out[0]);
            close(ch[i].p_err[0]);
            if(ch[i].cmd) free(ch[i].cmd);
        }
        free(ch);

        if(stats_get_speed_mode()==0){
            concurrency_log(CLR_MAGENTA"╔═════════════════════════════════════════════════════════════╗\n");
            concurrency_log("║ SCHEDULE BLOCK END => %s, total_time=%llums\n",
                             modeNames[m], (unsigned long long)total_time);
            concurrency_log("╚═════════════════════════════════════════════════════════════╝"CLR_RESET"\n");
        }
    }

    if(stats_get_speed_mode()==0){
        printf(CLR_MAGENTA "\n╔═══════════════════════════════════════════════════════════════╗\n");
        printf(             "║  END CONCURRENCY SCHEDULE BLOCK                               ║\n");
        printf(             "╚═══════════════════════════════════════════════════════════════╝\n" CLR_RESET);
    }

    set_os_concurrency_stop_flag(0);
}
#ifndef RUNNER_H
#define RUNNER_H

/*
  runner.h => code to run entire test suites or concurrency commands
              with chosen scheduling modes.
*/

#include <stddef.h>

/* Deprecated stub, replaced by menu logic. */
void run_all_levels(void);

/* Runs the external tests menu, checks scoreboard, etc. */
void run_external_tests_menu(void);

/*
  Run shell commands concurrently with a chosen scheduling mode or all modes.
   - count        => how many commands
   - lines        => array of string commands
   - coreCount    => how many CPU cores
   - mode         => which mode to use; if -1 => run all
   - allModes     => 1 => run all modes, 0 => single mode only
*/
void run_shell_commands_concurrently(int count,
                                     char** lines,
                                     int coreCount,
                                     int mode,
                                     int allModes);

#endif
#include "safe_calls_library.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <string.h>

int parse_int_strtol(const char* in, int fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    long v=strtol(in, &e, 10);
    if(e==in || errno==ERANGE || v<INT_MIN || v>INT_MAX) return fb;
    return (int)v;
}

long parse_long_strtol(const char* in, long fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    long v=strtol(in, &e, 10);
    if(e==in || errno==ERANGE) return fb;
    return v;
}

float parse_float_strtof(const char* in, float fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    float v=strtof(in, &e);
    if(e==in || errno==ERANGE) return fb;
    return v;
}

double parse_double_strtod(const char* in, double fb) {
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    double v=strtod(in, &e);
    if(e==in || errno==ERANGE) return fb;
    return v;
}

int safe_pthread_create(void*(*f)(void*), void* arg) {
    pthread_t t;
    int r = pthread_create(&t, NULL, f, arg);
    if(r) {
        fprintf(stderr,"pthread_create fail: %s\n", strerror(r));
        return -1;
    }
    pthread_detach(t);
    return 0;
}
#ifndef SAFE_CALLS_LIBRARY_H
#define SAFE_CALLS_LIBRARY_H

int    safe_pthread_create(void*(*f)(void*), void* arg);
int    parse_int_strtol(const char* input, int fallback);
long   parse_long_strtol(const char* input, long fallback);
float  parse_float_strtof(const char* input, float fallback);
double parse_double_strtod(const char* input, double fallback);

#endif
#include "scheduler.h"
#include "ready_queue.h"
#include "worker.h"
#include "os.h"
#include "stats.h"

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* We'll assume max of 4 cores for BFS/MLFQ demonstration. */
#ifndef MAX_CORES
#define MAX_CORES 4
#endif

/* Global scheduling states: */
static scheduler_alg_t  g_current_alg = ALG_CFS;
static int              g_num_cores   = 1;
static int              g_running     = 0;
static uint64_t         g_sim_time    = 0;
static pthread_mutex_t  g_sim_time_lock = PTHREAD_MUTEX_INITIALIZER;

/* track final stats in a single structure. */
static schedule_stats_t g_stats;

/* We keep a pointer to the list of processes used in the run. */
static process_t* g_process_list = NULL;
static int        g_list_count   = 0;

/* Access global sim time (used by ready_queue for e.g. HRRN). */
uint64_t get_global_sim_time(void) {
    pthread_mutex_lock(&g_sim_time_lock);
    uint64_t t = g_sim_time;
    pthread_mutex_unlock(&g_sim_time_lock);
    return t;
}

/* Resets scheduling stats & sim time at run start. */
static void reset_schedule_stats(void) {
    memset(&g_stats, 0, sizeof(g_stats));
    g_sim_time = 0;
}

/* The user wants HPC overshadow to skip normal stats. We'll handle that. */
static void finalize_stats(void) {
    /* HPC overshadow => skip normal stats because it's not a typical scheduling run. */
    if(g_stats.HPC_over_mode || g_list_count <= 0) {
        return;
    }
    for(int i=0; i<g_list_count; i++) {
        process_t* P = &g_process_list[i];
        uint64_t at  = P->arrival_time;
        uint64_t st  = P->first_response;
        uint64_t et  = P->end_time;

        uint64_t wait = (st > at) ? (st - at) : 0ULL;
        uint64_t tat  = (et > at) ? (et - at) : 0ULL;
        uint64_t resp = wait;

        g_stats.total_wait += wait;
        g_stats.total_tat  += tat;
        g_stats.total_resp += resp;
    }
    g_stats.total_count = g_list_count;

    if(g_stats.total_count > 0) {
        g_stats.avg_wait       = (double)g_stats.total_wait / (double)g_stats.total_count;
        g_stats.avg_turnaround = (double)g_stats.total_tat  / (double)g_stats.total_count;
        g_stats.avg_response   = (double)g_stats.total_resp / (double)g_stats.total_count;
    }
    g_stats.preemptions  = g_stats.total_preempts;
    g_stats.total_procs   = g_stats.total_count;
}

/* Core thread function: pop from ready_queue and run the partial timeslice. */
static void* core_thread_func(void* arg) {
    long core_id = (long)arg;
    unsigned long quantum = 2; /* ms for RR-like preemption simulation */

    while(g_running) {
        if(os_concurrency_stop_requested()) {
            /* concurrency stop => break from loop. */
            break;
        }
        process_t* p = ready_queue_pop();
        if(!g_running || !p) {
            /* if queue is empty or a sentinel (NULL) => continue or break. */
            continue;
        }
        uint64_t real_t = os_time();

        /* in normal mode, show scheduling info. */
        if(stats_get_speed_mode()==0) {
            printf("\033[93m[time=%llu ms] => container=1 core=%ld => scheduling process=%p\n"
                   "   => burst_time=%lu, prio=%d, vruntime=%llu, remain=%llu, timesScheduled=%d\033[0m\n",
                   (unsigned long long)real_t,
                   core_id, (void*)p,
                   (unsigned long)p->burst_time,
                   p->priority,
                   (unsigned long long)p->vruntime,
                   (unsigned long long)p->remaining_time,
                   p->times_owning_core);
            usleep(300000);
        }

        if(!p->responded) {
            p->responded = 1;
            p->first_response = get_global_sim_time();
        }
        p->times_owning_core++;

        int preemptive = 0;
        switch(g_current_alg) {
            case ALG_RR:
            case ALG_BFS:
            case ALG_CFS_SRTF:
            case ALG_STRF:
            case ALG_HRRN_RT:
            case ALG_MLFQ:
                preemptive = 1;
                break;
            default:
                preemptive = 0;
                break;
        }

        unsigned long slice = 0;
        if(preemptive) {
            /* If preemptive => run up to quantum, or less if process needs less. */
            if(p->remaining_time > quantum) {
                slice = quantum;
            } else {
                slice = p->remaining_time;
            }
        } else {
            /* Non-preemptive => run to completion. */
            slice = p->remaining_time;
        }

        simulate_process_partial(p, slice, (int)core_id);

        pthread_mutex_lock(&g_sim_time_lock);
        g_sim_time += slice;
        uint64_t now_sim = g_sim_time;
        pthread_mutex_unlock(&g_sim_time_lock);

        p->remaining_time -= slice;
        if(g_current_alg == ALG_CFS || g_current_alg == ALG_CFS_SRTF) {
            p->vruntime += slice;
        }

        /* if process not finished => push back, else record end_time. */
        if(preemptive && p->remaining_time > 0) {
            __sync_fetch_and_add(&g_stats.total_preempts, 1ULL);
            if(stats_get_speed_mode()==0) {
                printf("\033[94m   => PREEMPT => process=%p => new remain=%llu => preemptions=%llu\033[0m\n",
                       (void*)p,
                       (unsigned long long)p->remaining_time,
                       (unsigned long long)g_stats.total_preempts);
                usleep(300000);
            }
            if(g_current_alg == ALG_MLFQ) {
                p->mlfq_level++;
            }
            ready_queue_push(p);
        } else {
            p->end_time = now_sim;
            if(stats_get_speed_mode()==0) {
                printf("\033[92m   => FINISH => process=%p => total CPU used=%lu ms => time=%llu ms\033[0m\n",
                       (void*)p,
                       (unsigned long)slice,
                       (unsigned long long)os_time());
                usleep(300000);
            }
        }
    }
    return NULL;
}

/*
  Scheduler run: sets up the queue, spawns core threads, runs or calls HPC overshadow logic.
*/
void scheduler_run(process_t* list, int count) {
    reset_schedule_stats();
    if(!list || count <= 0) return;

    /* HPC overshadow is handled specially. */
    if(g_current_alg == ALG_HPC_OVERSHADOW) {
        g_stats.HPC_over_mode = 1;
        if(stats_get_speed_mode()==0){
            printf("\n\033[95m╔══════════════════════════════════════════════╗\n");
            printf(         "║       SCHEDULE NAME => HPC-OVERSHADOW        ║\n");
            printf(         "╚══════════════════════════════════════════════╝\033[0m\n");
            usleep(300000);
        }

        os_run_hpc_overshadow();

        if(stats_get_speed_mode()==0){
            printf("\033[96m╔══════════════════════════════════════════════╗\n");
            printf(       "║  SCHEDULE END => HPC-OVERSHADOW => no stats  ║\n");
            printf(       "╚══════════════════════════════════════════════╝\033[0m\n");
            usleep(300000);
        }
        return;
    }

    /* Normal scheduling run */
    if(stats_get_speed_mode()==0){
        printf("\n\033[95m╔══════════════════════════════════════════════╗\n");
        printf(         "║   SCHEDULE NAME => %d (enum)                 \n", g_current_alg);
        printf(         "║   Number of processes => %d                  \n", count);
        printf(         "║   Time start => %llu ms                      \n", (unsigned long long)os_time());
        printf(         "╚══════════════════════════════════════════════╝\033[0m\n");
        usleep(300000);
    }

    /* BFS/MLFQ => 2 cores, else 1 core. */
    switch(g_current_alg) {
    case ALG_BFS:
    case ALG_MLFQ:
        g_num_cores = 2;
        break;
    default:
        g_num_cores = 1;
        break;
    }

    ready_queue_init_policy(g_current_alg);

    g_process_list = list;
    g_list_count   = count;
    g_running      = 1;

    for(int i=0; i<count; i++) {
        ready_queue_push(&list[i]);
    }

    pthread_t tid[MAX_CORES];
    int n = (g_num_cores > MAX_CORES) ? MAX_CORES : g_num_cores;

    for(int i=0; i<n; i++) {
        pthread_create(&tid[i], NULL, core_thread_func, (void*)(long)i);
    }

    while(ready_queue_size() > 0) {
        usleep(200000);
        if(os_concurrency_stop_requested()) {
            break;
        }
    }

    g_running = 0;
    /* push 'NULL' for each core so they break out from pop() loops. */
    for(int i=0; i<n; i++) {
        ready_queue_push(NULL);
    }
    for(int i=0; i<n; i++) {
        pthread_join(tid[i], NULL);
    }

    ready_queue_destroy();
    finalize_stats();

    uint64_t total_time = get_global_sim_time();
    if(stats_get_speed_mode()==0){
        printf("\033[96m╔══════════════════════════════════════════════╗\n");
        printf(       "║ SCHEDULE END => alg=%d => totalTime=%llums    ║\n", g_current_alg, (unsigned long long)total_time);
        printf(       "║ Stats: preemptions=%llu, totalProcs=%llu     ║\n", (unsigned long long)g_stats.preemptions, (unsigned long long)g_stats.total_procs);
        printf(       "║ AvgWait=%.2f, AvgTAT=%.2f, AvgResp=%.2f       ║\n", g_stats.avg_wait, g_stats.avg_turnaround, g_stats.avg_response);
        printf(       "╚══════════════════════════════════════════════╝\033[0m\n");
        usleep(300000);
    }

    g_process_list = NULL;
    g_list_count   = 0;
}

/* Store final stats in out if HPC overshadow wasn't used. */
void scheduler_fetch_report(sched_report_t* out) {
    if(!out) return;
    if(g_stats.HPC_over_mode) {
        out->avg_wait       = 0.0;
        out->avg_turnaround = 0.0;
        out->avg_response   = 0.0;
        out->preemptions    = 0ULL;
        out->total_procs    = 0ULL;
    } else {
        out->avg_wait       = g_stats.avg_wait;
        out->avg_turnaround = g_stats.avg_turnaround;
        out->avg_response   = g_stats.avg_response;
        out->preemptions    = g_stats.preemptions;
        out->total_procs    = g_stats.total_procs;
    }
}

void scheduler_select_algorithm(scheduler_alg_t a) {
    g_current_alg = a;
}
#ifndef SCHEDULER_H
#define SCHEDULER_H

#include <stdint.h>
#include "process.h"

/*
  Recognized scheduling algorithms
*/
typedef enum {
    ALG_CFS = 0,
    ALG_CFS_SRTF,
    ALG_FIFO,
    ALG_RR,
    ALG_SJF,
    ALG_STRF,
    ALG_HRRN,
    ALG_HRRN_RT,
    ALG_BFS,
    ALG_PRIORITY,
    ALG_HPC_OVERSHADOW,
    ALG_MLFQ
} scheduler_alg_t;

/*
   We store final results of scheduling in a schedule_stats_t.
   This helps keep track of average times, preemptions, HPC mode, etc.
*/
typedef struct {
    double avg_wait;
    double avg_turnaround;
    double avg_response;
    unsigned long long preemptions;
    unsigned long long total_procs;

    /* Internal aggregator: sums for final stats. */
    uint64_t total_wait;
    uint64_t total_tat;
    uint64_t total_resp;
    unsigned long long total_preempts;
    int total_count;

    /* Flag if HPC overshadow mode => skip normal stats. */
    int HPC_over_mode;
} schedule_stats_t;

/* A simpler struct to retrieve final scheduling stats. */
typedef struct {
    double avg_wait;
    double avg_turnaround;
    double avg_response;
    unsigned long long preemptions;
    unsigned long long total_procs;
} sched_report_t;

/* Select an algorithm. */
void scheduler_select_algorithm(scheduler_alg_t a);

/* Run the scheduling simulation on an array of processes. */
void scheduler_run(process_t* list, int count);

/* Retrieve final stats from last run. HPC overshadow => zeroed stats. */
void scheduler_fetch_report(sched_report_t* out);

/* Accessor so the ready-queue can see current simulated time for HRRN, etc. */
uint64_t get_global_sim_time(void);

#endif
#include "scoreboard.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

/*
 * scoreboard.c => Implementation with new weighting:
 *   BASIC      => 25%
 *   NORMAL     => 25%
 *   MODES      => 10%
 *   EDGE       => 10%
 *   HIDDEN     => 10%
 *   EXTERNAL   => 10%
 *   SCHED MAST => 10%
 *
 * The sum is 100% across 7 categories.
 * Scheduling mastery is scored from up to 15 points, scaled to 0..100,
 * then that result is multiplied by 10% (0.10) for final contribution.
 */

/* Global scoreboard structure */
static scoreboard_t gSB = {
    /* test totals and passes: */
    0,0, 0,0, 0,0, 0,0, 0,0, 0,0,
    /* scheduling mastery flags: */
    0,0,0,0,0, 0,0,0,0,0,0,0,
    /* computed percentages for each suite: */
    0.0,0.0,0.0,0.0,0.0,0.0,
    /* pass threshold (e.g. 60.0) */
    60.0
};

/* Utility: read entire file into memory */
static char* read_file_all(const char* path) {
    FILE* f = fopen(path, "rb");
    if(!f) return NULL;
    fseek(f, 0, SEEK_END);
    long sz = ftell(f);
    if(sz < 0) {
        fclose(f);
        return NULL;
    }
    fseek(f, 0, SEEK_SET);

    char* buf = (char*)malloc((size_t)sz + 1);
    if(!buf) {
        fclose(f);
        return NULL;
    }
    if(fread(buf, 1, (size_t)sz, f) != (size_t)sz) {
        fclose(f);
        free(buf);
        return NULL;
    }
    buf[sz] = '\0';
    fclose(f);
    return buf;
}

/* Simple JSON parse helper for int */
static int parse_json_int(const char* json, const char* key, int def) {
    if(!json || !key) return def;
    char pattern[128];
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    char* found = strstr(json, pattern);
    if(!found) return def;
    char* colon = strstr(found, ":");
    if(!colon) return def;
    colon++;
    while(*colon==' '||*colon=='\t') colon++;
    int val = def;
    sscanf(colon, "%d", &val);
    return val;
}

/* Simple JSON parse helper for double */
static double parse_json_double(const char* json, const char* key, double def) {
    if(!json || !key) return def;
    char pattern[128];
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    char* found = strstr(json, pattern);
    if(!found) return def;
    char* colon = strstr(found, ":");
    if(!colon) return def;
    colon++;
    while(*colon==' '||*colon=='\t') colon++;
    double val = def;
    sscanf(colon, "%lf", &val);
    return val;
}

/* Write scoreboard to scoreboard.json */
static void write_scoreboard_json(const scoreboard_t* sb) {
    FILE* f = fopen("scoreboard.json", "w");
    if(!f) return;

    fprintf(f, "{\n");
    /* test totals + passes */
    fprintf(f, "  \"basic_total\": %d,\n",    sb->basic_total);
    fprintf(f, "  \"basic_pass\": %d,\n",     sb->basic_pass);
    fprintf(f, "  \"normal_total\": %d,\n",   sb->normal_total);
    fprintf(f, "  \"normal_pass\": %d,\n",    sb->normal_pass);
    fprintf(f, "  \"external_total\": %d,\n", sb->external_total);
    fprintf(f, "  \"external_pass\": %d,\n",  sb->external_pass);
    fprintf(f, "  \"modes_total\": %d,\n",    sb->modes_total);
    fprintf(f, "  \"modes_pass\": %d,\n",     sb->modes_pass);
    fprintf(f, "  \"edge_total\": %d,\n",     sb->edge_total);
    fprintf(f, "  \"edge_pass\": %d,\n",      sb->edge_pass);
    fprintf(f, "  \"hidden_total\": %d,\n",   sb->hidden_total);
    fprintf(f, "  \"hidden_pass\": %d,\n",    sb->hidden_pass);

    /* schedule mastery flags */
    fprintf(f, "  \"sc_fifo\": %d,\n",      sb->sc_fifo);
    fprintf(f, "  \"sc_rr\": %d,\n",        sb->sc_rr);
    fprintf(f, "  \"sc_cfs\": %d,\n",       sb->sc_cfs);
    fprintf(f, "  \"sc_cfs_srtf\": %d,\n",  sb->sc_cfs_srtf);
    fprintf(f, "  \"sc_bfs\": %d,\n",       sb->sc_bfs);
    fprintf(f, "  \"sc_sjf\": %d,\n",       sb->sc_sjf);
    fprintf(f, "  \"sc_strf\": %d,\n",      sb->sc_strf);
    fprintf(f, "  \"sc_hrrn\": %d,\n",      sb->sc_hrrn);
    fprintf(f, "  \"sc_hrrn_rt\": %d,\n",   sb->sc_hrrn_rt);
    fprintf(f, "  \"sc_priority\": %d,\n",  sb->sc_priority);
    fprintf(f, "  \"sc_hpc_over\": %d,\n",  sb->sc_hpc_over);
    fprintf(f, "  \"sc_mlfq\": %d,\n",      sb->sc_mlfq);

    /* percentages */
    fprintf(f, "  \"basic_percent\": %.3f,\n",    sb->basic_percent);
    fprintf(f, "  \"normal_percent\": %.3f,\n",   sb->normal_percent);
    fprintf(f, "  \"external_percent\": %.3f,\n", sb->external_percent);
    fprintf(f, "  \"modes_percent\": %.3f,\n",    sb->modes_percent);
    fprintf(f, "  \"edge_percent\": %.3f,\n",     sb->edge_percent);
    fprintf(f, "  \"hidden_percent\": %.3f,\n",   sb->hidden_percent);

    /* pass threshold */
    fprintf(f, "  \"pass_threshold\": %.1f\n",    sb->pass_threshold);
    fprintf(f, "}\n");

    fclose(f);
}

/* scoreboard_init() / scoreboard_close() => no-op */
void scoreboard_init(void) {}
void scoreboard_close(void) {}

/* Load from scoreboard.json */
void scoreboard_load(void) {
    char* json = read_file_all("scoreboard.json");
    if(!json) return;

    gSB.basic_total    = parse_json_int(json,"basic_total",    gSB.basic_total);
    gSB.basic_pass     = parse_json_int(json,"basic_pass",     gSB.basic_pass);
    gSB.normal_total   = parse_json_int(json,"normal_total",   gSB.normal_total);
    gSB.normal_pass    = parse_json_int(json,"normal_pass",    gSB.normal_pass);
    gSB.external_total = parse_json_int(json,"external_total", gSB.external_total);
    gSB.external_pass  = parse_json_int(json,"external_pass",  gSB.external_pass);
    gSB.modes_total    = parse_json_int(json,"modes_total",    gSB.modes_total);
    gSB.modes_pass     = parse_json_int(json,"modes_pass",     gSB.modes_pass);
    gSB.edge_total     = parse_json_int(json,"edge_total",     gSB.edge_total);
    gSB.edge_pass      = parse_json_int(json,"edge_pass",      gSB.edge_pass);
    gSB.hidden_total   = parse_json_int(json,"hidden_total",   gSB.hidden_total);
    gSB.hidden_pass    = parse_json_int(json,"hidden_pass",    gSB.hidden_pass);

    gSB.sc_fifo     = parse_json_int(json,"sc_fifo",     gSB.sc_fifo);
    gSB.sc_rr       = parse_json_int(json,"sc_rr",       gSB.sc_rr);
    gSB.sc_cfs      = parse_json_int(json,"sc_cfs",      gSB.sc_cfs);
    gSB.sc_cfs_srtf = parse_json_int(json,"sc_cfs_srtf", gSB.sc_cfs_srtf);
    gSB.sc_bfs      = parse_json_int(json,"sc_bfs",      gSB.sc_bfs);
    gSB.sc_sjf      = parse_json_int(json,"sc_sjf",      gSB.sc_sjf);
    gSB.sc_strf     = parse_json_int(json,"sc_strf",     gSB.sc_strf);
    gSB.sc_hrrn     = parse_json_int(json,"sc_hrrn",     gSB.sc_hrrn);
    gSB.sc_hrrn_rt  = parse_json_int(json,"sc_hrrn_rt",  gSB.sc_hrrn_rt);
    gSB.sc_priority = parse_json_int(json,"sc_priority", gSB.sc_priority);
    gSB.sc_hpc_over = parse_json_int(json,"sc_hpc_over", gSB.sc_hpc_over);
    gSB.sc_mlfq     = parse_json_int(json,"sc_mlfq",     gSB.sc_mlfq);

    gSB.basic_percent    = parse_json_double(json,"basic_percent",    gSB.basic_percent);
    gSB.normal_percent   = parse_json_double(json,"normal_percent",   gSB.normal_percent);
    gSB.external_percent = parse_json_double(json,"external_percent", gSB.external_percent);
    gSB.modes_percent    = parse_json_double(json,"modes_percent",    gSB.modes_percent);
    gSB.edge_percent     = parse_json_double(json,"edge_percent",     gSB.edge_percent);
    gSB.hidden_percent   = parse_json_double(json,"hidden_percent",   gSB.hidden_percent);

    gSB.pass_threshold   = parse_json_double(json,"pass_threshold",   gSB.pass_threshold);

    free(json);
}

/* Recompute pass% from total/pass counts */
static void recompute_pass_percents(void) {
    if(gSB.basic_total > 0)
        gSB.basic_percent = (100.0 * (double)gSB.basic_pass) / (double)gSB.basic_total;
    else
        gSB.basic_percent = 0.0;

    if(gSB.normal_total > 0)
        gSB.normal_percent = (100.0 * (double)gSB.normal_pass) / (double)gSB.normal_total;
    else
        gSB.normal_percent = 0.0;

    if(gSB.external_total > 0)
        gSB.external_percent = (100.0 * (double)gSB.external_pass) / (double)gSB.external_total;
    else
        gSB.external_percent = 0.0;

    if(gSB.modes_total > 0)
        gSB.modes_percent = (100.0 * (double)gSB.modes_pass) / (double)gSB.modes_total;
    else
        gSB.modes_percent = 0.0;

    if(gSB.edge_total > 0)
        gSB.edge_percent = (100.0 * (double)gSB.edge_pass) / (double)gSB.edge_total;
    else
        gSB.edge_percent = 0.0;

    if(gSB.hidden_total > 0)
        gSB.hidden_percent = (100.0 * (double)gSB.hidden_pass) / (double)gSB.hidden_total;
    else
        gSB.hidden_percent = 0.0;
}

/*
  The chain unlocking logic:
    BASIC => always unlocked
    NORMAL => unlocked if BASIC >= pass_threshold
    EXTERNAL => unlocked if NORMAL >= pass_threshold
    MODES => unlocked if EXTERNAL >= pass_threshold
    EDGE => unlocked if MODES >= pass_threshold
    HIDDEN => unlocked if EDGE >= pass_threshold
*/
static int is_suite_unlocked(scoreboard_suite_t suite) {
    if(suite == SUITE_BASIC) {
        return 1;
    }
    double T = gSB.pass_threshold;
    switch(suite) {
        case SUITE_NORMAL:
            return (gSB.basic_percent >= T) ? 1 : 0;
        case SUITE_EXTERNAL:
            return (gSB.normal_percent >= T) ? 1 : 0;
        case SUITE_MODES:
            return (gSB.normal_percent >= T) ? 1 : 0;
        case SUITE_EDGE:
            return (gSB.modes_percent >= T) ? 1 : 0;
        case SUITE_HIDDEN:
            return (gSB.edge_percent >= T) ? 1 : 0;
        default:
            return 0;
    }
}

/* BFS=2, HPC=2, MLFQ=2, others=1 => up to 15 points */
static int get_scheduler_points(void) {
    int points = 0;
    if(gSB.sc_fifo)         points += 2;
    if(gSB.sc_rr)           points += 2;
    if(gSB.sc_cfs)          points += 1;
    if(gSB.sc_cfs_srtf)     points += 1;
    if(gSB.sc_bfs)          points += 1;
    if(gSB.sc_sjf)          points += 2;
    if(gSB.sc_strf)         points += 1;
    if(gSB.sc_hrrn)         points += 1;
    if(gSB.sc_hrrn_rt)      points += 1;
    if(gSB.sc_priority)     points += 1;
    if(gSB.sc_hpc_over)     points += 1;
    if(gSB.sc_mlfq)         points += 1;
    return points;
}

/* Save scoreboard => JSON after recomputing percentages */
void scoreboard_save(void) {
    recompute_pass_percents();
    write_scoreboard_json(&gSB);
}

/* Clear scoreboard entirely and set pass_threshold=60.0 default */
void scoreboard_clear(void) {
    memset(&gSB, 0, sizeof(gSB));
    gSB.pass_threshold = 60.0;
    scoreboard_save();
}

/* Return a copy of the scoreboard struct */
void get_scoreboard(scoreboard_t* out) {
    if(out) {
        *out = gSB;
    }
}

/*
  Weighted final score => integer from 0..100
   - BASIC:    25%
   - NORMAL:   25%
   - MODES:    10%
   - EDGE:     10%
   - HIDDEN:   10%
   - EXTERNAL: 10%
   - SCHEDULING MASTERY: 10%
*/
int scoreboard_get_final_score(void) {
    recompute_pass_percents();

    double b  = gSB.basic_percent    * 0.25;  /* 25%  */
    double n  = gSB.normal_percent   * 0.25;  /* 25%  */
    double mo = gSB.modes_percent    * 0.10;  /* 10%  */
    double ed = gSB.edge_percent     * 0.10;  /* 10%  */
    double hi = gSB.hidden_percent   * 0.10;  /* 10%  */
    double ex = gSB.external_percent * 0.10;  /* 10%  */

    /* scheduling mastery => 10% portion */
    int sched_pts = get_scheduler_points();  /* up to 15 => map to 0..100 => scaled => then 10% portion */
    double sched_percent = ((double)sched_pts / 15.0) * 100.0;
    double s = sched_percent * 0.10;

    double total = b + n + mo + ed + hi + ex + s;
    if(total > 100.0) total=100.0;
    if(total < 0.0)   total=0.0;
    return (int)(total + 0.5);
}

/* Return whether the given suite is unlocked */
int scoreboard_is_unlocked(scoreboard_suite_t suite) {
    recompute_pass_percents();
    return is_suite_unlocked(suite);
}

/* Mark an algorithm as "mastered" => for scheduling mastery points */
void scoreboard_set_sc_mastered(scheduler_alg_t alg) {
    switch(alg) {
        case ALG_FIFO:          gSB.sc_fifo      = 1; break;
        case ALG_RR:            gSB.sc_rr        = 1; break;
        case ALG_CFS:           gSB.sc_cfs       = 1; break;
        case ALG_CFS_SRTF:      gSB.sc_cfs_srtf  = 1; break;
        case ALG_BFS:           gSB.sc_bfs       = 1; break;
        case ALG_SJF:           gSB.sc_sjf       = 1; break;
        case ALG_STRF:          gSB.sc_strf      = 1; break;
        case ALG_HRRN:          gSB.sc_hrrn      = 1; break;
        case ALG_HRRN_RT:       gSB.sc_hrrn_rt   = 1; break;
        case ALG_PRIORITY:      gSB.sc_priority  = 1; break;
        case ALG_HPC_OVERSHADOW:gSB.sc_hpc_over  = 1; break;
        case ALG_MLFQ:          gSB.sc_mlfq      = 1; break;
        default:
            break;
    }
}

/* Increment basic test stats */
void scoreboard_update_basic(int total, int pass) {
    gSB.basic_total += total;
    gSB.basic_pass  += pass;
}

/* Increment normal test stats */
void scoreboard_update_normal(int total, int pass) {
    gSB.normal_total += total;
    gSB.normal_pass  += pass;
}

/* Increment external test stats */
void scoreboard_update_external(int total, int pass) {
    gSB.external_total += total;
    gSB.external_pass  += pass;
}

/* Increment modes test stats */
void scoreboard_update_modes(int total, int pass) {
    gSB.modes_total += total;
    gSB.modes_pass  += pass;
}

/* Increment edge test stats */
void scoreboard_update_edge(int total, int pass) {
    gSB.edge_total += total;
    gSB.edge_pass  += pass;
}

/* Increment hidden test stats */
void scoreboard_update_hidden(int total, int pass) {
    gSB.hidden_total += total;
    gSB.hidden_pass  += pass;
}
#ifndef SCOREBOARD_H
#define SCOREBOARD_H

#include "scheduler.h"

/* Enum to identify a test suite. */
typedef enum {
    SUITE_BASIC = 1,
    SUITE_NORMAL,
    SUITE_EXTERNAL,
    SUITE_MODES,
    SUITE_EDGE,
    SUITE_HIDDEN,
    SUITE_COUNT
} scoreboard_suite_t;

/*
  Structure for scoreboard data.
*/
typedef struct {
    int basic_total,    basic_pass;
    int normal_total,   normal_pass;
    int external_total, external_pass;
    int modes_total,    modes_pass;
    int edge_total,     edge_pass;
    int hidden_total,   hidden_pass;

    /* Mastery flags for scheduling algorithms. */
    int sc_fifo, sc_rr, sc_cfs, sc_cfs_srtf, sc_bfs;
    int sc_sjf, sc_strf, sc_hrrn, sc_hrrn_rt, sc_priority;
    int sc_hpc_over, sc_mlfq;

    double basic_percent;
    double normal_percent;
    double external_percent;
    double modes_percent;
    double edge_percent;
    double hidden_percent;

    /* Passing threshold for unlocking next suite. */
    double pass_threshold;
} scoreboard_t;

/* Initialize scoreboard (no-op). */
void scoreboard_init(void);

/* Close scoreboard (no-op). */
void scoreboard_close(void);

/* Load from scoreboard.json -> internal scoreboard. */
void scoreboard_load(void);

/* Save scoreboard -> scoreboard.json. */
void scoreboard_save(void);

/* Clear scoreboard entirely. */
void scoreboard_clear(void);

/* Retrieve scoreboard snapshot. */
void get_scoreboard(scoreboard_t* out);

/* Returns final overall score (0..100). */
int  scoreboard_get_final_score(void);

/* Mark that we have "mastered" a scheduling algorithm. */
void scoreboard_set_sc_mastered(scheduler_alg_t alg);

/* Update raw counts for each test suite. */
void scoreboard_update_basic(int total, int pass);
void scoreboard_update_normal(int total, int pass);
void scoreboard_update_external(int total,int pass);
void scoreboard_update_modes(int total,int pass);
void scoreboard_update_edge(int total,int pass);
void scoreboard_update_hidden(int total,int pass);

/* Check if suite is unlocked. (Basic is always unlocked at game start.) */
int scoreboard_is_unlocked(scoreboard_suite_t suite);

#endif
#include "stats.h"
#include <stdio.h>
#include <string.h>

/* Global stats object. */
static stats_t g_stats;

void stats_init(void) {
    memset(&g_stats, 0, sizeof(g_stats));
    g_stats.speed_mode = 0; /* default => normal speed */
}

void stats_get(stats_t* out) {
    if(out) {
        *out = g_stats;
    }
}

void stats_set_speed_mode(int mode) {
    g_stats.speed_mode = (mode != 0) ? 1 : 0;
}

int stats_get_speed_mode(void) {
    return g_stats.speed_mode;
}

void stats_inc_signal_sigint(void) {
    g_stats.signals_received_sigint++;
}
void stats_inc_signal_sigterm(void) {
    g_stats.signals_received_sigterm++;
}
void stats_inc_signal_other(void) {
    g_stats.signals_received_others++;
}
void stats_inc_concurrency_runs(void) {
    g_stats.concurrency_runs++;
}
void stats_inc_processes_spawned(void) {
    g_stats.processes_spawned++;
}
void stats_inc_containers_created(void) {
    g_stats.containers_created++;
}
void stats_inc_containers_removed(void) {
    g_stats.containers_removed++;
}
void stats_inc_tests_passed(int count) {
    g_stats.tests_passed += count;
}
void stats_inc_tests_failed(int count) {
    g_stats.tests_failed += count;
}
void stats_inc_concurrency_commands(int n) {
    g_stats.concurrency_commands_run += n;
}

/*
  Print final stats with nice ASCII box.
*/
void stats_print_summary(void) {
    printf(CLR_BOLD CLR_CYAN "\n╔═══════════════════ FINAL STATS ═════════════════╗\n");
    printf("║ Speed Mode            : %s\n", g_stats.speed_mode ? "FAST" : "NORMAL");
    printf("║ Signals (SIGINT)      : %d\n", g_stats.signals_received_sigint);
    printf("║ Signals (SIGTERM)     : %d\n", g_stats.signals_received_sigterm);
    printf("║ Signals (Others)      : %d\n", g_stats.signals_received_others);
    printf("║ Concurrency Runs      : %d\n", g_stats.concurrency_runs);
    printf("║ Processes Spawned     : %d\n", g_stats.processes_spawned);
    printf("║ Containers Created    : %d\n", g_stats.containers_created);
    printf("║ Containers Removed    : %d\n", g_stats.containers_removed);
    printf("║ Tests Passed          : %d\n", g_stats.tests_passed);
    printf("║ Tests Failed          : %d\n", g_stats.tests_failed);
    printf("║ Concurrency Cmds Run  : %d\n", g_stats.concurrency_commands_run);
    printf("╚═════════════════════════════════════════════════╝\n" CLR_RESET);
}
#ifndef STATS_H
#define STATS_H

/*
   stats.h => a global struct tracking concurrency usage, signals, tests, etc.
   Also color macros for convenient printing.
*/

#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GREEN   "\033[92m"
#define CLR_GRAY    "\033[90m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

typedef struct {
    int signals_received_sigint;
    int signals_received_sigterm;
    int signals_received_others;

    int concurrency_runs;
    int processes_spawned;
    int containers_created;
    int containers_removed;

    int tests_passed;
    int tests_failed;

    /* speed_mode: 0 => normal, 1 => fast */
    int speed_mode;

    /* track total concurrency commands issued in runner. */
    int concurrency_commands_run;

} stats_t;

/* Initialize global stats. */
void stats_init(void);

/* Get the global stats. */
void stats_get(stats_t* out);

/* set speed_mode (0 or 1). */
void stats_set_speed_mode(int mode);

/* get speed_mode. */
int stats_get_speed_mode(void);

/* increments for various tracked fields. */
void stats_inc_signal_sigint(void);
void stats_inc_signal_sigterm(void);
void stats_inc_signal_other(void);
void stats_inc_concurrency_runs(void);
void stats_inc_processes_spawned(void);
void stats_inc_containers_created(void);
void stats_inc_containers_removed(void);
void stats_inc_tests_passed(int count);
void stats_inc_tests_failed(int count);
void stats_inc_concurrency_commands(int n);

/* Print them in a block at program end. */
void stats_print_summary(void);

#endif
#include "worker.h"
#include "stats.h"
#include <stdio.h>
#include <unistd.h>

/*
  We drastically reduce real-time sleeps to ensure that
  in FAST mode, all tests can finish under ~5 seconds total.

  We'll define a new scaling:
    - In NORMAL mode: usleep(slice_ms * 20000)
    - In FAST mode:   usleep(slice_ms * 2000)
  This is a ~10x difference. That should keep normal mode somewhat slow
  and fast mode quite quick.
*/

void simulate_process_partial(process_t* p, unsigned long slice_ms, int core_id) {
    if (!p || slice_ms == 0) return;

    if(stats_get_speed_mode() == 0) {
        /* NORMAL mode => bigger sleep for user-friendly pacing */
        usleep((useconds_t)(slice_ms * 20000U));
    } else {
        /* FAST mode => short sleep to finish quickly slice_ms = 1/50 */
        usleep((useconds_t)(slice_ms * 2000U));
    }
}
#ifndef WORKER_H
#define WORKER_H

#include "process.h"

/*
  Worker simulation => runs a process for some (partial) timeslice
  by sleeping that many ms in real-time (scaled for concurrency).
*/

/* Simulate a partial run of 'p' for slice_ms. */
void simulate_process_partial(process_t* p, unsigned long slice_ms, int core_id);

#endif
#include "basic-test.h"
#include "test_common.h"

#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include "../src/worker.h"

#include <stdio.h>
#include <math.h>

/* Global counters for run_basic_tests() usage: */
static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

/* Helper: approximate float eq */
static int almost_equal(double a, double b, double eps) {
    return (fabs(a - b) < eps);
}

/* ---------- Actual test functions ---------- */
static bool test_fifo(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 1, 0);
    init_process(&p[1], 5, 1, 0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.5, t=5.5, r=1.5;
    if (!almost_equal(rep.avg_wait, w, 0.1) ||
        !almost_equal(rep.avg_turnaround, t, 0.1) ||
        !almost_equal(rep.avg_response, r, 0.1) ||
        rep.preemptions != 0ULL)
    {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_fifo => mismatch, got W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_FIFO);
    return true;
}

static bool test_rr(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0], 2, 1, 0);
    init_process(&p[1], 2, 1, 0);

    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.0, t=3.0, r=1.0;
    if (!almost_equal(rep.avg_wait, w, 0.2) ||
        !almost_equal(rep.avg_turnaround, t, 0.2) ||
        !almost_equal(rep.avg_response, r, 0.2) ||
        rep.preemptions != 0ULL)
    {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_rr => mismatch, got W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_RR);
    return true;
}

static bool test_cfs(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 0, 0);
    init_process(&p[1], 4, 0, 0);

    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    double w=1.5, t=5.0, r=1.5;
    if (!almost_equal(rep.avg_wait, w, 0.2) ||
        !almost_equal(rep.avg_turnaround, t, 0.3) ||
        !almost_equal(rep.avg_response, r, 0.2) ||
        rep.preemptions != 0ULL)
    {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_cfs => mismatch => W=%.2f,T=%.2f,R=%.2f, pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS);
    return true;
}

static bool test_bfs(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0], 2, 1, 0);
    init_process(&p[1], 3, 1, 0);
    init_process(&p[2], 4, 1, 0);

    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p, 3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.total_procs != 3 || rep.preemptions < 1) {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_bfs => mismatch => procs=%llu, preempts=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_BFS);
    return true;
}

static bool test_pipeline(void) {
    g_tests_run++;
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}

static bool test_distributed(void) {
    g_tests_run++;
    os_init();
    os_run_distributed_example();
    os_cleanup();
    return true;
}

static bool test_fifo_strict(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 10, 0);
    init_process(&p[1], 4, 20, 0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p, 2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if (rep.preemptions != 0ULL) {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_fifo_strict => mismatch => preempt=%llu",
                 rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

/* Array of all basic tests so we can run them individually or in bulk */
typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} basic_tests[] = {
    { "fifo",           test_fifo },
    { "rr",             test_rr },
    { "cfs",            test_cfs },
    { "bfs",            test_bfs },
    { "pipeline",       test_pipeline },
    { "distributed",    test_distributed },
    { "fifo_strict",    test_fifo_strict },
};
static const int BASIC_COUNT = sizeof(basic_tests)/sizeof(basic_tests[0]);

/* Public API: get number of tests in Basic suite */
int basic_test_count(void) {
    return BASIC_COUNT;
}

/* Public API: get name of ith test in Basic suite */
const char* basic_test_name(int i) {
    if(i<0 || i>=BASIC_COUNT) return NULL;
    return basic_tests[i].name;
}

/* Public API: run the ith single test in Basic suite.
   pass_out=1 if test passed, else 0.
*/
void basic_test_run_single(int i, int* pass_out) {
    if(!pass_out) return;
    if(i<0 || i>=BASIC_COUNT) {
        *pass_out=0;
        return;
    }
    /* reset counters for single test run */
    g_tests_run=0;
    g_tests_failed=0;
    memset(g_fail_reason,0,sizeof(g_fail_reason));

    /* run it */
    bool ok = basic_tests[i].func();
    if(!ok) {
        *pass_out=0;
        return;
    }
    /* if not failed => pass */
    *pass_out = (g_tests_failed==0) ? 1 : 0;
}

/* Public API: run all Basic tests in a row */
void run_basic_tests(int* total, int* passed){
    g_tests_run=0;
    g_tests_failed=0;
    memset(g_fail_reason,0,sizeof(g_fail_reason));

    printf("\n" CLR_BOLD CLR_YELLOW "╔════════════ BASIC TESTS START ═════════════╗" CLR_RESET "\n");
    for(int i=0; i<BASIC_COUNT; i++){
        bool ok = basic_tests[i].func();
        if(ok) {
            printf("  PASS: %s\n", basic_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n",
                   basic_tests[i].name,
                   test_get_fail_reason());
        }
    }

    *total  = g_tests_run;
    *passed = g_tests_run - g_tests_failed;

    printf(CLR_BOLD CLR_YELLOW "╔══════════════════════════════════════════════╗\n");
    printf("║       BASIC TESTS RESULTS: %d / %d passed      ║\n", *passed, *total);
    if(*passed < *total) {
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\n" CLR_RESET);
}
#ifndef BASIC_TEST_H
#define BASIC_TEST_H

/*
  Basic tests: FIFO, RR, CFS, BFS, pipeline, distributed, etc.
  We also provide single-test picking if needed.
*/

void run_basic_tests(int* total,int* passed);
int basic_test_count(void);
void basic_test_run_single(int i, int* pass_out);

#endif
#include "edge-test.h"
#include "test_common.h"

#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

static int almost_equal(double a, double b, double eps) {
    return (fabs(a - b) < eps);
}

static bool test_extreme_long(void) {
    g_tests_run++;
    os_init();
    process_t p[1];
    init_process(&p[0],50,2,0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=1 || rep.preemptions!=0ULL) {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
                 "test_extreme_long => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    /* partial check of W/T */
    if(!almost_equal(rep.avg_wait,0.0,0.9) ||
       !almost_equal(rep.avg_turnaround,50.0,5.0))
    {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_extreme_long => stats mismatch => W=%.2f,T=%.2f",
                 rep.avg_wait, rep.avg_turnaround);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_extreme_short(void) {
    g_tests_run++;
    os_init();
    process_t p[1];
    init_process(&p[0],1,2,0);

    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=1 || rep.preemptions!=0ULL) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_extreme_short => mismatch => procs=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    if(!almost_equal(rep.avg_wait, 0.0, 0.5) ||
       !almost_equal(rep.avg_turnaround,1.0,0.5))
    {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_extreme_short => mismatch => W=%.2f,T=%.2f",
                 rep.avg_wait, rep.avg_turnaround);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_high_load(void) {
    g_tests_run++;
    os_init();
    process_t arr[10];
    for(int i=0;i<10;i++){
        init_process(&arr[i],3+(i%3), 1, 0);
    }
    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(arr,10);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs != 10) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_high_load => mismatch => total=%llu",
                 rep.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_hpc_under_load(void) {
    g_tests_run++;
    os_init();
    os_run_hpc_overshadow();
    os_cleanup();
    return true;
}

static bool test_container_spam(void) {
    g_tests_run++;
    os_init();
    for (int i=0;i<3;i++){
        os_create_ephemeral_container();
    }
    for (int i=0;i<3;i++){
        os_remove_ephemeral_container();
    }
    os_cleanup();
    return true;
}

static bool test_pipeline_edge(void) {
    g_tests_run++;
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}

static bool test_multi_distrib(void) {
    g_tests_run++;
    os_init();
    for(int i=0;i<3;i++){
        os_run_distributed_example();
    }
    os_cleanup();
    return true;
}

typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} edge_tests[] = {
    {"extreme_long",   test_extreme_long},
    {"extreme_short",  test_extreme_short},
    {"high_load",      test_high_load},
    {"hpc_under_load", test_hpc_under_load},
    {"container_spam", test_container_spam},
    {"pipeline_edge",  test_pipeline_edge},
    {"multi_distrib",  test_multi_distrib}
};
static const int EDGE_COUNT = sizeof(edge_tests)/sizeof(edge_tests[0]);

int edge_test_count(void){ return EDGE_COUNT; }
const char* edge_test_name(int i){
    if(i<0||i>=EDGE_COUNT) return NULL;
    return edge_tests[i].name;
}

void edge_test_run_single(int i,int* pass_out){
    if(!pass_out) return;
    if(i<0||i>=EDGE_COUNT){
        *pass_out=0;
        return;
    }
    g_tests_run=0;
    g_tests_failed=0;
    bool ok = edge_tests[i].func();
    *pass_out = (ok && g_tests_failed==0) ? 1 : 0;
}

void run_edge_tests(int* total,int* passed){
    g_tests_run=0;
    g_tests_failed=0;

    printf("\n\033[1m\033[93m╔════════════ EDGE TESTS START ═══════════╗\033[0m\n");
    for(int i=0;i<EDGE_COUNT;i++){
        bool ok = edge_tests[i].func();
        if(ok){
            printf("  PASS: %s\n", edge_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n", edge_tests[i].name, test_get_fail_reason());
        }
    }

    *total = g_tests_run;
    *passed= (g_tests_run - g_tests_failed);

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║      EDGE TESTS RESULTS: %d / %d passed        ║\n", *passed, *total);
    if(*passed < *total){
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef EDGE_TEST_H
#define EDGE_TEST_H

/* Edge tests: extreme bursts, HPC under load, container spam, pipeline, etc. */

void run_edge_tests(int* total,int* passed);
int edge_test_count(void);
void edge_test_run_single(int i, int* pass_out);

#endif
#include "external-test.h"
#include "test_common.h"

#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/scoreboard.h"
#include "../src/runner.h"

#include <stdio.h>
#include <unistd.h>
#include <string.h>

static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

/* HPC overshadow test */
static bool test_external_hpc(void) {
    g_tests_run++;
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=0){
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_external_hpc => expected total_procs=0, got %llu",
                 (unsigned long long)rep.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HPC_OVERSHADOW);
    return true;
}

/* BFS partial test */
static bool test_external_bfs(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=2 || rep.preemptions<1){
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_external_bfs => mismatch => procs=%llu, preempts=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_BFS);
    return true;
}

/* Shell concurrency sample test => just run 2 commands with FIFO. */
static bool test_run_shell_concurrency(void) {
    g_tests_run++;
    int count=2;
    char* lines[2];
    lines[0] = "sleep 2";
    lines[1] = "sleep 3";

    run_shell_commands_concurrently(count, lines, 1, ALG_FIFO, 0);
    /* Not strictly verifying output, just ensuring it runs without error. */
    return true;
}

/* array of external tests */
typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} external_tests[] = {
    {"hpc_over",           test_external_hpc},
    {"bfs_partial",        test_external_bfs},
    {"shell_concurrency",  test_run_shell_concurrency}
};
static const int EXTERNAL_COUNT = sizeof(external_tests)/sizeof(external_tests[0]);

int external_test_count(void){ return EXTERNAL_COUNT; }
const char* external_test_name(int i){
    if(i<0||i>=EXTERNAL_COUNT) return NULL;
    return external_tests[i].name;
}
void external_test_run_single(int i,int* pass_out){
    if(!pass_out) return;
    if(i<0||i>=EXTERNAL_COUNT){
        *pass_out=0;
        return;
    }
    g_tests_run=0;
    g_tests_failed=0;
    bool ok = external_tests[i].func();
    *pass_out = (ok && g_tests_failed==0)?1:0;
}

void run_external_tests(void) {
    printf("\n\033[1m\033[93m╔═════════ EXTERNAL TESTS START ═════════╗\033[0m\n");
    g_tests_run=0;
    g_tests_failed=0;
    for(int i=0; i<EXTERNAL_COUNT; i++){
        bool ok = external_tests[i].func();
        if(ok){
            printf("  PASS: %s\n", external_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n", external_tests[i].name, test_get_fail_reason());
        }
    }

    /* scoreboard update done in runner or main menu caller */
    printf("\033[1m\033[93m╔════════════════════════════════════════════╗\n");
    printf("║   EXTERNAL TESTS RESULTS: %d / %d passed     ║\n",
           (g_tests_run - g_tests_failed), g_tests_run);
    if(g_tests_failed>0) {
        printf("║   FAILURES => see logs above              ║\n");
    }
    printf("╚════════════════════════════════════════════╝\033[0m\n");
}
#ifndef EXTERNAL_TEST_H
#define EXTERNAL_TEST_H

/*
  External tests: HPC overshadow, BFS partial, concurrency.
*/

void run_external_tests(void);
int external_test_count(void);
void external_test_run_single(int i, int* pass_out);

#endif
#include "hidden-test.h"
#include "test_common.h"

#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

static bool test_distrib_heavy(void) {
    g_tests_run++;
    os_init();
    for(int i=0;i<4;i++){
        os_run_distributed_example();
    }
    os_cleanup();
    return true;
}

static bool test_hpc_heavy(void) {
    g_tests_run++;
    os_init();
    process_t dummy[1];
    init_process(&dummy[0],0,0,0);

    for(int i=0;i<2;i++){
        scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
        scheduler_run(dummy,1);
        sched_report_t rep;
        scheduler_fetch_report(&rep);
        if(rep.total_procs!=0){
            snprintf(g_fail_reason,sizeof(g_fail_reason),
                     "test_hpc_heavy => overshadow => got total_procs=%llu, expected=0",
                     rep.total_procs);
            test_set_fail_reason(g_fail_reason);
            g_tests_failed++;
            os_cleanup();
            return false;
        }
    }
    os_cleanup();
    return true;
}

static bool test_container_combo(void) {
    g_tests_run++;
    os_init();
    os_create_ephemeral_container();
    os_run_distributed_example();
    os_run_hpc_overshadow();
    os_remove_ephemeral_container();
    os_cleanup();
    return true;
}

static bool test_scheduling_variety(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    /* SJF first */
    init_process(&p[0],2,1,0);
    init_process(&p[1],6,2,0);
    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs!=2){
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_scheduling_variety => SJF => mismatch => total=%llu",
                 r1.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        os_cleanup();
        return false;
    }

    /* Priority next */
    init_process(&p[0],2,3,0);
    init_process(&p[1],6,1,0);
    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,2);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    os_cleanup();

    if(r2.total_procs!=2){
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_scheduling_variety => Priority => mismatch => total=%llu",
                 r2.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_auto_logic(void) {
    g_tests_run++;
    /* always pass */
    return true;
}

static bool test_final_integration(void) {
    g_tests_run++;
    os_init();
    os_log("Final synergy HPC + container + pipeline + distributed");
    os_create_ephemeral_container();
    os_run_hpc_overshadow();
    os_run_distributed_example();
    os_pipeline_example();
    os_remove_ephemeral_container();
    os_cleanup();
    return true;
}

static bool test_multi_stage_distributed(void) {
    g_tests_run++;
    os_init();
    os_run_distributed_example();

    process_t dummy[1];
    init_process(&dummy[0],0,0,0);
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs!=0){
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_multi_stage_distributed => overshadow #1 => got %llu procs,expected=0",
                 r1.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        os_cleanup();
        return false;
    }

    os_run_distributed_example();
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    os_cleanup();
    if(r2.total_procs!=0){
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_multi_stage_distributed => overshadow #2 => got %llu procs,expected=0",
                 r2.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} hidden_tests[] = {
    {"distrib_heavy",        test_distrib_heavy},
    {"hpc_heavy",            test_hpc_heavy},
    {"container_combo",      test_container_combo},
    {"scheduling_variety",   test_scheduling_variety},
    {"auto_logic",           test_auto_logic},
    {"final_integration",    test_final_integration},
    {"multi_stage_distributed", test_multi_stage_distributed}
};
static const int HIDDEN_COUNT = sizeof(hidden_tests)/sizeof(hidden_tests[0]);

int hidden_test_count(void){ return HIDDEN_COUNT; }
const char* hidden_test_name(int i){
    if(i<0||i>=HIDDEN_COUNT) return NULL;
    return hidden_tests[i].name;
}
void hidden_test_run_single(int i,int* pass_out){
    if(!pass_out) return;
    if(i<0||i>=HIDDEN_COUNT){
        *pass_out=0;
        return;
    }
    g_tests_run=0;
    g_tests_failed=0;
    bool ok = hidden_tests[i].func();
    *pass_out = (ok && g_tests_failed==0)?1:0;
}

void run_hidden_tests(int* total,int* passed){
    g_tests_run=0;
    g_tests_failed=0;

    printf("\n\033[1m\033[93m╔══════════ HIDDEN TESTS START ══════════╗\033[0m\n");
    for(int i=0;i<HIDDEN_COUNT;i++){
        bool ok = hidden_tests[i].func();
        if(ok){
            printf("  PASS: %s\n", hidden_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n", hidden_tests[i].name, test_get_fail_reason());
        }
    }

    *total = g_tests_run;
    *passed= (g_tests_run - g_tests_failed);

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║      HIDDEN TESTS RESULTS: %d / %d passed      ║\n", *passed, *total);
    if(*passed < *total){
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef HIDDEN_TEST_H
#define HIDDEN_TEST_H

/* Hidden tests: synergy HPC + containers + distributed, advanced scheduling variety, etc. */

void run_hidden_tests(int* total,int* passed);
int hidden_test_count(void);
void hidden_test_run_single(int i, int* pass_out);
#endif
#include "modes-test.h"
#include "test_common.h"

#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/process.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

static int almost_equal(double a, double b, double eps) {
    return (fabs(a - b) < eps);
}

/* HPC overshadow */
static bool test_hpc_over(void) {
    g_tests_run++;
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy, 1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=0 || rep.preemptions!=0ULL) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_hpc_over => mismatch => procs=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HPC_OVERSHADOW);
    return true;
}

static bool test_multi_containers(void) {
    g_tests_run++;
    os_init();
    for(int i=0;i<2;i++){
        os_create_ephemeral_container();
    }
    for(int i=0;i<2;i++){
        os_remove_ephemeral_container();
    }
    os_cleanup();
    return true;
}

static bool test_multi_distrib(void) {
    g_tests_run++;
    os_init();
    os_run_distributed_example();
    os_run_distributed_example();
    os_cleanup();
    return true;
}

static bool test_pipeline_modes(void) {
    g_tests_run++;
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}

static bool test_mix_algos(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);
    sched_report_t r1;
    scheduler_fetch_report(&r1);

    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,2);
    sched_report_t r2;
    scheduler_fetch_report(&r2);

    os_cleanup();
    if(r1.total_procs!=2 || r2.total_procs!=2) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_mix_algos => mismatch => r1procs=%llu, r2procs=%llu",
                 r1.total_procs, r2.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_double_hpc(void) {
    g_tests_run++;
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r1;
    scheduler_fetch_report(&r1);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r2;
    scheduler_fetch_report(&r2);

    os_cleanup();

    if(r1.total_procs!=0 || r2.total_procs!=0) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_double_hpc => mismatch => r1=%llu, r2=%llu",
                 r1.total_procs, r2.total_procs);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

static bool test_mlfq_check(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0],2,10,0);
    init_process(&p[1],3,20,0);
    init_process(&p[2],4,30,0);

    scheduler_select_algorithm(ALG_MLFQ);
    scheduler_run(p,3);

    sched_report_t r;
    scheduler_fetch_report(&r);
    os_cleanup();

    if(r.total_procs!=3 || r.preemptions<1) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_mlfq_check => mismatch => procs=%llu, preempts=%llu",
                 r.total_procs, r.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_MLFQ);
    return true;
}

/* array of all modes tests */
typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} modes_tests[] = {
    {"hpc_over",        test_hpc_over},
    {"multi_containers",test_multi_containers},
    {"multi_distrib",   test_multi_distrib},
    {"pipeline_modes",  test_pipeline_modes},
    {"mix_algos",       test_mix_algos},
    {"double_hpc",      test_double_hpc},
    {"mlfq_check",      test_mlfq_check}
};
static const int MODES_COUNT = sizeof(modes_tests)/sizeof(modes_tests[0]);

int modes_test_count(void){ return MODES_COUNT; }
const char* modes_test_name(int i){
    if(i<0 || i>=MODES_COUNT) return NULL;
    return modes_tests[i].name;
}
void modes_test_run_single(int i, int* pass_out){
    if(!pass_out) return;
    if(i<0 || i>=MODES_COUNT) {
        *pass_out=0;
        return;
    }
    g_tests_run=0;
    g_tests_failed=0;
    bool ok = modes_tests[i].func();
    *pass_out = (ok && g_tests_failed==0) ? 1 : 0;
}

void run_modes_tests(int* total, int* passed) {
    g_tests_run=0;
    g_tests_failed=0;

    printf("\n\033[1m\033[93m╔══════════ MODES TESTS START ══════════╗\033[0m\n");
    for(int i=0; i<MODES_COUNT; i++){
        bool ok = modes_tests[i].func();
        if(ok){
            printf("  PASS: %s\n", modes_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n", modes_tests[i].name, test_get_fail_reason());
        }
    }

    *total  = g_tests_run;
    *passed = (g_tests_run - g_tests_failed);

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║       MODES TESTS RESULTS: %d / %d passed       ║\n", *passed, *total);
    if(*passed < *total){
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef MODES_TEST_H
#define MODES_TEST_H

/* Modes test: HPC overshadow, BFS, MLFQ, pipeline, containers, etc.*/

void run_modes_tests(int* total,int* passed);
int modes_test_count(void);
void modes_test_run_single(int i, int* pass_out);

#endif
#include "normal-test.h"
#include "test_common.h"

#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/os.h"
#include "../src/scoreboard.h"

#include <stdio.h>
#include <math.h>

static int g_tests_run=0, g_tests_failed=0;
static char g_fail_reason[256];

static int almost_equal(double a, double b, double eps) {
    return (fabs(a-b) < eps);
}

/* Test functions */
static bool test_sjf(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0],1,1,0);
    init_process(&p[1],5,1,0);
    init_process(&p[2],2,1,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(!(almost_equal(rep.avg_wait, 1.33, 0.5) &&
         almost_equal(rep.avg_turnaround, 4.0, 0.5) &&
         almost_equal(rep.avg_response, 1.33, 0.5) &&
         rep.preemptions==0ULL))
    {
        snprintf(g_fail_reason, sizeof(g_fail_reason),
            "test_sjf => mismatch => W=%.2f,T=%.2f,R=%.2f, pre=%llu",
            rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_SJF);
    return true;
}

static bool test_strf(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0],4,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_STRF);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=2 || rep.preemptions<1) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_strf => mismatch => procs=%llu, preempts=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_STRF);
    return true;
}

static bool test_hrrn(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    init_process(&p[2],4,1,0);

    scheduler_select_algorithm(ALG_HRRN);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=3 || rep.preemptions!=0ULL) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_hrrn => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN);
    return true;
}

static bool test_hrrn_rt(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,0);
    init_process(&p[1],4,1,0);

    scheduler_select_algorithm(ALG_HRRN_RT);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=2 || rep.preemptions<1) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_hrrn_rt => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN_RT);
    return true;
}

static bool test_priority(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0],2,3,0);
    init_process(&p[1],2,1,0);
    init_process(&p[2],2,2,0);

    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* just approximate check. expect no preemptions, some wait~2, TAT~4 */
    if(rep.preemptions!=0ULL ||
       !almost_equal(rep.avg_wait, 2.0, 1.0) ||
       !almost_equal(rep.avg_turnaround,4.0,1.0))
    {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_priority => mismatch => W=%.2f,T=%.2f,R=%.2f,pre=%llu",
                 rep.avg_wait, rep.avg_turnaround, rep.avg_response, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_PRIORITY);
    return true;
}

static bool test_cfs_srtf(void) {
    g_tests_run++;
    os_init();
    process_t p[3];
    init_process(&p[0],2,1,0);
    init_process(&p[1],4,1,0);
    init_process(&p[2],6,1,0);

    scheduler_select_algorithm(ALG_CFS_SRTF);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=3 || rep.preemptions<1) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_cfs_srtf => mismatch => total=%llu, pre=%llu",
                 rep.total_procs, rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS_SRTF);
    return true;
}

static bool test_sjf_strict(void) {
    g_tests_run++;
    os_init();
    process_t p[2];
    init_process(&p[0],2,10,0);
    init_process(&p[1],5,20,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.preemptions!=0ULL) {
        snprintf(g_fail_reason,sizeof(g_fail_reason),
                 "test_sjf_strict => mismatch => preempt=%llu",
                 rep.preemptions);
        test_set_fail_reason(g_fail_reason);
        g_tests_failed++;
        return false;
    }
    return true;
}

/* Array of all normal tests */
typedef bool (*test_fn)(void);
static struct {
    const char* name;
    test_fn func;
} normal_tests[] = {
    {"sjf",       test_sjf},
    {"strf",      test_strf},
    {"hrrn",      test_hrrn},
    {"hrrn_rt",   test_hrrn_rt},
    {"priority",  test_priority},
    {"cfs_srtf",  test_cfs_srtf},
    {"sjf_strict",test_sjf_strict}
};
static const int NORMAL_COUNT = sizeof(normal_tests)/sizeof(normal_tests[0]);

int normal_test_count(void) {
    return NORMAL_COUNT;
}
const char* normal_test_name(int i) {
    if(i<0 || i>=NORMAL_COUNT) return NULL;
    return normal_tests[i].name;
}

void normal_test_run_single(int i, int* pass_out) {
    if(!pass_out) return;
    if(i<0 || i>=NORMAL_COUNT) {
        *pass_out=0;
        return;
    }
    g_tests_run=0;
    g_tests_failed=0;
    memset(g_fail_reason,0,sizeof(g_fail_reason));

    bool ok = normal_tests[i].func();
    *pass_out = (ok && g_tests_failed==0) ? 1 : 0;
}

void run_normal_tests(int* total,int* passed) {
    g_tests_run=0;
    g_tests_failed=0;
    memset(g_fail_reason,0,sizeof(g_fail_reason));

    printf("\n\033[1m\033[93m╔══════════ NORMAL TESTS START ══════════╗\033[0m\n");
    for(int i=0; i<NORMAL_COUNT; i++) {
        bool ok = normal_tests[i].func();
        if(ok){
            printf("  PASS: %s\n", normal_tests[i].name);
        } else {
            printf("  FAIL: %s => %s\n", normal_tests[i].name, test_get_fail_reason());
        }
    }

    *total  = g_tests_run;
    *passed = (g_tests_run - g_tests_failed);

    printf("\033[1m\033[93m╔══════════════════════════════════════════════╗\n");
    printf("║      NORMAL TESTS RESULTS: %d / %d passed       ║\n", *passed, *total);
    if(*passed < *total) {
        printf("║    FAILURES => see logs above               ║\n");
    }
    printf("╚══════════════════════════════════════════════╝\033[0m\n");
}
#ifndef NORMAL_TEST_H
#define NORMAL_TEST_H

/* Normal tests: SJF, STRF, HRRN, HRRN-RT, PRIORITY, CFS-SRTF, etc. */

void run_normal_tests(int* total,int* passed);
int normal_test_count(void);
void normal_test_run_single(int i, int* pass_out);
#endif
#include "test_common.h"
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <errno.h>
#include <stdarg.h>

static char g_fail_reason[256] = {0};

void test_set_fail_reason(const char* msg) {
    if(!msg) {
        g_fail_reason[0] = '\0';
        return;
    }
    strncpy(g_fail_reason, msg, sizeof(g_fail_reason)-1);
    g_fail_reason[sizeof(g_fail_reason)-1] = '\0';
}

const char* test_get_fail_reason(void) {
    if(g_fail_reason[0] == '\0') {
        return "???";
    }
    return g_fail_reason;
}

static ssize_t read_all_fd(int fd, char* buf, size_t cap) {
    size_t used = 0;
    while(used + 1 < cap) {
        ssize_t r = read(fd, buf + used, cap - 1 - used);
        if(r < 0 && errno == EINTR) continue;
        if(r <= 0) break;
        used += (size_t)r;
    }
    buf[used] = '\0';
    return (ssize_t)used;
}

int run_function_capture_output(void(*fn)(void), struct captured_output* out) {
    if(!fn || !out) return -1;
    int p_out[2], p_err[2];
    if(pipe(p_out)==-1 || pipe(p_err)==-1) return -1;
    int save_out = dup(STDOUT_FILENO);
    int save_err = dup(STDERR_FILENO);
    if(save_out<0 || save_err<0) return -1;

    pid_t c = fork();
    if(c<0) {
        return -1;
    }
    if(c==0) {
        close(p_out[0]);
        close(p_err[0]);
        dup2(p_out[1], STDOUT_FILENO);
        dup2(p_err[1], STDERR_FILENO);
        close(p_out[1]);
        close(p_err[1]);

        fn();
        _exit(0);
    } else {
        close(p_out[1]);
        close(p_err[1]);
        read_all_fd(p_out[0], out->stdout_buf, sizeof(out->stdout_buf));
        read_all_fd(p_err[0], out->stderr_buf, sizeof(out->stderr_buf));
        close(p_out[0]);
        close(p_err[0]);

        dup2(save_out, STDOUT_FILENO);
        dup2(save_err, STDERR_FILENO);
        close(save_out);
        close(save_err);

        int st=0;
        waitpid(c,&st,0);
        return st;
    }
    return 0;
}
#ifndef TEST_COMMON_H
#define TEST_COMMON_H

#include <stdbool.h>
#include <stdio.h>
#include <string.h>

/* Colors for ASCII art convenience. */
#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GREEN   "\033[92m"
#define CLR_GRAY    "\033[90m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

void test_set_fail_reason(const char* msg);
const char* test_get_fail_reason(void);

struct captured_output {
  char stdout_buf[8192];
  char stderr_buf[8192];
};

/*
  run_function_capture_output():
    Creates pipes, forks, runs fn() in child, captures output in out.
*/
int run_function_capture_output(void(*fn)(void), struct captured_output* out);

/* A macro for test function definitions. */
#define TEST(name) static bool test_##name(void)

/* RUN_TEST macro to unify pass/fail printing. */
#define RUN_TEST(name) do {                          \
bool ok = test_##name();                             \
tests_run++;                                         \
if(!ok){                                             \
tests_failed++;                                      \
printf("  %s " CLR_GRAY "%s" CLR_RESET "%s%s%s\n",   \
test_failed ? "✘" : "✔",                             \
#name,                                               \
test_failed ? " => " CLR_RED : "",                   \
test_failed ? test_get_fail_reason() : "",           \
test_failed ? CLR_RESET : "");                       \
}                                                    \
} while(0)

#endif
