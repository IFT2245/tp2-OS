
    # **Directory Layout**

    ```
    my_enterprise_concurrency_game/
     ├── CMakeLists.txt
     ├── Makefile
     ├── README.md
     ├── src/
     │    ├── main.c
     │    ├── menu.c
     │    ├── menu.h
     │    ├── concurrency_test.c
     │    ├── concurrency_test.h
     │    ├── orchestrator.c
     │    ├── orchestrator.h
     │    ├── container.c
     │    ├── container.h
     │    ├── scheduler.c
     │    ├── scheduler.h
     │    ├── ready_queue.c
     │    ├── ready_queue.h
     │    ├── process.h
     │    ├── scoreboard.c
     │    ├── scoreboard.h
     │    ├── stats.c
     │    ├── stats.h
     │    ├── logger.c
     │    ├── logger.h
     │    ├── ephemeral.c
     │    ├── ephemeral.h
     │    ├── HPCqueue.c    (optional multi-level HPC queue logic)
     │    ├── HPCqueue.h
     │    └── cJSON.c / cJSON.h  (3rd-party, if included in-tree)
     └── ...
    ```

    We show the essential code below. For brevity, we keep each snippet short but demonstrate the advanced HPC scheduling, ephemeral containers, real scoreboard JSON with cJSON, a Docker approach if you want it, arrival times, resource-limits, etc.

    ---

    ## **1.** `CMakeLists.txt`

    A minimal CMake script that builds our “concurrency_game” from all `.c` sources. If you have cJSON as a submodule, you can add it similarly.

    ```cmake
    cmake_minimum_required(VERSION 3.10)
    project(EnterpriseConcurrencyGame C)

    # If cJSON is part of your source, add it:
    set(SOURCES
        src/main.c
        src/menu.c
        src/concurrency_test.c
        src/orchestrator.c
        src/container.c
        src/scheduler.c
        src/ready_queue.c
        src/scoreboard.c
        src/stats.c
        src/logger.c
        src/ephemeral.c
        # HPCqueue.c if needed
        # cJSON.c if included
    )

    add_executable(concurrency_game ${SOURCES})

    # If cJSON is external:
    # find_package(cJSON REQUIRED)
    # target_link_libraries(concurrency_game PRIVATE cjson)

    # Otherwise if cJSON is in-tree, just compile cJSON.c along with the rest.
    ```

    ---

    ## **2.** `Makefile`

    A simple fallback `Makefile` for those not using CMake. It compiles all `.c`:

    ```makefile
    CC = gcc
    CFLAGS = -Wall -Wextra -std=c11 -g
    SRCS = main.c menu.c concurrency_test.c orchestrator.c container.c scheduler.c ready_queue.c scoreboard.c stats.c logger.c ephemeral.c
    OBJS = $(SRCS:.c=.o)
    TARGET = concurrency_game

    all: $(TARGET)

    $(TARGET): $(OBJS)
    	$(CC) $(CFLAGS) -o $(TARGET) $(OBJS)

    %.o: src/%.c
    	$(CC) $(CFLAGS) -c $< -o $@

    clean:
    	rm -f $(OBJS) $(TARGET)
    ```

    *(Assumes your `.c` files are in `src/`. Adjust paths as needed.)*

    ---

    ## **3.** `README.md`

    A short README showing how to build and run.

    ```markdown
    # Enterprise Concurrency Game

    A “production-level” concurrency training game with HPC scheduling, ephemeral containers, resource-limits, scoreboard in JSON, arrival times, multi-level HPC, and more.

    ## Build

    ### Using CMake

    ```bash
    mkdir build
    cd build
    cmake ..
    make
    ./concurrency_game
    ```

    ### Using Makefile

    ```bash
    make
    ./concurrency_game
    ```

    ## Dependencies

    - **cJSON** for JSON parsing (either included in `src/cJSON.c/h` or installed system-wide).
    - A POSIX system for ephemeral directories (`mkdtemp`).

    ## Run

    ```bash
    ./concurrency_game
    ```

    Then follow the on-screen menu. Your scoreboard is stored in `scoreboard.json`, and ephemeral container directories are created in `/tmp/`.

    ---
    ```

    ---

    ## **4.** `logger.h` / `logger.c`

    *(Same from iteration #7. We keep them intact.)*

    ### **`logger.h`**

    ```c
    #ifndef LOGGER_H
    #define LOGGER_H

    #include <stdio.h>

    typedef enum {
        LOG_LEVEL_DEBUG=0,
        LOG_LEVEL_INFO,
        LOG_LEVEL_WARN,
        LOG_LEVEL_ERROR
    } log_level_t;

    void logger_set_level(log_level_t lvl);

    void logger_debug(const char* fmt, ...);
    void logger_info(const char* fmt, ...);
    void logger_warn(const char* fmt, ...);
    void logger_error(const char* fmt, ...);

    #endif
    ```

    ### **`logger.c`**

    ```c
    #include "logger.h"
    #include <stdarg.h>
    #include <stdio.h>

    static log_level_t g_log_level=LOG_LEVEL_INFO;

    void logger_set_level(log_level_t lvl)
    {
        g_log_level=lvl;
    }

    static void vlogf(log_level_t lvl, const char* prefix, const char* fmt, va_list ap)
    {
        if(lvl<g_log_level) return;
        fprintf(stderr,"%s", prefix);
        vfprintf(stderr,fmt,ap);
        fprintf(stderr,"\n");
    }

    void logger_debug(const char* fmt, ...)
    {
        va_list ap;
        va_start(ap,fmt);
        vlogf(LOG_LEVEL_DEBUG,"[DEBUG] ",fmt,ap);
        va_end(ap);
    }

    void logger_info(const char* fmt, ...)
    {
        va_list ap;
        va_start(ap,fmt);
        vlogf(LOG_LEVEL_INFO,"[INFO]  ",fmt,ap);
        va_end(ap);
    }

    void logger_warn(const char* fmt, ...)
    {
        va_list ap;
        va_start(ap,fmt);
        vlogf(LOG_LEVEL_WARN,"[WARN]  ",fmt,ap);
        va_end(ap);
    }

    void logger_error(const char* fmt, ...)
    {
        va_list ap;
        va_start(ap,fmt);
        vlogf(LOG_LEVEL_ERROR,"[ERROR] ",fmt,ap);
        va_end(ap);
    }
    ```

    ---

    ## **5.** `ephemeral.h` / `ephemeral.c`

    *(Also from iteration #7, unchanged.)*

    ### **`ephemeral.h`**

    ```c
    #ifndef EPHEMERAL_H
    #define EPHEMERAL_H

    #define MAX_EPHEMERAL_PATH 256

    char* ephemeral_create_container(void);
    void ephemeral_remove_container(const char* path);

    #endif
    ```

    ### **`ephemeral.c`**

    ```c
    #include "ephemeral.h"
    #include "logger.h"
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <sys/stat.h>

    char* ephemeral_create_container(void)
    {
        char tmpl[] = "/tmp/container_XXXXXX";
        char* path = (char*)malloc(MAX_EPHEMERAL_PATH);
        if(!path){
            logger_error("Cannot allocate ephemeral container path.");
            return NULL;
        }
        strcpy(path, tmpl);
        if(!mkdtemp(path)){
            logger_error("mkdtemp failed for %s", path);
            free(path);
            return NULL;
        }
        logger_info("Created ephemeral container => %s", path);
        return path;
    }

    void ephemeral_remove_container(const char* path)
    {
        if(!path) return;
        int rc=rmdir(path);
        if(rc==0){
            logger_info("Removed ephemeral container => %s", path);
        }else{
            logger_warn("Failed to remove ephemeral container => %s", path);
        }
    }
    ```

    ---

    ## **6.** `cJSON.c` / `cJSON.h`

    We won’t inline cJSON’s entire code here—it’s large. Typically, you’d clone [cJSON from GitHub](https://github.com/DaveGamble/cJSON) or install it system-wide. Then you add it to your build. For demonstration, we just note that you have a **cJSON** single-file approach:

    ```bash
    # cJSON might be included as:
    src/cJSON.c
    src/cJSON.h
    ```

    And your scoreboard code or others can do:

    ```c
    #include "cJSON.h"
    ...
    ```

    We’ll illustrate usage below in `scoreboard.c`.

    ---

    ## **7.** **Advanced HPC**: `HPCqueue.h` / `HPCqueue.c`

    *(Optional) If you want a separate HPC queue implementation for multi-level HPC priority. If you prefer to keep HPC logic in `ready_queue.c`, ignore this file. We show it to demonstrate “enterprise” modular approach—`ready_queue` for normal algorithms, `HPCqueue` for HPC multi-level.*

    ### **`HPCqueue.h`**

    ```c
    #ifndef HPCQUEUE_H
    #define HPCQUEUE_H

    #include "process.h"
    #include <pthread.h>

    /*
     * HPC multi-level queue:
     *   - HPC prios range [0..X], smaller => higher priority
     *   - We'll store HPC processes in multiple lists.
     *   - HPC pop => the highest priority non-empty list's front.
     */

    #define HPC_MAX_PRIOS 4

    typedef struct HPCnode_s {
        process_t*        proc;
        struct HPCnode_s* next;
    } HPCnode_t;

    typedef struct HPCqueue_s {
        HPCnode_t*        heads[HPC_MAX_PRIOS];
        int               sizes[HPC_MAX_PRIOS];
        pthread_mutex_t   m;
        pthread_cond_t    c;
    } HPCqueue_t;

    void HPCqueue_init(HPCqueue_t* q);
    void HPCqueue_destroy(HPCqueue_t* q);
    void HPCqueue_push(HPCqueue_t* q, process_t* p, int hpc_prio);
    process_t* HPCqueue_pop(HPCqueue_t* q);
    /* push sentinel => p==NULL => all lists? or just highest prio?
       Up to you. We can do for prio 0. */
    void HPCqueue_push_sentinel(HPCqueue_t* q);

    #endif
    ```

    ### **`HPCqueue.c`**

    ```c
    #include "HPCqueue.h"
    #include <stdlib.h>
    #include <string.h>
    #include <stdio.h>

    void HPCqueue_init(HPCqueue_t* q)
    {
        memset(q,0,sizeof(*q));
        pthread_mutex_init(&q->m,NULL);
        pthread_cond_init(&q->c,NULL);
    }

    void HPCqueue_destroy(HPCqueue_t* q)
    {
        for(int i=0;i<HPC_MAX_PRIOS;i++){
            HPCnode_t* cur=q->heads[i];
            while(cur){
                HPCnode_t* tmp=cur;
                cur=cur->next;
                free(tmp);
            }
        }
        pthread_mutex_destroy(&q->m);
        pthread_cond_destroy(&q->c);
        memset(q,0,sizeof(*q));
    }

    void HPCqueue_push(HPCqueue_t* q, process_t* p, int hpc_prio)
    {
        pthread_mutex_lock(&q->m);
        if(hpc_prio<0) hpc_prio=0;
        if(hpc_prio>=HPC_MAX_PRIOS) hpc_prio=HPC_MAX_PRIOS-1;

        HPCnode_t* n=(HPCnode_t*)malloc(sizeof(HPCnode_t));
        n->proc=p;
        n->next=NULL;

        if(!p){
            /* sentinel => store in highest prio? or do logic. For example, store prio=0. */
        }

        HPCnode_t** head_ref=&q->heads[hpc_prio];
        if(!(*head_ref)){
            *head_ref=n;
        } else {
            HPCnode_t* c=*head_ref;
            while(c->next) c=c->next;
            c->next=n;
        }
        q->sizes[hpc_prio]++;
        pthread_cond_broadcast(&q->c);
        pthread_mutex_unlock(&q->m);
    }

    void HPCqueue_push_sentinel(HPCqueue_t* q)
    {
        HPCqueue_push(q,NULL,0); /* push sentinel in prio=0 list. */
    }

    /* pop => pick the highest priority non-empty. If sentinel => return NULL. */
    process_t* HPCqueue_pop(HPCqueue_t* q)
    {
        pthread_mutex_lock(&q->m);
        while(1){
            int nonempty=0;
            for(int i=0;i<HPC_MAX_PRIOS;i++){
                if(q->heads[i]) {nonempty=1; break;}
            }
            if(nonempty){
                /* find highest i with heads[i] != NULL */
                for(int i=0;i<HPC_MAX_PRIOS;i++){
                    if(q->heads[i]){
                        HPCnode_t* n=q->heads[i];
                        q->heads[i]=n->next;
                        q->sizes[i]--;
                        process_t* p=n->proc;
                        free(n);
                        pthread_mutex_unlock(&q->m);
                        return p;
                    }
                }
            }
            pthread_cond_wait(&q->c,&q->m);
        }
        /* unreachable */
        pthread_mutex_unlock(&q->m);
        return NULL;
    }
    ```

    Then your container can use HPCqueue for HPC processes instead of `ready_queue_t` if you want a multi-level HPC approach.

    ---

    ## **8.** `scoreboard.h` / `scoreboard.c` with **cJSON**

    ### **`scoreboard.h`**

    *(Largely the same—unchanged from iteration #7, except we disclaim we use cJSON now.)*

    ```c
    #ifndef SCOREBOARD_H
    #define SCOREBOARD_H

    typedef enum {
        SUITE_BASIC=1,
        SUITE_NORMAL,
        SUITE_EXTERNAL,
        SUITE_MODES,
        SUITE_EDGE,
        SUITE_HIDDEN
    } scoreboard_suite_t;

    typedef struct {
        int basic_total,    basic_pass;
        int normal_total,   normal_pass;
        int external_total, external_pass;
        int modes_total,    modes_pass;
        int edge_total,     edge_pass;
        int hidden_total,   hidden_pass;

        /* HPC mastery => sc_hpc=1 if HPC is “mastered.” */
        int sc_fifo, sc_rr, sc_cfs, sc_cfs_srtf, sc_bfs;
        int sc_sjf, sc_strf, sc_hrrn, sc_hrrn_rt, sc_priority;
        int sc_hpc, sc_mlfq;

        double basic_percent;
        double normal_percent;
        double external_percent;
        double modes_percent;
        double edge_percent;
        double hidden_percent;

        double pass_threshold;
    } scoreboard_t;

    void scoreboard_load(void);
    void scoreboard_save(void);
    void scoreboard_clear(void);
    int  scoreboard_get_final_score(void);

    void scoreboard_update_basic(int total,int pass);
    void scoreboard_update_normal(int total,int pass);
    void scoreboard_update_external(int total,int pass);
    void scoreboard_update_modes(int total,int pass);
    void scoreboard_update_edge(int total,int pass);
    void scoreboard_update_hidden(int total,int pass);

    void scoreboard_set_sc_hpc(int val);

    int  scoreboard_is_unlocked(scoreboard_suite_t suite);
    void get_scoreboard(scoreboard_t* out);

    #endif
    ```

    ### **`scoreboard.c`** with cJSON

    ```c
    #include "scoreboard.h"
    #include "logger.h"
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/stat.h>
    #include "cJSON.h"

    static scoreboard_t gSB;

    static void recompute_suite_percents(void)
    {
        #define PERC(t,p) ((t)>0 ? (100.0*(double)(p)/(double)(t)) : 0.0)
        gSB.basic_percent    = PERC(gSB.basic_total,    gSB.basic_pass);
        gSB.normal_percent   = PERC(gSB.normal_total,   gSB.normal_pass);
        gSB.external_percent = PERC(gSB.external_total, gSB.external_pass);
        gSB.modes_percent    = PERC(gSB.modes_total,    gSB.modes_pass);
        gSB.edge_percent     = PERC(gSB.edge_total,     gSB.edge_pass);
        gSB.hidden_percent   = PERC(gSB.hidden_total,   gSB.hidden_pass);
        #undef PERC
    }

    /*
      Weighted approach =>
       basic=20%, normal=20%, modes=15%, edge=15%, hidden=15%, external=10%, HPC=5%
    */
    int scoreboard_get_final_score(void)
    {
        recompute_suite_percents();
        double b  = gSB.basic_percent*0.20;
        double n  = gSB.normal_percent*0.20;
        double mo = gSB.modes_percent*0.15;
        double ed = gSB.edge_percent*0.15;
        double hi = gSB.hidden_percent*0.15;
        double ex = gSB.external_percent*0.10;
        double HPC= gSB.sc_hpc? 5.0 : 0.0;
        double total=b+n+mo+ed+hi+ex+HPC;
        if(total>100.0) total=100.0;
        return (int)(total+0.5);
    }

    static void scoreboard_defaults(void)
    {
        memset(&gSB,0,sizeof(gSB));
        gSB.pass_threshold=60.0;
    }

    void scoreboard_load(void)
    {
        scoreboard_defaults();
        FILE* f=fopen("scoreboard.json","rb");
        if(!f){
            logger_warn("scoreboard_load => scoreboard.json not found, using defaults");
            return;
        }
        fseek(f,0,SEEK_END);
        long sz=ftell(f);
        if(sz<0){fclose(f);return;}
        fseek(f,0,SEEK_SET);
        char* buf=(char*)malloc(sz+1);
        if(!buf){fclose(f);return;}
        if(fread(buf,1,sz,f)!=(size_t)sz){free(buf);fclose(f);return;}
        buf[sz]='\0';
        fclose(f);

        cJSON* root=cJSON_Parse(buf);
        free(buf);
        if(!root){
            logger_warn("scoreboard_load => JSON parse error => using defaults");
            return;
        }
        #define JGETINT(obj,name,dst) do{ \
           cJSON* tmp=cJSON_GetObjectItemCaseSensitive(obj,name); \
           if(tmp && cJSON_IsNumber(tmp)){ (dst)=tmp->valueint;} \
        }while(0)
        #define JGETDBL(obj,name,dst) do{ \
           cJSON* tmp=cJSON_GetObjectItemCaseSensitive(obj,name); \
           if(tmp && cJSON_IsNumber(tmp)){ (dst)=tmp->valuedouble;} \
        }while(0)

        JGETINT(root,"basic_total",    gSB.basic_total);
        JGETINT(root,"basic_pass",     gSB.basic_pass);
        JGETINT(root,"normal_total",   gSB.normal_total);
        JGETINT(root,"normal_pass",    gSB.normal_pass);
        JGETINT(root,"external_total", gSB.external_total);
        JGETINT(root,"external_pass",  gSB.external_pass);
        JGETINT(root,"modes_total",    gSB.modes_total);
        JGETINT(root,"modes_pass",     gSB.modes_pass);
        JGETINT(root,"edge_total",     gSB.edge_total);
        JGETINT(root,"edge_pass",      gSB.edge_pass);
        JGETINT(root,"hidden_total",   gSB.hidden_total);
        JGETINT(root,"hidden_pass",    gSB.hidden_pass);

        JGETINT(root,"sc_hpc", gSB.sc_hpc);

        JGETDBL(root,"pass_threshold", gSB.pass_threshold);

        cJSON_Delete(root);
        logger_info("scoreboard_load => success from scoreboard.json");
    }

    void scoreboard_save(void)
    {
        cJSON* root=cJSON_CreateObject();
        #define JADDINT(obj,name,val) cJSON_AddNumberToObject(obj,name,(double)(val))
        #define JADDDBL(obj,name,val) cJSON_AddNumberToObject(obj,name,(val))

        JADDINT(root,"basic_total",    gSB.basic_total);
        JADDINT(root,"basic_pass",     gSB.basic_pass);
        JADDINT(root,"normal_total",   gSB.normal_total);
        JADDINT(root,"normal_pass",    gSB.normal_pass);
        JADDINT(root,"external_total", gSB.external_total);
        JADDINT(root,"external_pass",  gSB.external_pass);
        JADDINT(root,"modes_total",    gSB.modes_total);
        JADDINT(root,"modes_pass",     gSB.modes_pass);
        JADDINT(root,"edge_total",     gSB.edge_total);
        JADDINT(root,"edge_pass",      gSB.edge_pass);
        JADDINT(root,"hidden_total",   gSB.hidden_total);
        JADDINT(root,"hidden_pass",    gSB.hidden_pass);

        JADDINT(root,"sc_hpc",         gSB.sc_hpc);

        JADDDBL(root,"pass_threshold", gSB.pass_threshold);

        char* outstr=cJSON_Print(root);
        cJSON_Delete(root);

        FILE* f=fopen("scoreboard.json","wb");
        if(!f){
            logger_error("scoreboard_save => cannot open scoreboard.json for write");
            free(outstr);
            return;
        }
        fwrite(outstr,1,strlen(outstr),f);
        fclose(f);
        free(outstr);

        logger_info("scoreboard_save => updated scoreboard.json");
    }

    void scoreboard_clear(void)
    {
        scoreboard_defaults();
        scoreboard_save();
    }

    void scoreboard_update_basic(int total,int pass)
    {
        gSB.basic_total += total;
        gSB.basic_pass  += pass;
    }
    void scoreboard_update_normal(int total,int pass)
    {
        gSB.normal_total+=total;
        gSB.normal_pass +=pass;
    }
    void scoreboard_update_external(int total,int pass)
    {
        gSB.external_total+=total;
        gSB.external_pass +=pass;
    }
    void scoreboard_update_modes(int total,int pass)
    {
        gSB.modes_total+=total;
        gSB.modes_pass +=pass;
    }
    void scoreboard_update_edge(int total,int pass)
    {
        gSB.edge_total+=total;
        gSB.edge_pass +=pass;
    }
    void scoreboard_update_hidden(int total,int pass)
    {
        gSB.hidden_total+=total;
        gSB.hidden_pass +=pass;
    }

    void scoreboard_set_sc_hpc(int val)
    {
        gSB.sc_hpc = (val?1:0);
    }

    int scoreboard_is_unlocked(scoreboard_suite_t suite)
    {
        recompute_suite_percents();
        double T=gSB.pass_threshold;
        switch(suite){
            case SUITE_BASIC:   return 1;
            case SUITE_NORMAL:  return (gSB.basic_percent>=T);
            case SUITE_EXTERNAL:return (gSB.normal_percent>=T);
            case SUITE_MODES:   return (gSB.normal_percent>=T);
            case SUITE_EDGE:    return (gSB.modes_percent>=T);
            case SUITE_HIDDEN:  return (gSB.edge_percent>=T);
            default:            return 0;
        }
    }
    void get_scoreboard(scoreboard_t* out)
    {
        if(out) *out=gSB;
    }
    ```

    Now we have a truly “enterprise” scoreboard system that uses **cJSON** to load/save from `scoreboard.json` in a robust manner.

    ---

    ## **9.** `stats.h` / `stats.c`

    *(Same minimal pass/fail approach as iteration #7–8. No overshadow references.)*

    ---

    ## **10.** HPC multi-level code integrated into `container.c` or `HPCqueue.c`

    In an enterprise system, you might do advanced HPC in a separate HPC queue (like `HPCqueue.c/h` above). Or you can integrate it into `container.c`. Whichever you choose, you have robust HPC multi-level scheduling, ephemeral container creation, real JSON scoreboard, plus everything from prior iterations.

    ---

    ## **11.** `concurrency_test.c/h`, `menu.c/h`, `main.c`

    *(Largely the same as iteration #7, but referencing cJSON scoreboard. Possibly you add advanced HPC usage, ephemeral container usage, extended logging, etc. We omit re-pasting the entire code for brevity. You get the idea: the final iteration merges all these advanced features into one cohesive repository.)*

    In short:

    - `main.c` => sets `logger_set_level(LOG_LEVEL_INFO)`, loads scoreboard, calls `menu_main_loop()`, then ephemeral_remove_container() or so, prints final stats, etc.
    - `menu.c` => offers concurrency tests, HPC tests, scoreboard display, locked HPC-limited test, etc.
    - `concurrency_test.c` => sets up containers with HPC multi-level priorities if you wish, arrivals, resource-limits, ephemeral container usage, logs per-process stats, updates scoreboard.

    **No overshadow references**. HPC is purely done via `ALG_HPC`, with advanced logic if you choose.

    ---

    # **Conclusion**

    - **cJSON** for robust scoreboard JSON
    - **Ephemeral container** directories
    - **Advanced HPC** multi-level approach
    - **Resource-limits**
    - **Arrival times**
    - **Better logging**
    - **CMake** + fallback **Makefile**
    - **README** for usage

    It’s an extensive “enterprise concurrency game” showing concurrency scheduling, HPC features, ephemeral containers, scoreboard progression, test lock/unlock, and so forth, all in **one** code base.

