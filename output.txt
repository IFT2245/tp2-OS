#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
#include "worker.h"

/* =========== (A) ephemeral remove code =========== */
#ifdef EPHEMERAL_RM_RECURSIVE
static int remove_directory_recursive(const char* path){
    DIR* dir = opendir(path);
    if(!dir) return rmdir(path);
    struct dirent* entry;
    int ret=0;
    while((entry = readdir(dir))){
        if(strcmp(entry->d_name,".")==0 || strcmp(entry->d_name,"..")==0){
            continue;
        }
        char buf[512];
        snprintf(buf,sizeof(buf),"%s/%s", path, entry->d_name);
        struct stat st;
        if(stat(buf,&st)==0){
            if(S_ISDIR(st.st_mode)){
                ret=remove_directory_recursive(buf);
                if(ret!=0) break;
            } else {
                ret=unlink(buf);
                if(ret!=0) break;
            }
        }
    }
    closedir(dir);
    if(ret==0) ret=rmdir(path);
    return ret;
}
#endif

static char* ephemeral_create_container(void){
    char tmpl[] = "/tmp/container_XXXXXX";
    char* p = (char*)malloc(256);
    if(!p){
        log_error("ephemeral_create_container mem fail");
        return NULL;
    }
    strcpy(p, tmpl);
    if(!mkdtemp(p)){
        log_error("mkdtemp fail %s => %s", p, strerror(errno));
        free(p);
        return NULL;
    }
    /* Make ephemeral container logs purple: */
    log_info("\033[35mephemeral created => %s\033[0m", p);
    return p;
}

static void ephemeral_remove_container(const char* path){
    if(!path) return;
#ifdef EPHEMERAL_RM_RECURSIVE
    int r = remove_directory_recursive(path);
#else
    int r = rmdir(path);
#endif
    if(r==0){
        log_info("\033[35mephemeral removed => %s\033[0m", path);
    } else {
        log_warn("ephemeral remove fail => %s : %s", path, strerror(errno));
    }
}

/* =========== (B) timeline printing =========== */
static int compare_timeline(const void* a, const void* b){
    const timeline_item_t* A = (const timeline_item_t*)a;
    const timeline_item_t* B = (const timeline_item_t*)b;
    if(A->core_id < B->core_id) return -1;
    if(A->core_id > B->core_id) return 1;
    if(A->start_ms < B->start_ms) return -1;
    if(A->start_ms > B->start_ms) return 1;
    return 0;
}

static void print_container_timeline(const container_t* c){
    if(c->timeline_count == 0){
        printf("\n\033[1m\033[33mNo timeline for container.\033[0m\n");
        return;
    }
    qsort(c->timeline, c->timeline_count, sizeof(c->timeline[0]), compare_timeline);

    printf("\033[1m\033[36m\n--- Container Timeline ---\n\033[0m");
    int current_core=9999999;
    for(int i=0; i<c->timeline_count; i++){
        int cid = c->timeline[i].core_id;
        if(cid != current_core){
            if(cid >= 0){
                printf("\033[1m\033[32m\nMain Core %d:\n\033[0m", cid);
            } else {
                int hpc_idx = (-1 - cid);
                printf("\033[1m\033[35m\nHPC Thread %d:\n\033[0m", hpc_idx);
            }
            current_core=cid;
        }
        unsigned long st=c->timeline[i].start_ms;
        unsigned long ln=c->timeline[i].length_ms;
        bool pre=c->timeline[i].preempted_slice;
        if(pre){
            printf("  T[%lu..%lu] => P%d \033[1m\033[33m[PREEMPT]\033[0m\n",
                   st, st+ln, c->timeline[i].proc_id);
        } else {
            printf("  T[%lu..%lu] => P%d\n", st, st+ln, c->timeline[i].proc_id);
        }
    }
}

/* =========== (C) container_run =========== */
static void* container_thread_runner(void* arg){
    container_t* c=(container_t*)arg;
    if(!c){
        log_error("container_run => null container pointer?");
        return NULL;
    }

    c->ephemeral_path = ephemeral_create_container();
    if(!c->ephemeral_path){
        log_error("container_run => ephemeral creation failed => ignoring");
    }

    /* HPC procs offset 1000. */
    for(int i=0; i<c->main_count; i++){
        c->main_procs[i].id = i;
    }
    for(int i=0; i<c->hpc_count; i++){
        c->hpc_procs[i].id = 1000 + i;
    }

    /* Build local RQs. */
    ready_queue_t main_q, hpc_q;
    rq_init(&main_q, c->main_alg);
    rq_init(&hpc_q, c->hpc_alg);

    /* Push immediate arrivals. */
    for(int i=0; i<c->main_count; i++){
        process_t* p=&c->main_procs[i];
        if(p->remaining_time>0 && p->arrival_time==0){
            rq_push(&main_q, p);
        }
    }
    for(int i=0; i<c->hpc_count; i++){
        process_t* p=&c->hpc_procs[i];
        if(p->remaining_time>0 && p->arrival_time==0){
            rq_push(&hpc_q, p);
        }
    }

    /* Create main threads. */
    pthread_t* main_threads = calloc(c->nb_cores, sizeof(pthread_t));
    if(!main_threads){
        log_error("container_run => no memory for main_threads");
        return NULL;
    }
    for(int i=0; i<c->nb_cores; i++){
        core_thread_pack_t* pack = malloc(sizeof(core_thread_pack_t));
        pack->container = c;
        pack->qs.main_rq = &main_q;
        pack->qs.hpc_rq  = &hpc_q;
        pack->core_id = i;
        pthread_create(&main_threads[i], NULL, main_core_thread, pack);
    }

    /* HPC threads. */
    pthread_t* hpc_threads = NULL;
    if(c->nb_hpc_threads > 0){
        hpc_threads = calloc(c->nb_hpc_threads, sizeof(pthread_t));
        if(!hpc_threads){
            log_error("container_run => no memory for hpc_threads");
        } else {
            for(int i=0; i<c->nb_hpc_threads; i++){
                core_thread_pack_t* pack = malloc(sizeof(core_thread_pack_t));
                pack->container = c;
                pack->qs.main_rq = &main_q;
                pack->qs.hpc_rq  = &hpc_q;
                pack->core_id = i;
                pthread_create(&hpc_threads[i], NULL, hpc_thread, pack);
            }
        }
    }

    /* Join main cores. */
    for(int i=0; i<c->nb_cores; i++){
        pthread_join(main_threads[i], NULL);
    }
    free(main_threads);

    /* Join HPC threads. */
    if(c->nb_hpc_threads>0 && hpc_threads){
        for(int i=0; i<c->nb_hpc_threads; i++){
            pthread_join(hpc_threads[i], NULL);
        }
        free(hpc_threads);
    }

    rq_destroy(&main_q);
    rq_destroy(&hpc_q);

    /* ephemeral remove */
    if(c->ephemeral_path){
        ephemeral_remove_container(c->ephemeral_path);
        free(c->ephemeral_path);
        c->ephemeral_path=NULL;
    }

    print_container_timeline(c);

    if(c->timeline){
        free(c->timeline);
        c->timeline = NULL;
    }
    pthread_mutex_destroy(&c->timeline_lock);
    pthread_mutex_destroy(&c->finish_lock);

    return NULL;
}

void container_init(container_t* c,
                    int nb_cores,
                    int nb_hpc_threads,
                    scheduler_alg_t main_alg,
                    scheduler_alg_t hpc_alg,
                    process_t* main_list,
                    int main_count,
                    process_t* hpc_list,
                    int hpc_count,
                    unsigned long max_cpu_ms)
{
    if(!c){
        log_error("container_init => null container pointer");
        return;
    }
    memset(c,0,sizeof(*c));

    if(nb_cores<0) nb_cores=0;
    if(nb_hpc_threads<0) nb_hpc_threads=0;
    if(max_cpu_ms==0){
        log_warn("container_init => forcing max_cpu_ms=100");
        max_cpu_ms=100;
    }

    c->nb_cores       = nb_cores;
    c->nb_hpc_threads = nb_hpc_threads;
    c->main_alg       = main_alg;
    c->hpc_alg        = hpc_alg;
    c->main_procs     = main_list;
    c->main_count     = main_count;
    c->hpc_procs      = hpc_list;
    c->hpc_count      = hpc_count;
    c->max_cpu_time_ms= max_cpu_ms;
    c->remaining_count= main_count + hpc_count;

    pthread_mutex_init(&c->finish_lock,NULL);
    pthread_mutex_init(&c->timeline_lock,NULL);

    c->timeline       = NULL;
    c->timeline_count = 0;
    c->timeline_cap   = 0;
    c->time_exhausted = false;
    c->accumulated_cpu= 0;
    c->sim_time       = 0;

    /* HPC steal if 0 main cores but have main processes. */
    if(nb_cores == 0 && main_count>0){
        log_info("container_init => no main cores but main processes => enabling HPC steal");
        c->allow_hpc_steal = true;
    }

    /* ADDED for concurrency consistency => track active cores */
    c->active_cores   = 0;
}

void container_run(container_t* c){
    container_thread_runner((void*)c);
}

void orchestrator_run(container_t* arr, int count){
    pthread_t* tids = calloc(count, sizeof(pthread_t));
    if(!tids){
        log_error("orchestrator_run => cannot allocate");
        return;
    }
    for(int i=0; i<count; i++){
        pthread_create(&tids[i], NULL, container_thread_runner, &arr[i]);
    }
    for(int i=0; i<count; i++){
        pthread_join(tids[i], NULL);
    }
    free(tids);
}
#ifndef CONTAINER_H
#define CONTAINER_H

#include <pthread.h>
#include <stdbool.h>
#include "../lib/scheduler_alg.h"
#include "process.h"
#include "ready_queue.h"
struct core_thread_pack_s;
typedef struct core_thread_pack_s core_thread_pack_t;
/**
 * Timeline event struct
 */
typedef struct timeline_item_s {
    int           core_id;    /* HPC ID if negative */
    int           proc_id;
    unsigned long start_ms;
    unsigned long length_ms;
    bool          preempted_slice;
} timeline_item_t;

/**
 * @brief The container struct for processes + HPC threads + scheduling info.
 */
typedef struct container_s {
    int              nb_cores;
    int              nb_hpc_threads;
    scheduler_alg_t  main_alg;
    scheduler_alg_t  hpc_alg;

    process_t*       main_procs;
    int              main_count;
    process_t*       hpc_procs;
    int              hpc_count;

    unsigned long    max_cpu_time_ms;
    unsigned long    accumulated_cpu;
    unsigned long    sim_time;
    bool             time_exhausted;
    int              remaining_count;

    pthread_mutex_t  finish_lock;
    pthread_mutex_t  timeline_lock;

    timeline_item_t* timeline;
    int   timeline_count;
    int   timeline_cap;

    char* ephemeral_path;
    bool  allow_hpc_steal;

    /* NEW FIELD: number of cores actively running a slice right now */
    int   active_cores;

} container_t;

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Initialize a container. HPC steal is automatically enabled if nb_cores=0 but main_count>0.
 */
void container_init(container_t* c,
                    int nb_cores,
                    int nb_hpc_threads,
                    scheduler_alg_t main_alg,
                    scheduler_alg_t hpc_alg,
                    process_t* main_list,
                    int main_count,
                    process_t* hpc_list,
                    int hpc_count,
                    unsigned long max_cpu_ms);

/**
 * @brief Run this container in the current thread. (Blocks until completion.)
 */
void container_run(container_t* c);

/**
 * @brief Orchestrator that runs multiple containers in parallel.
 */
void orchestrator_run(container_t* arr, int count);

#endif // CONTAINER_H
#include "worker.h"
#include "../lib/log.h"
#include "../lib/scoreboard.h"
#include "../lib/library.h"
#include "../test/basic-tests.h"  // Now includes our expanded tests

static void show_scoreboard_submenu(void) {
    while(1) {
        printf("\n\033[1m\033[36m=== SCOREBOARD MENU ===\033[0m\n");
        printf("1) Show scoreboard legend\n");
        printf("2) Return to main menu\n");
        printf("Choice? ");
        fflush(stdout);
        char choice[64];
        if(!fgets(choice, sizeof(choice), stdin)) break;
        switch(choice[0]) {
        case '1':
            show_legend();
            break;
        case '2':
            return;
        default:
            printf("\033[33mUnknown option.\033[0m\n");
            break;
        }
    }
}


static void do_one_run_test(void){
    scoreboard_clear();
    scoreboard_save();
    set_log_level(LOG_LEVEL_INFO);
    run_all_tests();       // The refined test suite (includes multi-tests)
    show_scoreboard();
    scoreboard_save();
    fflush(stdout);
    fflush(stderr);
}

/**
 * We run all refined tests, show the scoreboard, and exit with final score.
 * OFFICIAL SCORING FUNCTION
 */
static void do_run_tests(void){
    scoreboard_clear();
    scoreboard_save();
    int i = 0;
    while (i++<10) {
        set_log_level(LOG_LEVEL_INFO);
        run_all_tests();       // The refined test suite (includes multi-tests)
        show_scoreboard();
        scoreboard_save();
        fflush(stdout);
        fflush(stderr);
    }
}


static void show_main_menu(void){
    fflush(stdout);
    fflush(stderr);
    printf("\n\033[1m\033[35m=== MAIN MENU ===\033[0m\n");
    printf("1) Run all tests\n");
    printf("2) Scoreboard\n");
    printf("3) Clear scoreboard\n");
    printf("4) Enable/Disable bonus test\n");
    printf(CLR_BOLD"5) NON OFFICIAL GRADING\n"CLR_RESET);
    printf("6) Exit\n");
    printf("Choice? ");
}

int main(void){
    signal(SIGINT, handle_signal);
    signal(SIGTERM, handle_signal);
    scoreboard_load();
    scoreboard_set_sc_hpc(1);
    set_bonus_test(1);   // default: bonus test ON

    while(1){
        if (fflush(stdout) == 0 && fflush(stderr) == 0) {
            usleep(50000);
            show_main_menu();
        }
        char choice[64];
        if(!fgets(choice, sizeof(choice), stdin)){
            break;
        }
        switch(choice[0]){
        case '1':
            init_preempt_timer();
            do_one_run_test();
            disable_preempt_timer();
            break;
        case '2':
            show_scoreboard();
            show_scoreboard_submenu();
            break;
        case '3':
            scoreboard_clear();
            printf("\033[31mScoreboard cleared.\033[00m\n");
            break;
        case '4':
            if (is_bonus_test()) {
                set_bonus_test(0);
                printf("\033[35mBonus test disabled.\033[0m\n");
            } else {
                set_bonus_test(1);
                printf("\033[35mBonus test enabled.\033[0m\n");
            }
            break;
        case '5':
            init_preempt_timer();
            do_run_tests();
            disable_preempt_timer();
            break;
        case '6':
        case 'q':
        case 'Q':
            printf("Exiting...\n");
            return scoreboard_get_final_score();
        default:
            printf("\033[33mUnknown option.\033[0m\n");
            break;
        }
    }
    return -1;
}
#include "process.h"
#include "../lib/log.h"

void init_process(process_t* p, unsigned long burst, int prio, unsigned long arrival, double weight){
    if(!p){
        log_error("init_process => Null pointer for process_t");
        return;
    }
    if(burst == 0){
        log_warn("init_process => burst=0 => completes instantly");
    }
    if(prio < 0){
        log_warn("init_process => negative priority => continuing");
    }
    if(weight <= 0.0){
        log_warn("init_process => nonpositive weight => forcing weight=1.0");
        weight = 1.0;
    }

    p->id             = 0;
    p->burst_time     = burst;
    p->priority       = prio;
    p->arrival_time   = arrival;
    p->remaining_time = burst;
    p->first_response = 0;
    p->end_time       = 0;
    p->responded      = false;
    p->weight         = weight;
    p->hpc_affinity   = -1;
    p->mlfq_level     = 0;
    p->was_preempted  = false;
}
#ifndef PROCESS_H
#define PROCESS_H

#include <stdbool.h>

/**
 * @brief Represents a single process entity for scheduling.
 */
typedef struct {
    int           id;             /**< Unique ID (for debugging/timeline) */
    unsigned long burst_time;     /**< Original burst (execution) time */
    int           priority;       /**< Used by priority-based schedulers */
    unsigned long arrival_time;   /**< Arrival time for process */
    unsigned long remaining_time; /**< Remaining execution time */
    unsigned long first_response; /**< Timestamp of first scheduling response */
    unsigned long end_time;       /**< Timestamp when process completed */
    bool          responded;      /**< True if process has responded at least once */

    double        weight;         /**< Weight for Weighted Fair Queueing */

    int           hpc_affinity;   /**< HPC thread index if relevant */

    int           mlfq_level;     /**< MLFQ queue level for demonstration */

    bool          was_preempted;  /**< If forcibly preempted */
} process_t;

/**
 * @brief Initialize a single process struct
 */
void init_process(process_t* p, unsigned long burst, int prio, unsigned long arrival, double weight);

#endif
#include "ready_queue.h"
#include "../lib/log.h"
#include <stdlib.h>
#include <string.h>

/* ------------------------------------------------------
   Internal comparator for sorted insertion
   ------------------------------------------------------ */
typedef int (*proc_cmp_fn)(const process_t* A, const process_t* B);

static int prio_asc_cmp(const process_t* A, const process_t* B){
    return (A->priority - B->priority);
}
static int burst_asc_cmp(const process_t* A, const process_t* B){
    if(A->burst_time < B->burst_time) return -1;
    if(A->burst_time > B->burst_time) return 1;
    return 0;
}

/* Simple ascending sort insertion if cmp != NULL,
   or tail insertion (FIFO) if cmp == NULL. */
static void rq_insert_sorted(ready_queue_t* rq, process_t* p, proc_cmp_fn cmp){
    rq_node_t* n = (rq_node_t*)malloc(sizeof(rq_node_t));
    n->proc = p;
    n->next = NULL;

    if(!rq->head){
        rq->head = n;
        return;
    }
    if(!cmp){
        /* Insert at tail => FIFO */
        rq_node_t* c = rq->head;
        while(c->next) c = c->next;
        c->next = n;
        return;
    }
    /* Else ascending sorted insertion. */
    rq_node_t* c  = rq->head;
    rq_node_t* px = NULL;
    while(c){
        if(cmp(p, c->proc) < 0){
            if(px){
                px->next = n;
            } else {
                rq->head = n;
            }
            n->next = c;
            return;
        }
        px = c;
        c = c->next;
    }
    px->next = n;
}

void rq_init(ready_queue_t* rq, scheduler_alg_t alg){
    memset(rq, 0, sizeof(*rq));
    pthread_mutex_init(&rq->lock, NULL);
    pthread_cond_init(&rq->cond, NULL);
    rq->alg = alg;
    rq->wfq_virtual_time = 0.0;
}

void rq_destroy(ready_queue_t* rq){
    if(!rq) return;
    rq_node_t* c = rq->head;
    while(c){
        rq_node_t* nxt = c->next;
        free(c);
        c = nxt;
    }
    pthread_mutex_destroy(&rq->lock);
    pthread_cond_destroy(&rq->cond);
    memset(rq, 0, sizeof(*rq));
}

void rq_push(ready_queue_t* rq, process_t* p){
    pthread_mutex_lock(&rq->lock);

    if(!p){
        /* termination marker => push front always */
        rq_node_t* n = (rq_node_t*)malloc(sizeof(rq_node_t));
        n->proc = NULL;
        n->next = rq->head;
        rq->head = n;
        rq->size++;
        pthread_cond_broadcast(&rq->cond);
        pthread_mutex_unlock(&rq->lock);
        return;
    }

    switch(rq->alg){
    case ALG_PRIORITY:
        rq_insert_sorted(rq, p, prio_asc_cmp);
        break;
    case ALG_PRIO_PREEMPT:
        rq_insert_sorted(rq, p, prio_asc_cmp);
        break;
    case ALG_SJF:
        rq_insert_sorted(rq, p, burst_asc_cmp);
        break;
    case ALG_HPC:
        /* HPC example => push front. */
    {
        rq_node_t* n = (rq_node_t*)malloc(sizeof(rq_node_t));
        n->proc = p;
        n->next = rq->head;
        rq->head = n;
    }
        break;
    default:
        /* default => FIFO for RR, BFS, MLFQ, WFQ, etc. */
        rq_insert_sorted(rq, p, NULL);
        break;
    }

    rq->size++;
    pthread_cond_broadcast(&rq->cond);
    pthread_mutex_unlock(&rq->lock);
}

process_t* rq_pop(ready_queue_t* rq, bool* got_term){
    *got_term = false;
    pthread_mutex_lock(&rq->lock);

    /* Wait until something is in the queue. */
    while(rq->size == 0){
        pthread_cond_wait(&rq->cond, &rq->lock);
    }

    if(rq->alg == ALG_WFQ){
        /* Weighted Fair Queueing => pick process with earliest
           "finish_time" = (wfq_virtual_time + remaining_time/weight).
           We do partial updates in run_slice, so we basically pick the minimal finish_time at pop. */
        rq_node_t* prev = NULL;
        rq_node_t* best_prev = NULL;
        rq_node_t* best_node = NULL;
        double best_val = 1e15;

        rq_node_t* cur = rq->head;
        while(cur){
            if(!cur->proc){
                /* termination => pick that immediately. */
                best_node = cur;
                break;
            }
            double fin = rq->wfq_virtual_time + (cur->proc->remaining_time / cur->proc->weight);
            if(fin < best_val){
                best_val = fin;
                best_node = cur;
                best_prev = prev;
            }
            prev = cur;
            cur = cur->next;
        }
        if(!best_node){
            pthread_mutex_unlock(&rq->lock);
            return NULL;
        }
        if(!best_node->proc){
            /* got termination marker */
            *got_term = true;
            if(best_node == rq->head){
                rq->head = best_node->next;
            } else if(best_prev){
                best_prev->next = best_node->next;
            }
            free(best_node);
            rq->size--;
            pthread_mutex_unlock(&rq->lock);
            return NULL;
        }
        process_t* ret = best_node->proc;
        if(best_node == rq->head){
            rq->head = best_node->next;
        } else if(best_prev){
            best_prev->next = best_node->next;
        }
        free(best_node);
        rq->size--;
        pthread_mutex_unlock(&rq->lock);
        return ret;
    }
    else {
        /* Non-WFQ => pop head. */
        rq_node_t* h = rq->head;
        rq->head = h->next;
        rq->size--;

        process_t* ret = h->proc;
        if(!ret){
            *got_term = true;
        }
        free(h);
        pthread_mutex_unlock(&rq->lock);
        return ret;
    }
}

bool try_preempt_if_needed(ready_queue_t* rq, process_t* p){
    if(rq->alg != ALG_PRIO_PREEMPT || !p) return false;

    pthread_mutex_lock(&rq->lock);
    if(!rq->head || !rq->head->proc){
        pthread_mutex_unlock(&rq->lock);
        return false;
    }
    process_t* front = rq->head->proc;
    // smaller priority => higher priority
    if(front->priority < p->priority){
        p->was_preempted = true;
        rq_insert_sorted(rq, p, prio_asc_cmp);
        rq->size++;
        pthread_mutex_unlock(&rq->lock);
        return true;
    }
    pthread_mutex_unlock(&rq->lock);
    return false;
}
#ifndef READY_QUEUE_H
#define READY_QUEUE_H

#include <stdbool.h>
#include <pthread.h>
#include "scheduler.h"
#include "process.h"

/* A singly-linked node. */
typedef struct rq_node_s {
    process_t*        proc;
    struct rq_node_s* next;
} rq_node_t;

/* The main "ready queue" structure. */
typedef struct {
    rq_node_t*       head;
    int              size;
    pthread_mutex_t  lock;
    pthread_cond_t   cond;
    scheduler_alg_t  alg;

    double           wfq_virtual_time; /* For Weighted Fair Queueing. */
} ready_queue_t;

/**
 * @brief Initialize a ready queue with a given algorithm.
 */
void rq_init(ready_queue_t* rq, scheduler_alg_t alg);

/**
 * @brief Destroy the queue (frees any leftover nodes).
 */
void rq_destroy(ready_queue_t* rq);

/**
 * @brief Push a process. (If `p == NULL`, we treat that as termination marker.)
 */
void rq_push(ready_queue_t* rq, process_t* p);

/**
 * @brief Pop the next process. If we pop the termination marker, sets *got_term=true.
 */
process_t* rq_pop(ready_queue_t* rq, bool* got_term);

/**
 * @brief Try to see if we need to preempt the current running process
 *        if a higher-priority one arrives in the queue (for ALG_PRIO_PREEMPT).
 *
 * @return true if a preemption occurred and we reinserted the old process.
 */
bool try_preempt_if_needed(ready_queue_t* rq, process_t* p);

#endif // READY_QUEUE_H
#include "scheduler.h"
#include "../lib/log.h"
#include "../lib/scheduler_alg.h"
#include "../lib/library.h"
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <stdbool.h>

unsigned long get_quantum(scheduler_alg_t alg, const process_t* p){
    if(!p) return 0;
    switch(alg){
    case ALG_RR:           return 2;
    case ALG_BFS:          return 4;
    case ALG_WFQ:          return 3;  // [REFINED NOTE]: small timeslice helps partial fairness
    case ALG_MLFQ:         return (2 + p->mlfq_level * 2);
    case ALG_PRIO_PREEMPT: return 2;
    default:
        // FIFO, priority => effectively run to completion, but we will break if needed
        return 2;
    }
}

void record_timeline(container_t* c, int core_id, int proc_id,
                     unsigned long start_ms, unsigned long slice, bool preempted)
{
    pthread_mutex_lock(&c->timeline_lock);
    if(c->timeline_count + 1 >= c->timeline_cap){
        int new_cap = c->timeline_cap + 64;
        void* tmp = realloc(c->timeline, new_cap * sizeof(*c->timeline));
        if(!tmp){
            log_error("record_timeline => OOM");
            pthread_mutex_unlock(&c->timeline_lock);
            return;
        }
        c->timeline = tmp;
        c->timeline_cap = new_cap;
    }
    c->timeline[c->timeline_count].core_id         = core_id;
    c->timeline[c->timeline_count].proc_id         = proc_id;
    c->timeline[c->timeline_count].start_ms        = start_ms;
    c->timeline[c->timeline_count].length_ms       = slice;
    c->timeline[c->timeline_count].preempted_slice = preempted;
    c->timeline_count++;
    pthread_mutex_unlock(&c->timeline_lock);
}

/**
 * Perform actual CPU-bound "work" for ms milliseconds
 * with optional immediate preemption.
 */
void do_cpu_work(unsigned long ms, int core_id, int proc_id)
{
    if(ms == 0) return;

    unblock_preempt_signal();

    // simple loop
    for (unsigned long i=0; i<ms; i++){
        usleep(1000);
    }

    block_preempt_signal();
}
#ifndef SCHEDULER_H
#define SCHEDULER_H
#include <stdbool.h>
#include "../lib/scheduler_alg.h"
#include "process.h"
#include "container.h"
struct container_s;         /* forward-decl for the struct */
typedef struct container_s container_t;  /* shorter alias */
/**
 * @brief Return the timeslice “quantum” for a given algorithm + process.
 */
unsigned long get_quantum(scheduler_alg_t alg, const process_t* p);

/**
 * @brief Perform actual CPU-bound "work" for `ms` milliseconds,
 *        with optional immediate preemption support.
 */
void do_cpu_work(unsigned long ms, int core_id, int proc_id);

/**
 * @brief Record a timeline event into the container's timeline array.
 */
void record_timeline(container_t* c,
                     int core_id,
                     int proc_id,
                     unsigned long start_ms,
                     unsigned long slice,
                     bool preempted_flag);

#endif // SCHEDULER_H
#include "worker.h"
#include "ready_queue.h"
#include "scheduler.h"
#include "../lib/library.h"
#include <pthread.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

/* ------------------------------------------------------------------
   (A) UTILITY: Check if container has exceeded time
   ------------------------------------------------------------------ */
static bool is_time_exhausted(container_t* c){
    pthread_mutex_lock(&c->finish_lock);
    bool r = (c->time_exhausted || (c->accumulated_cpu >= c->max_cpu_time_ms));
    pthread_mutex_unlock(&c->finish_lock);
    return r;
}

/* ------------------------------------------------------------------
   (B) UTILITY: Push termination markers into queues
   ------------------------------------------------------------------ */
static void force_stop(const container_t* c,
                       ready_queue_t* rq_main,
                       ready_queue_t* rq_hpc){
    for(int i=0; i<c->nb_cores; i++){
        rq_push(rq_main, NULL);
    }
    for(int i=0; i<c->nb_hpc_threads; i++){
        rq_push(rq_hpc, NULL);
    }
}

/* ------------------------------------------------------------------
   (C) UTILITY: Check arrivals whose arrival_time <= sim_time
   ------------------------------------------------------------------ */
static void check_main_arrivals(container_t* c, ready_queue_t* rq){
    pthread_mutex_lock(&c->finish_lock);
    unsigned long now = c->sim_time;
    pthread_mutex_unlock(&c->finish_lock);

    for(int i=0; i<c->main_count; i++){
        process_t* p = &c->main_procs[i];
        if(p->remaining_time>0 && p->arrival_time>0 && p->arrival_time <= now){
            fprintf(stderr,"\033[94m[MAIN ARRIVE] P%d arrives at t=%lu => push mainRQ\033[0m\n",
                    p->id, now);
            p->arrival_time = 0;
            rq_push(rq, p);
        }
    }
}
static void check_hpc_arrivals(container_t* c, ready_queue_t* rq){
    pthread_mutex_lock(&c->finish_lock);
    unsigned long now = c->sim_time;
    pthread_mutex_unlock(&c->finish_lock);

    for(int i=0; i<c->hpc_count; i++){
        process_t* p = &c->hpc_procs[i];
        if(p->remaining_time>0 && p->arrival_time>0 && p->arrival_time <= now){
            fprintf(stderr,"\033[95m[HPC ARRIVE]  P%d arrives at t=%lu => push hpcRQ\033[0m\n",
                    p->id, now);
            p->arrival_time = 0;
            rq_push(rq, p);
        }
    }
}

/* ------------------------------------------------------------------
   (D) UTILITY: "Discrete-event" jump if both RQs empty + no active cores
   ------------------------------------------------------------------ */
static void maybe_advance_time_if_idle(container_t* c,
                                       ready_queue_t* main_rq,
                                       ready_queue_t* hpc_rq)
{
    pthread_mutex_lock(&c->finish_lock);

    // if either queue non-empty => no jump
    if(main_rq->size>0) {
        pthread_mutex_unlock(&c->finish_lock);
        return;
    }
    if(!c->allow_hpc_steal && hpc_rq->size>0) {
        pthread_mutex_unlock(&c->finish_lock);
        return;
    }
    // if any core is running => no jump
    if(c->active_cores > 0) {
        pthread_mutex_unlock(&c->finish_lock);
        return;
    }

    // find earliest future arrival (main or HPC)
    unsigned long earliest = (unsigned long)-1;

    for(int i=0; i<c->main_count; i++){
        process_t* p = &c->main_procs[i];
        if(p->remaining_time>0 && p->arrival_time>0 && p->arrival_time<earliest){
            earliest = p->arrival_time;
        }
    }
    for(int i=0; i<c->hpc_count; i++){
        process_t* p = &c->hpc_procs[i];
        if(p->remaining_time>0 && p->arrival_time>0 && p->arrival_time<earliest){
            earliest = p->arrival_time;
        }
    }

    if(earliest == (unsigned long)-1){
        // no future arrivals => forcibly push termination
        for(int i=0;i<c->nb_cores;i++) rq_push(main_rq,NULL);
        for(int i=0;i<c->nb_hpc_threads;i++) rq_push(hpc_rq,NULL);
        pthread_mutex_unlock(&c->finish_lock);
        return;
    }

    // jump sim_time
    c->sim_time = earliest;
    pthread_mutex_unlock(&c->finish_lock);

    // now check arrivals
    check_main_arrivals(c, main_rq);
    check_hpc_arrivals(c, hpc_rq);
}

/* ------------------------------------------------------------------
   (E) Run a timeslice in 1ms increments
   ------------------------------------------------------------------ */
static void run_slice(container_t* c,
                      ready_queue_t* main_rq,
                      ready_queue_t* hpc_rq,
                      process_t* p,
                      scheduler_alg_t alg,
                      int core_id,
                      unsigned long* used_ms)
{
    *used_ms = 0;
    if(!p || p->remaining_time==0) return;

    unsigned long q = get_quantum(alg, p);

    pthread_mutex_lock(&c->finish_lock);
    c->active_cores++;
    unsigned long start_ms = c->sim_time;
    if(!p->responded){
        p->responded      = true;
        p->first_response = start_ms;
    }
    pthread_mutex_unlock(&c->finish_lock);

    bool preempted_flag=false;
    unsigned long slice_used=0;

    while(slice_used < q && !c->time_exhausted && p->remaining_time>0){
        do_cpu_work(1, core_id, p->id);

        pthread_mutex_lock(&c->finish_lock);
        p->remaining_time--;
        c->accumulated_cpu++;
        c->sim_time++;
        slice_used++;

        if(p->remaining_time==0){
            p->end_time = p->first_response + p->burst_time;
            c->remaining_count--;
            if(c->remaining_count<=0) c->time_exhausted=true;
        }
        if(c->accumulated_cpu>=c->max_cpu_time_ms){
            c->time_exhausted=true;
        }
        pthread_mutex_unlock(&c->finish_lock);

        // if WFQ => update each ms
        if(alg==ALG_WFQ){
            pthread_mutex_lock(&main_rq->lock);
            main_rq->wfq_virtual_time+=(1.0/p->weight);
            pthread_mutex_unlock(&main_rq->lock);
        }
        // preemptive priority => check each ms
        if(alg==ALG_PRIO_PREEMPT){
            bool got_preempted = try_preempt_if_needed(main_rq, p);
            if(got_preempted){
                preempted_flag=true;
                break;
            }
        }
        // arrivals each ms
        check_main_arrivals(c, main_rq);
        check_hpc_arrivals(c, hpc_rq);

        if(is_time_exhausted(c)) break;
    }

    // MLFQ => if used entire quantum => next level
    if(alg==ALG_MLFQ && p->remaining_time>0 && slice_used==q){
        p->mlfq_level++;
    }

    *used_ms = slice_used;
    record_timeline(c, core_id, p->id, start_ms, slice_used, preempted_flag);

    if(preempted_flag){
        fprintf(stderr,"\033[33m[CORE %d] PREEMPTED process P%d after %lu ms!\033[0m\n",
                core_id, p->id, slice_used);
    }

    pthread_mutex_lock(&c->finish_lock);
    c->active_cores--;
    pthread_mutex_unlock(&c->finish_lock);
}

/* ------------------------------------------------------------------
   (F) MAIN CORE THREAD
   ------------------------------------------------------------------ */
void* main_core_thread(void* arg){
    core_thread_pack_t* pack = (core_thread_pack_t*)arg;
    container_t* c = pack->container;
    ready_queue_t* main_rq = pack->qs.main_rq;
    ready_queue_t* hpc_rq  = pack->qs.hpc_rq;
    int core_id = pack->core_id;
    free(pack);

    set_core_id_for_this_thread(core_id);

    while(!is_time_exhausted(c)){
        block_preempt_signal();
        sigjmp_buf env;
        int ret=sigsetjmp(env,1);
        register_jmpbuf_for_core(core_id,env);
        if(ret!=0){
            fprintf(stderr,"\033[31m[CORE %d] *** IMMEDIATE PREEMPT => jumped back ***\033[0m\n",
                    core_id);
        }

        maybe_advance_time_if_idle(c, main_rq, hpc_rq);

        bool term_marker=false;
        process_t* p = rq_pop(main_rq,&term_marker);
        if(term_marker || !p){
            fprintf(stderr,"\033[32m[CORE %d] Termination => done.\033[0m\n",core_id);
            break;
        }

        unsigned long used=0;
        run_slice(c, main_rq, hpc_rq, p, c->main_alg, core_id, &used);

        if(!is_time_exhausted(c) && p->remaining_time>0){
            rq_push(main_rq,p);
        }
        if(is_time_exhausted(c)){
            force_stop(c, main_rq, hpc_rq);
            break;
        }
    }
    return NULL;
}

/* ------------------------------------------------------------------
   (G) HPC THREAD => HPC BFS improvements:
       we call maybe_advance_time_if_idle before & after each slice
   ------------------------------------------------------------------ */
void* hpc_thread(void* arg){
    core_thread_pack_t* pack = (core_thread_pack_t*)arg;
    container_t* c=pack->container;
    ready_queue_t* main_rq=pack->qs.main_rq;
    ready_queue_t* hpc_rq =pack->qs.hpc_rq;
    int hpc_idx=pack->core_id;
    free(pack);

    int timeline_id=(-1 - hpc_idx);
    set_core_id_for_this_thread(hpc_idx);

    while(!is_time_exhausted(c)){
        block_preempt_signal();
        sigjmp_buf env;
        int ret=sigsetjmp(env,1);
        register_jmpbuf_for_core(hpc_idx,env);
        if(ret!=0){
            fprintf(stderr,"\033[35m[HPC %d] *** PREEMPT => jumped ***\033[0m\n",hpc_idx);
        }

        /* Before picking next process, let’s see if we can jump time. */
        maybe_advance_time_if_idle(c, main_rq, hpc_rq);

        bool term_marker=false;
        process_t* p = rq_pop(hpc_rq, &term_marker);

        /* HPC steal if HPC queue empty + allow_hpc_steal=1 */
        if(!p && c->allow_hpc_steal){
            p = rq_pop(main_rq,&term_marker);
        }

        if(term_marker || !p){
            fprintf(stderr,"\033[35m[HPC %d] HPC termination => done.\033[0m\n",hpc_idx);
            break;
        }

        unsigned long used=0;
        run_slice(c, main_rq, hpc_rq, p, c->hpc_alg, timeline_id, &used);

        /* After the slice, do another maybe_advance_time_if_idle
           so HPC-only BFS can jump forward if no one’s ready. */
        maybe_advance_time_if_idle(c, main_rq, hpc_rq);

        if(!is_time_exhausted(c) && p->remaining_time>0){
            rq_push(hpc_rq,p);
        }

        if(is_time_exhausted(c)){
            force_stop(c,main_rq,hpc_rq);
            break;
        }
    }
    return NULL;
}
#ifndef WORKER_H
#define WORKER_H

#include "container.h"
#include "ready_queue.h"
#include <stdlib.h>
#include "scheduler.h"
#include "ready_queue.h"
#include "../lib/log.h"
#include <stdio.h>
#include <unistd.h>
#include <stdbool.h>
struct container_s;         /* forward-decl for the struct */
typedef struct container_s container_t;  /* shorter alias */
/**
 * @brief A small struct to pass to each core/hpc thread.
 */
typedef struct core_thread_pack_s {
    container_t* container;
    struct {
        ready_queue_t* main_rq;
        ready_queue_t* hpc_rq;
    } qs;
    int core_id;
} core_thread_pack_t;

/**
 * @brief The function each "main core" thread runs.
 */
void* main_core_thread(void* arg);

/**
 * @brief The function each "HPC" thread runs.
 */
void* hpc_thread(void* arg);

/**
 * @brief Bonus HPC BFS test toggle
 */
int is_bonus_test(void);
void set_bonus_test(int onOff);

#endif // WORKER_H
#include "library.h"
#include "log.h"
#include "scoreboard.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <unistd.h>
#include <signal.h>
#include <pthread.h>

/* -------------------------------------------------------------------
   (A) Global flags for skipping or partial "look" at tests
   ------------------------------------------------------------------- */

static volatile sig_atomic_t g_skip_remaining_tests = 0;
static volatile sig_atomic_t g_look_remaining_tests = 0;

int skip_remaining_tests_requested(void) {
    return (g_skip_remaining_tests != 0);
}
void set_skip_remaining_tests(const int val) {
    g_skip_remaining_tests = (val ? 1 : 0);
}

int look_remaining_tests_requested(void) {
    return (g_look_remaining_tests != 0);
}
void set_look_remaining_tests(const int val) {
    g_look_remaining_tests = (val ? 1 : 0);
}

/* Tracks slow-mode on/off globally: */
static int bonus_test = 0;

void set_bonus_test(const int onOff) {
    bonus_test = (onOff != 0);
}
int is_bonus_test(void) {
    return bonus_test;
}

/**
 * @brief handle_signal for SIGINT, SIGTERM
 */
void handle_signal(const int signum){
    scoreboard_save();
    fflush(stdout);
    fflush(stderr);

    if(signum == SIGINT) {
        log_warn("Caught SIGINT => exiting now");
        exit(scoreboard_get_final_score());
    }
    if(signum == SIGTERM) {
        if (look_remaining_tests_requested()) {
            set_skip_remaining_tests(1);
            log_warn("Caught SIGTERM => skip concurrency tests next");
        } else {
            log_warn("Caught SIGTERM => exiting now");
            exit(scoreboard_get_final_score());
        }
    }
}

/* -------------------------------------------------------------------
   (B) Immediate preemption setup: sigaltstack + setitimer + siglongjmp
   ------------------------------------------------------------------- */

#define MAX_CORES 64

static sigjmp_buf g_jmpbufs[MAX_CORES];
static int        g_registered[MAX_CORES] = {0};

static __thread int t_core_id = -1;

static stack_t g_altstack;

void preempt_signal_handler(int sig) {
    if(sig == SIGALRM){
        int cid = t_core_id;
        if(cid >= 0 && cid < MAX_CORES && g_registered[cid]){
            siglongjmp(g_jmpbufs[cid], 1);
        }
    }
}

void init_preempt_timer(void) {
    // 1) Alternate stack
    memset(&g_altstack, 0, sizeof(g_altstack));
    g_altstack.ss_sp = malloc(SIGSTKSZ);
    if(!g_altstack.ss_sp){
        log_error("init_preempt_timer => cannot allocate altstack");
        return;
    }
    g_altstack.ss_size = SIGSTKSZ;
    g_altstack.ss_flags= 0;
    if(sigaltstack(&g_altstack, NULL) < 0){
        log_error("init_preempt_timer => sigaltstack fail: %s", strerror(errno));
        free(g_altstack.ss_sp);
        g_altstack.ss_sp = NULL;
        return;
    }

    // 2) sigaction
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = preempt_signal_handler;
    sa.sa_flags   = SA_ONSTACK | SA_NODEFER;
    sigemptyset(&sa.sa_mask);
    if(sigaction(SIGALRM, &sa, NULL) < 0){
        log_error("init_preempt_timer => sigaction fail: %s", strerror(errno));
        return;
    }

    // 3) block SIGALRM in main so threads inherit blocked
    sigset_t blockSet;
    sigemptyset(&blockSet);
    sigaddset(&blockSet, SIGALRM);
    pthread_sigmask(SIG_BLOCK, &blockSet, NULL);

    // 4) setitimer => 1ms
    struct itimerval it;
    memset(&it, 0, sizeof(it));
    it.it_interval.tv_sec  = 0;
    it.it_interval.tv_usec = 1000; // 1ms
    it.it_value = it.it_interval;
    if(setitimer(ITIMER_REAL, &it, NULL) < 0){
        log_error("init_preempt_timer => setitimer fail: %s", strerror(errno));
        return;
    }

    log_info("init_preempt_timer => installed 1ms SIGALRM for immediate preemption");
}

void disable_preempt_timer(void){
    struct itimerval it;
    memset(&it, 0, sizeof(it));
    setitimer(ITIMER_REAL, &it, NULL);

    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = SIG_DFL;
    sigaction(SIGALRM, &sa, NULL);

    if(g_altstack.ss_sp){
        free(g_altstack.ss_sp);
        g_altstack.ss_sp = NULL;
        g_altstack.ss_size = 0;
    }
    log_info("disable_preempt_timer => timer off + altstack freed");
}

void set_core_id_for_this_thread(int coreId){
    t_core_id = coreId;
}
int get_core_id_for_this_thread(void){
    return t_core_id;
}
void register_jmpbuf_for_core(int coreId, sigjmp_buf env){
    if(coreId < 0 || coreId >= MAX_CORES){
        log_error("register_jmpbuf_for_core => invalid coreId=%d", coreId);
        return;
    }
    memcpy(g_jmpbufs[coreId], env, sizeof(sigjmp_buf));
    g_registered[coreId] = 1;
}

void block_preempt_signal(void){
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGALRM);
    pthread_sigmask(SIG_BLOCK, &set, NULL);
}

void unblock_preempt_signal(void){
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGALRM);
    pthread_sigmask(SIG_UNBLOCK, &set, NULL);
}
#ifndef LIBRARY_H
#define LIBRARY_H

#include <signal.h>
#include <setjmp.h>

#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GREEN   "\033[92m"
#define CLR_GRAY    "\033[90m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

/**
 * If user hits SIGINT or SIGTERM => scoreboard saving, etc.
 */
void handle_signal(int signum);

/**
 * Return 1 if we decided to skip remaining concurrency tests.
 */
int skip_remaining_tests_requested(void);
void set_skip_remaining_tests(const int val);

/**
 * Return 1 if we only want to "look" at tests but not actually do them.
 */
int look_remaining_tests_requested(void);
void set_look_remaining_tests(const int val);

/**
 * Return 1 if we want slow-mode concurrency.
 */
int is_bonus_test(void);
void set_bonus_test(const int onOff);

/* Preemption with setitimer + altstack + siglongjmp */
void init_preempt_timer(void);
void disable_preempt_timer(void);
void preempt_signal_handler(int sig);

void set_core_id_for_this_thread(int coreId);
int  get_core_id_for_this_thread(void);
void register_jmpbuf_for_core(int coreId, sigjmp_buf env);

void block_preempt_signal(void);
void unblock_preempt_signal(void);

#endif // LIBRARY_H
#include "log.h"

static log_level_t g_log_level = LOG_LEVEL_INFO;

static void vlogf(log_level_t lvl, const char* prefix, const char* fmt, va_list ap){
    if(lvl < g_log_level) return;
    fprintf(stderr, "%s", prefix);
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, CLR_RESET "\n");
}

void set_log_level(log_level_t lvl){
    g_log_level = lvl;
}

void log_debug(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_DEBUG, CLR_BLUE "[DEBUG] " CLR_RESET, fmt, ap);
    va_end(ap);
}

void log_info(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_INFO, CLR_GREEN "[INFO]  " CLR_RESET, fmt, ap);
    va_end(ap);
    fflush(stdout);
    fflush(stderr);
}

void log_warn(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_WARN, CLR_YELLOW "[WARN]  " CLR_RESET, fmt, ap);
    va_end(ap);
}

void log_error(const char* fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    vlogf(LOG_LEVEL_ERROR, CLR_RED "[ERROR] " CLR_RESET, fmt, ap);
    va_end(ap);
}
#ifndef LOG_H
#define LOG_H

#include <stdio.h>
#include <stdarg.h>

/* ======== ANSI COLORS ======== */
#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_RED     "\033[31m"
#define CLR_GREEN   "\033[32m"
#define CLR_YELLOW  "\033[33m"
#define CLR_BLUE    "\033[34m"
#define CLR_MAGENTA "\033[35m"
#define CLR_CYAN    "\033[36m"

typedef enum {
    LOG_LEVEL_DEBUG=0,
    LOG_LEVEL_INFO,
    LOG_LEVEL_WARN,
    LOG_LEVEL_ERROR
} log_level_t;

void set_log_level(log_level_t lvl);

void log_debug(const char* fmt, ...);
void log_info(const char* fmt, ...);
void log_warn(const char* fmt, ...);
void log_error(const char* fmt, ...);

#endif
#ifndef SCHEDULER_ALG_H
#define SCHEDULER_ALG_H

/*
   Standalone definition of the scheduling algorithm enum
*/
typedef enum {
    ALG_NONE=-1,
    ALG_FIFO=0,
    ALG_RR,
    ALG_SJF,
    ALG_PRIORITY,
    ALG_BFS,
    ALG_MLFQ,
    ALG_HPC,
    ALG_WFQ,
    ALG_PRIO_PREEMPT
} scheduler_alg_t;

#endif // SCHEDULER_ALG_H
#include "scoreboard.h"
#include "log.h"
#include "../libExtern/cJSON.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* The global scoreboard struct */
static scoreboard_t gSB;

/* A small helper: compute percentage from pass/total */
static double calc_percent(int total, int pass){
    if(total <= 0) return 0.0;
    return 100.0 * ((double)pass / (double)total);
}

/* Recompute cached percent fields from pass & total */
static void recompute(void){
    gSB.basic_percent        = calc_percent(gSB.basic_total,       gSB.basic_pass);
    gSB.normal_percent       = calc_percent(gSB.normal_total,      gSB.normal_pass);
    gSB.edge_percent         = calc_percent(gSB.edge_total,        gSB.edge_pass);
    gSB.hidden_percent       = calc_percent(gSB.hidden_total,      gSB.hidden_pass);
    gSB.wfq_percent          = calc_percent(gSB.wfq_total,         gSB.wfq_pass);
    gSB.multi_hpc_percent    = calc_percent(gSB.multi_hpc_total,   gSB.multi_hpc_pass);
    gSB.bfs_percent          = calc_percent(gSB.bfs_total,         gSB.bfs_pass);
    gSB.mlfq_percent         = calc_percent(gSB.mlfq_total,        gSB.mlfq_pass);
    gSB.prio_preempt_percent = calc_percent(gSB.prio_preempt_total,gSB.prio_preempt_pass);
    gSB.hpc_bfs_percent      = calc_percent(gSB.hpc_bfs_total,     gSB.hpc_bfs_pass);
}

/* Weighted final score => simpler suites have bigger impact, advanced ones smaller. */
int scoreboard_get_final_score(void){
    recompute();

    double wBasic   = gSB.basic_percent        * 0.20;  /* 20% => BASIC */
    double wNormal  = gSB.normal_percent       * 0.15;  /* 15% => NORMAL */
    double wBFS     = gSB.bfs_percent          * 0.15;  /* BFS => 15% */
    double wEdge    = gSB.edge_percent         * 0.10;  /* 10% => EDGE */
    double wHidden  = gSB.hidden_percent       * 0.10;  /* 10% => HIDDEN */
    double wWFQ     = gSB.wfq_percent          * 0.10;  /* 10% => WFQ */
    double wMulti   = gSB.multi_hpc_percent    * 0.05;  /*  5% => MULTI_HPC */
    double wMLFQ    = gSB.mlfq_percent         * 0.05;  /*  5% => MLFQ */
    double wPrio    = gSB.prio_preempt_percent * 0.05;  /*  5% => PRIO_PREEMPT */
    double wHpcBFS  = gSB.hpc_bfs_percent      * 0.05;  /*  5% => HPC_BFS (bonus) */

    double HPC = (gSB.sc_hpc ? 5.0 : 0.0);  // HPC bonus => +5% if sc_hpc=1

    double total = wBasic + wNormal + wBFS + wEdge + wHidden
                 + wWFQ + wMulti + wMLFQ + wPrio + wHpcBFS
                 + HPC;

    if(total > 100.0) total = 100.0;
    return (int)(total + 0.5);
}

/* Default scoreboard => 0 passes, pass_threshold=60, etc. */
static void scoreboard_defaults(void){
    memset(&gSB, 0, sizeof(gSB));
    gSB.pass_threshold = 60.0;
}

void scoreboard_load(void){
    scoreboard_defaults();
    FILE* f = fopen("scoreboard.json", "rb");
    if(!f){
        log_warn("No scoreboard.json => defaults");
        return;
    }
    fseek(f,0,SEEK_END);
    long sz = ftell(f);
    if(sz < 0){
        fclose(f);
        return;
    }
    fseek(f,0,SEEK_SET);
    char* buf = (char*)malloc(sz+1);
    if(!buf){
        fclose(f);
        return;
    }
    if(fread(buf,1,sz,f) != (size_t)sz){
        free(buf);
        fclose(f);
        return;
    }
    buf[sz] = '\0';
    fclose(f);

    cJSON* root = cJSON_Parse(buf);
    free(buf);
    if(!root){
        log_warn("scoreboard parse fail => defaults");
        return;
    }
    #define JGETINT(o,n,v) do{ cJSON*_t=cJSON_GetObjectItemCaseSensitive(o,n); \
      if(_t&&cJSON_IsNumber(_t)) (v)=_t->valueint;}while(0)
    #define JGETDBL(o,n,v) do{ cJSON*_t=cJSON_GetObjectItemCaseSensitive(o,n); \
      if(_t&&cJSON_IsNumber(_t)) (v)=_t->valuedouble;}while(0)

    JGETINT(root,"basic_total",        gSB.basic_total);
    JGETINT(root,"basic_pass",         gSB.basic_pass);
    JGETINT(root,"normal_total",       gSB.normal_total);
    JGETINT(root,"normal_pass",        gSB.normal_pass);
    JGETINT(root,"edge_total",         gSB.edge_total);
    JGETINT(root,"edge_pass",          gSB.edge_pass);
    JGETINT(root,"hidden_total",       gSB.hidden_total);
    JGETINT(root,"hidden_pass",        gSB.hidden_pass);
    JGETINT(root,"wfq_total",          gSB.wfq_total);
    JGETINT(root,"wfq_pass",           gSB.wfq_pass);
    JGETINT(root,"multi_hpc_total",    gSB.multi_hpc_total);
    JGETINT(root,"multi_hpc_pass",     gSB.multi_hpc_pass);
    JGETINT(root,"bfs_total",          gSB.bfs_total);
    JGETINT(root,"bfs_pass",           gSB.bfs_pass);
    JGETINT(root,"mlfq_total",         gSB.mlfq_total);
    JGETINT(root,"mlfq_pass",          gSB.mlfq_pass);
    JGETINT(root,"prio_preempt_total", gSB.prio_preempt_total);
    JGETINT(root,"prio_preempt_pass",  gSB.prio_preempt_pass);
    JGETINT(root,"hpc_bfs_total",      gSB.hpc_bfs_total);
    JGETINT(root,"hpc_bfs_pass",       gSB.hpc_bfs_pass);

    JGETINT(root,"sc_hpc",            gSB.sc_hpc);
    JGETDBL(root,"pass_threshold",    gSB.pass_threshold);

    cJSON_Delete(root);
    log_info("Scoreboard loaded");
}

void scoreboard_save(void){
    cJSON* root = cJSON_CreateObject();
    #define JADDINT(o,n,v) cJSON_AddNumberToObject(o,n,(double)(v))
    #define JADDDBL(o,n,v) cJSON_AddNumberToObject(o,n,(v))

    JADDINT(root,"basic_total",        gSB.basic_total);
    JADDINT(root,"basic_pass",         gSB.basic_pass);
    JADDINT(root,"normal_total",       gSB.normal_total);
    JADDINT(root,"normal_pass",        gSB.normal_pass);
    JADDINT(root,"edge_total",         gSB.edge_total);
    JADDINT(root,"edge_pass",          gSB.edge_pass);
    JADDINT(root,"hidden_total",       gSB.hidden_total);
    JADDINT(root,"hidden_pass",        gSB.hidden_pass);
    JADDINT(root,"wfq_total",          gSB.wfq_total);
    JADDINT(root,"wfq_pass",           gSB.wfq_pass);
    JADDINT(root,"multi_hpc_total",    gSB.multi_hpc_total);
    JADDINT(root,"multi_hpc_pass",     gSB.multi_hpc_pass);
    JADDINT(root,"bfs_total",          gSB.bfs_total);
    JADDINT(root,"bfs_pass",           gSB.bfs_pass);
    JADDINT(root,"mlfq_total",         gSB.mlfq_total);
    JADDINT(root,"mlfq_pass",          gSB.mlfq_pass);
    JADDINT(root,"prio_preempt_total", gSB.prio_preempt_total);
    JADDINT(root,"prio_preempt_pass",  gSB.prio_preempt_pass);
    JADDINT(root,"hpc_bfs_total",      gSB.hpc_bfs_total);
    JADDINT(root,"hpc_bfs_pass",       gSB.hpc_bfs_pass);

    JADDINT(root,"sc_hpc",             gSB.sc_hpc);
    JADDDBL(root,"pass_threshold",     gSB.pass_threshold);

    char* out = cJSON_Print(root);
    cJSON_Delete(root);

    FILE* f = fopen("scoreboard.json","wb");
    if(!f){
        log_error("Cannot write scoreboard.json");
        free(out);
        return;
    }
    fwrite(out,1,strlen(out),f);
    fclose(f);
    free(out);

    log_info("Scoreboard saved");
}

void scoreboard_clear(void){
    scoreboard_defaults();
    scoreboard_save();
}

/* The scoreboard update functions: simply accumulate total/pass. */
void scoreboard_update_basic(int t,int p){
    gSB.basic_total += t;
    gSB.basic_pass  += p;
}
void scoreboard_update_normal(int t,int p){
    gSB.normal_total += t;
    gSB.normal_pass  += p;
}
void scoreboard_update_edge(int t,int p){
    gSB.edge_total += t;
    gSB.edge_pass  += p;
}
void scoreboard_update_hidden(int t,int p){
    gSB.hidden_total += t;
    gSB.hidden_pass  += p;
}
void scoreboard_update_wfq(int t,int p){
    gSB.wfq_total += t;
    gSB.wfq_pass  += p;
}
void scoreboard_update_multi_hpc(int t,int p){
    gSB.multi_hpc_total += t;
    gSB.multi_hpc_pass  += p;
}
void scoreboard_update_bfs(int t,int p){
    gSB.bfs_total += t;
    gSB.bfs_pass  += p;
}
void scoreboard_update_mlfq(int t,int p){
    gSB.mlfq_total += t;
    gSB.mlfq_pass  += p;
}
void scoreboard_update_prio_preempt(int t,int p){
    gSB.prio_preempt_total += t;
    gSB.prio_preempt_pass  += p;
}
void scoreboard_update_hpc_bfs(int t,int p){
    gSB.hpc_bfs_total += t;
    gSB.hpc_bfs_pass  += p;
}

void scoreboard_set_sc_hpc(int v){
    gSB.sc_hpc = (v ? 1 : 0);
}

/* If suite is locked behind threshold, return 0, else 1. */
int scoreboard_is_unlocked(scoreboard_suite_t s){
    recompute();
    double T = gSB.pass_threshold;
    switch(s){
    case SUITE_BASIC:
        return 1; // always unlocked
    case SUITE_NORMAL:
        return (gSB.basic_percent >= T);
    case SUITE_EDGE:
        return (gSB.normal_percent >= T);
    case SUITE_HIDDEN:
        return (gSB.edge_percent >= T);
    case SUITE_WFQ:
        return (gSB.hidden_percent >= T);
    case SUITE_MULTI_HPC:
        return (gSB.wfq_percent >= T);
    case SUITE_BFS:
        return (gSB.normal_percent >= T);
    case SUITE_MLFQ:
        return (gSB.normal_percent >= T);
    case SUITE_PRIO_PREEMPT:
        return (gSB.edge_percent >= T);
    case SUITE_HPC_BFS:
        return (gSB.hidden_percent >= T);
    default:
        return 0;
    }
}

void get_scoreboard(scoreboard_t* out){
    if(out) *out = gSB;
}

/* Pretty print the scoreboard. */
static void print_suite_line(const char* name, int pass, int total, double percent){
    if(total == 0){
        printf("\033[33m%-26s => %d/%d => %.1f%% (no tests?)\033[0m\n",
               name, pass, total, percent);
        return;
    }
    if(pass == total){
        printf("\033[32m%-26s => %d/%d => %.1f%%\033[0m\n", name, pass, total, percent);
    } else if(pass == 0){
        printf("\033[31m%-26s => %d/%d => %.1f%%\033[0m\n", name, pass, total, percent);
    } else {
        printf("\033[33m%-26s => %d/%d => %.1f%%\033[0m\n", name, pass, total, percent);
    }
}

void show_scoreboard(void){
    scoreboard_t sb;
    get_scoreboard(&sb);
    int final = scoreboard_get_final_score();

    printf("\n\033[1m\033[36m===== REFINED SCOREBOARD =====\033[0m\n");
    print_suite_line("BASIC Tests",         sb.basic_pass,       sb.basic_total,       sb.basic_percent);
    print_suite_line("NORMAL Tests",        sb.normal_pass,      sb.normal_total,      sb.normal_percent);
    print_suite_line("BFS Tests",           sb.bfs_pass,         sb.bfs_total,         sb.bfs_percent);
    print_suite_line("EDGE Cases",          sb.edge_pass,        sb.edge_total,        sb.edge_percent);
    print_suite_line("HIDDEN Cases",        sb.hidden_pass,      sb.hidden_total,      sb.hidden_percent);
    print_suite_line("WFQ (Weighted FQ)",   sb.wfq_pass,         sb.wfq_total,         sb.wfq_percent);
    print_suite_line("MULTI_HPC (Advanced)",sb.multi_hpc_pass,   sb.multi_hpc_total,   sb.multi_hpc_percent);
    print_suite_line("MLFQ Scheduling",     sb.mlfq_pass,        sb.mlfq_total,        sb.mlfq_percent);
    print_suite_line("PRIO_PREEMPT",        sb.prio_preempt_pass,sb.prio_preempt_total,sb.prio_preempt_percent);
    print_suite_line("HPC_BFS Bonus",       sb.hpc_bfs_pass,     sb.hpc_bfs_total,     sb.hpc_bfs_percent);

    printf("HPC Bonus => %s (adds up to 5%%)\n", (sb.sc_hpc ? "YES" : "NO"));
    printf("Final Weighted Score => %d\n", final);
    printf("================================\n\n");
}

void show_legend(void){
    printf("\n\033[1m\033[35m--- Scoreboard Legend / Weights (Refined) ---\033[0m\n");
    printf("  BASIC => 20%%, NORMAL => 15%%, BFS => 15%%, EDGE => 10%%,\n");
    printf("  HIDDEN => 10%%, WFQ => 10%%, MULTI_HPC => 5%%, MLFQ => 5%%,\n");
    printf("  PRIO_PREEMPT => 5%%, HPC_BFS => 5%%, HPC bonus => +5%%\n");
    printf("  pass_threshold => 60%% gates unlocking advanced suites.\n");
    printf("----------------------------------------------\n");
}
#ifndef SCOREBOARD_H
#define SCOREBOARD_H

typedef enum {
    SUITE_BASIC=1,
    SUITE_NORMAL,
    SUITE_EDGE,
    SUITE_HIDDEN,
    SUITE_WFQ,
    SUITE_MULTI_HPC,
    SUITE_BFS,
    SUITE_MLFQ,
    SUITE_PRIO_PREEMPT,
    SUITE_HPC_BFS
} scoreboard_suite_t;

/**
 * @brief The scoreboard structure with refined weighting.
 * We rely on a 60% threshold to unlock advanced suites.
 * Weighted breakdown (up to 100%):
 *   BASIC => 20%
 *   NORMAL => 15%
 *   BFS => 15%
 *   EDGE => 10%
 *   HIDDEN => 10%
 *   WFQ => 10%
 *   MULTI_HPC => 5%
 *   MLFQ => 5%
 *   PRIO_PREEMPT => 5%
 *   HPC_BFS => 5%
 * + HPC bonus => +5% if sc_hpc=1
 */
typedef struct {
    int basic_total,      basic_pass;
    int normal_total,     normal_pass;
    int edge_total,       edge_pass;
    int hidden_total,     hidden_pass;
    int wfq_total,        wfq_pass;
    int multi_hpc_total,  multi_hpc_pass;
    int bfs_total,        bfs_pass;
    int mlfq_total,       mlfq_pass;
    int prio_preempt_total, prio_preempt_pass;
    int hpc_bfs_total,      hpc_bfs_pass;

    double basic_percent,
           normal_percent,
           edge_percent,
           hidden_percent,
           wfq_percent,
           multi_hpc_percent,
           bfs_percent,
           mlfq_percent,
           prio_preempt_percent,
           hpc_bfs_percent;

    double pass_threshold;  // 60.0
    int    sc_hpc;          // HPC bonus toggle => +5% if set
} scoreboard_t;

/* Load/save scoreboard from scoreboard.json */
void scoreboard_load(void);
void scoreboard_save(void);
void scoreboard_clear(void);

/* Update suite test counts. (We accumulate pass/fail in each call) */
void scoreboard_update_basic(int t,int p);
void scoreboard_update_normal(int t,int p);
void scoreboard_update_edge(int t,int p);
void scoreboard_update_hidden(int t,int p);
void scoreboard_update_wfq(int t,int p);
void scoreboard_update_multi_hpc(int t,int p);
void scoreboard_update_bfs(int t,int p);
void scoreboard_update_mlfq(int t,int p);
void scoreboard_update_prio_preempt(int t,int p);
void scoreboard_update_hpc_bfs(int t,int p);

/* HPC bonus on/off => +5% if sc_hpc=1. */
void scoreboard_set_sc_hpc(int v);

/* Gate logic: is suite unlocked after threshold? */
int  scoreboard_is_unlocked(scoreboard_suite_t s);

/* Retrieve + compute final */
void get_scoreboard(scoreboard_t* out);
int  scoreboard_get_final_score(void);

/* Display scoreboard in console */
void show_scoreboard(void);
void show_legend(void);

#endif
