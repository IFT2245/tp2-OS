
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include "runner.h"
#include "os.h"
#include "safe_calls_library.h"
#include "scoreboard.h"

#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GRAY    "\033[90m"
#define CLR_GREEN   "\033[92m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

static void cleanup_and_exit(int code);
static void handle_signal(int signum);

/* Clear terminal screen (POSIX vs Windows). */
static void clear_screen(void){
#if defined(_WIN32) || defined(_WIN64)
    system("cls");
#else
    system("clear");
#endif
}

static void pause_enter(void){
    printf("\nPress ENTER...");
    fflush(stdout);
    int c;
    while((c = getchar()) != '\n' && c != EOF){}
}

/* Safe read_line for user input. */
static int read_line(char *buf, size_t sz){
    if(!fgets(buf, sz, stdin)) return 0;
    buf[strcspn(buf, "\n")] = '\0';
    return 1;
}

/* Show scoreboard in a nice ASCII box. */
static void menu_show_scoreboard(void){
    scoreboard_t sb;
    get_scoreboard(&sb);
    clear_screen();

    printf(CLR_BOLD CLR_MAGENTA "╔════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_MAGENTA "║           ★ SCOREBOARD ★          ║\n" CLR_RESET);

    printf("║ BASIC       => %.1f/100 => %s\n",
           sb.basic_percent,
           unlocked_basic ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ NORMAL      => %.1f/100 => %s\n",
           sb.normal_percent,
           unlocked_normal ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ EXTERNAL    => %.1f/100 => %s\n",
           sb.external_percent,
           unlocked_external ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ MODES       => %.1f/100 => %s\n",
           sb.modes_percent,
           unlocked_modes ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ EDGE        => %.1f/100 => %s\n",
           sb.edge_percent,
           unlocked_edge ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║ HIDDEN      => %.1f/100 => %s\n",
           sb.hidden_percent,
           unlocked_hidden ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);

    printf("║\n");
    printf("║ Schedulers mastery (for 10%% block):\n");
    printf("║   FIFO:%s  RR:%s  CFS:%s  CFS-SRTF:%s  BFS:%s\n",
           sb.sc_fifo? "✔":"✘",
           sb.sc_rr? "✔":"✘",
           sb.sc_cfs? "✔":"✘",
           sb.sc_cfs_srtf? "✔":"✘",
           sb.sc_bfs? "✔":"✘");

    printf("║   SJF:%s  STRF:%s  HRRN:%s  HRRN-RT:%s  PRIORITY:%s\n",
           sb.sc_sjf? "✔":"✘",
           sb.sc_strf? "✔":"✘",
           sb.sc_hrrn? "✔":"✘",
           sb.sc_hrrn_rt? "✔":"✘",
           sb.sc_priority? "✔":"✘");

    printf("║   HPC-OVER:%s  MLFQ:%s\n",
           sb.sc_hpc_over? "✔":"✘",
           sb.sc_mlfq? "✔":"✘");

    int final_score = scoreboard_get_final_score();
    printf("║\n");
    printf("╚═ Overall Score => %d/100\n", final_score);
    pause_enter();
}

/* Clear scoreboard entirely. */
static void menu_clear_scoreboard(void){
    scoreboard_clear();
    printf("\nScoreboard cleared.\n");
    pause_enter();
}

/* Cleanup and exit. */
static void cleanup_and_exit(int code){
    os_cleanup();
    scoreboard_save();
    scoreboard_close();
    exit(code);
}

/* Handle Ctrl-C => Save scoreboard before exiting. */
static void handle_signal(int signum){
    if(signum == SIGINT){
        printf("\nCaught SIGINT! Saving scoreboard...\n");
        int fs = scoreboard_get_final_score();
        cleanup_and_exit(fs);
    }
}

/* Let user choose concurrency level => short, medium, stress. */
static int menu_choose_concurrency_level(void){
    printf("\nChoose concurrency test type:\n");
    printf(" 1) Short test (sleep 2)\n");
    printf(" 2) Medium test (sleep 5)\n");
    printf(" 3) Stress test (sleep 10 or more)\n");
    printf("Choice: ");
    char buf[256];
    if(!read_line(buf,sizeof(buf))) return 1;
    int x = parse_int_strtol(buf,1);
    if(x<1 || x>3) x=1;
    return x;
}

/*
  Submenu for external concurrency:
   1) single scheduling mode
   2) all scheduling modes
*/
static void menu_submenu_external_concurrency(void){
    printf(CLR_BOLD CLR_CYAN "\n╔══════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "║ External Shell Concurrency   ║\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "╚══════════════════════════════╝\n" CLR_RESET);

    printf("1) Run concurrency with a SINGLE scheduling mode\n");
    printf("2) Run concurrency with ALL scheduling modes\n");
    printf("\nChoice: ");
    char buf[256];
    if(!read_line(buf, sizeof(buf))) return;
    int sub = parse_int_strtol(buf, -1);
    if(sub < 1 || sub > 2){
        printf("Invalid.\n");
        pause_enter();
        return;
    }

    printf("How many concurrent shells? ");
    if(!read_line(buf, sizeof(buf))) return;
    int n = parse_int_strtol(buf, 0);
    if(n<1){
        printf("Invalid number of shells.\n");
        pause_enter();
        return;
    }

    printf("How many CPU cores? ");
    if(!read_line(buf, sizeof(buf))) return;
    int c = parse_int_strtol(buf, 2);
    if(c<1) c=2;

    /* Build lines array. */
    char** lines = (char**)calloc(n, sizeof(char*));
    if(!lines) return;

    if(sub==1){
        int style=menu_choose_concurrency_level();
        if(style==1){
            for(int i=0;i<n;i++){
                char tmp[64];
                snprintf(tmp,sizeof(tmp),"sleep %d", (i+1)*2);
                lines[i]=strdup(tmp);
            }
        } else if(style==2){
            for(int i=0;i<n;i++){
                char tmp[64];
                snprintf(tmp,sizeof(tmp),"sleep %d", ((i+1)*3)+2);
                lines[i]=strdup(tmp);
            }
        } else {
            for(int i=0;i<n;i++){
                char tmp[64];
                snprintf(tmp,sizeof(tmp),"sleep %d", (i+1)*5);
                lines[i]=strdup(tmp);
            }
        }
    } else {
        /* sub==2 => same lines for all modes => "sleep 2" scaled. */
        for(int i=0;i<n;i++){
            char tmp[64];
            snprintf(tmp,sizeof(tmp),"sleep %d", (i+1)*2);
            lines[i]=strdup(tmp);
        }
    }

    if(sub==1){
        printf("\nSelect scheduling mode:\n");
        printf(" 0=FIFO,1=RR,2=CFS,3=CFS-SRTF,4=BFS,\n");
        printf(" 5=SJF,6=STRF,7=HRRN,8=HRRN-RT,\n");
        printf(" 9=PRIORITY,10=HPC-OVER,11=MLFQ\n");
        printf("Choice: ");
        if(!read_line(buf,sizeof(buf))){
            pause_enter();
            for(int i=0;i<n;i++) free(lines[i]);
            free(lines);
            return;
        }
        int mode = parse_int_strtol(buf, -1);
        if(mode<0 || mode>11){
            printf("Invalid mode.\n");
            pause_enter();
        } else {
            run_shell_commands_concurrently(n, lines, c, mode, 0);
        }
    } else {
        run_shell_commands_concurrently(n, lines, c, -1, 1);
    }

    for(int i=0; i<n; i++){
        free(lines[i]);
    }
    free(lines);
    pause_enter();
}

int main(int argc, char** argv){
    (void)argc; (void)argv;
    signal(SIGINT, handle_signal);

    scoreboard_init();
    scoreboard_load();
    os_init();

    while(1){
        clear_screen();
        printf(CLR_BOLD CLR_YELLOW "┌─── MAIN MENU ────────────────────┐\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 1) Run All Unlocked              │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 2) Exit                          │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 3) External Shell Concurrency    │\n" CLR_RESET);

        if(unlocked_external){
            printf(CLR_BOLD CLR_YELLOW "│ 4) External Tests                │\n" CLR_RESET);
        } else {
            printf(CLR_BOLD CLR_YELLOW "│ 4) External Tests " CLR_GRAY "(locked)" CLR_RESET "\n");
        }

        printf(CLR_BOLD CLR_YELLOW "│ 5) Show Scoreboard               │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 6) Clear Scoreboard              │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "└───────────────────────────────────┘\n\n" CLR_RESET);
        printf("Choice: ");

        char input[256];
        if(!read_line(input, sizeof(input))){
            printf("Exiting (EOF/read error).\n");
            int fs = scoreboard_get_final_score();
            cleanup_and_exit(fs);
        }
        int choice = parse_int_strtol(input, -1);

        switch(choice){
        case 1:
            printf("\n" CLR_CYAN "Running all unlocked tests...\n" CLR_RESET);
            run_all_levels();
            scoreboard_save();
            pause_enter();
            break;

        case 2:{
            int fs = scoreboard_get_final_score();
            printf("\nExiting with final score = %d.\n", fs);
            cleanup_and_exit(fs);
            break;
        }

        case 3:
            if(!unlocked_external){
                printf("External is locked.\n");
                pause_enter();
            } else {
                menu_submenu_external_concurrency();
            }
            break;

        case 4:
            if(!unlocked_external){
                printf("External tests locked.\n");
                pause_enter();
            } else {
                printf("\nRunning external tests...\n");
                run_external_tests_menu();
                scoreboard_save();
                pause_enter();
            }
            break;

        case 5:
            menu_show_scoreboard();
            break;

        case 6:
            menu_clear_scoreboard();
            break;

        default:
            printf("Invalid.\n");
            pause_enter();
            break;
        }
    }
    return 0;
}
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <pthread.h>
#include <sys/wait.h>
#include "os.h"

#define MAX_CONTAINERS 32

#define CLR_CYAN    "\033[96m"
#define CLR_GREEN   "\033[92m"
#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"

static uint64_t start_ms=0;
static char container_paths[MAX_CONTAINERS][256];
static int container_count=0;

static uint64_t now_ms(void){
    /* Real-time measurement for ASCII printing timestamps only. */
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec*1000ULL + (ts.tv_nsec/1000000ULL);
}

void os_init(void){
    setvbuf(stdout,NULL,_IONBF,0);
    setvbuf(stderr,NULL,_IONBF,0);
    start_ms=now_ms();
    memset(container_paths, 0, sizeof(container_paths));
    container_count=0;

    printf(CLR_BOLD CLR_MAGENTA "==== OS INIT ====" CLR_RESET "\n");
    /* small delay so we can see output clearly */
    usleep(250000);
}

void os_cleanup(void){
    while(container_count>0){
        os_remove_ephemeral_container();
        usleep(200000);
    }
    printf(CLR_BOLD CLR_MAGENTA "==== OS CLEANUP ====" CLR_RESET "\n");
    usleep(250000);
}

uint64_t os_time(void){
    /* Return how many ms since we started the OS. This is purely for
       printing/logging, not for scheduling stats. */
    return now_ms() - start_ms;
}

void os_log(const char* msg){
    if(msg) {
        printf("%s\n", msg);
        usleep(150000);
    }
}

void os_create_ephemeral_container(void){
    if(container_count >= MAX_CONTAINERS) return;
    char tmpl[]="/tmp/os_cont_XXXXXX";
    if(mkdtemp(tmpl)){
        strncpy(container_paths[container_count], tmpl, 255);
        container_count++;
        printf(CLR_CYAN "$$$$$ Container created: %s (count=%d) $$$$$" CLR_RESET "\n",
               tmpl, container_count);
        usleep(250000);
    }
}

void os_remove_ephemeral_container(void){
    if(container_count<=0) return;
    container_count--;
    const char* path=container_paths[container_count];
    if(path[0]){
        rmdir(path);
        memset(container_paths[container_count], 0, sizeof(container_paths[container_count]));
        printf(CLR_CYAN "$$$$$ Container removed: %s (remaining=%d) $$$$$" CLR_RESET "\n",
               path, container_count);
        usleep(250000);
    }
}

/* overshadow_thread simulates HPC overshadowing by heavy CPU. */
static void* overshadow_thread(void* arg){
    long* ret=(long*)arg;
    long s=0;
    for(long i=0; i<700000; i++){
        s += (i%17)+(i%11);
    }
    *ret=s;
    return NULL;
}

void os_run_hpc_overshadow(void){
    printf(CLR_CYAN "$$$$$$$$$$$$$ HPC-OVERSHADOW BLOCK START $$$$$$$$$$$$$\n" CLR_RESET);
    usleep(200000);

    int n=4;
    long* vals=(long*)calloc(n,sizeof(long));
    pthread_t* th=(pthread_t*)malloc(n*sizeof(pthread_t));

    for(int i=0;i<n;i++){
        pthread_create(&th[i],NULL,overshadow_thread,&vals[i]);
        printf(CLR_GREEN "   HPC Overshadow Thread #%d => time=%llu ms => started.\n" CLR_RESET,
               i+1, (unsigned long long)os_time());
        usleep(300000);
    }

    for(int i=0;i<n;i++){
        pthread_join(th[i],NULL);
        printf(CLR_GREEN "   HPC Overshadow Thread #%d => time=%llu ms => finished.\n" CLR_RESET,
               i+1, (unsigned long long)os_time());
        usleep(300000);
    }

    free(th);
    free(vals);

    printf(CLR_CYAN "$$$$$$$$$$$$$ HPC-OVERSHADOW BLOCK END $$$$$$$$$$$$$\n" CLR_RESET);
    usleep(200000);
    printf("HPC overshadow done\n");
    usleep(200000);
}

void os_pipeline_example(void){
    printf("Pipeline start\n");
    printf(CLR_CYAN "$$$$$$$$$$$ PIPELINE BLOCK START $$$$$$$$$$$$$\n" CLR_RESET);
    usleep(200000);

    pid_t c=fork();
    if(c==0){
        printf(CLR_GREEN "   [Pipeline child => started => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        usleep(50000);
        printf(CLR_GREEN "   [Pipeline child => finishing => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        _exit(0);
    }
    printf(CLR_GREEN "   [Pipeline parent => waiting child => time=%llu ms]\n" CLR_RESET,
           (unsigned long long)os_time());
    usleep(200000);
    waitpid(c,NULL,0);

    printf(CLR_CYAN "$$$$$$$$$$$ PIPELINE BLOCK END $$$$$$$$$$$$$\n" CLR_RESET);
    usleep(200000);
    printf("Pipeline end\n");
    usleep(200000);
}

void os_run_distributed_example(void){
    printf("Distributed example: fork\n");
    printf(CLR_CYAN "$$$$$$$ DISTRIBUTED BLOCK START $$$$$$$$\n" CLR_RESET);
    usleep(200000);

    pid_t c=fork();
    if(c==0){
        printf(CLR_GREEN "   [Distributed child => HPC overshadow => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        usleep(200000);
        os_run_hpc_overshadow();
        _exit(0);
    } else {
        printf(CLR_GREEN "   [Distributed parent => waiting => time=%llu ms]\n" CLR_RESET,
               (unsigned long long)os_time());
        usleep(200000);
        waitpid(c,NULL,0);
    }

    printf(CLR_CYAN "$$$$$$$ DISTRIBUTED BLOCK END $$$$$$$$\n" CLR_RESET);
    usleep(200000);
}
#ifndef OS_H
#define OS_H

#include <stdint.h>

/*
  OS-level stubs:
   - ephemeral containers
   - HPC overshadow
   - pipeline
   - distributed example
   - time logging
*/
void     os_init(void);
void     os_cleanup(void);
uint64_t os_time(void);      /* real-time offset for user display only */
void     os_log(const char* msg);

void     os_create_ephemeral_container(void);
void     os_remove_ephemeral_container(void);

void     os_run_hpc_overshadow(void);
void     os_pipeline_example(void);
void     os_run_distributed_example(void);

#endif
#include "process.h"
#include <string.h>

void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival){
    if(!p) return;
    memset(p, 0, sizeof(*p));
    p->burst_time       = burst;
    p->remaining_time   = burst;
    p->priority         = priority;
    p->arrival_time     = arrival; /* For simulated scheduling time usage */
    p->times_owning_core= 0;
    /* We will set start_time/end_time etc. in the scheduler. */
}
#ifndef PROCESS_H
#define PROCESS_H

#include <stdint.h>

/*
  Represents a single "process" or "task" in our scheduler.
  We'll track the original burst_time, priority, arrival_time,
  plus some scheduling fields (vruntime, remaining_time, start_time, end_time, etc.).
*/

typedef struct process_s {
    uint64_t burst_time;       /* how long the process takes (ms) total */
    int      priority;         /* smaller => higher priority (in some algs) */
    uint64_t vruntime;         /* used by CFS */
    uint64_t arrival_time;     /* simulation arrival time */
    uint64_t remaining_time;   /* how many ms remain for this process */

    /* Additional fields to track stats: */
    uint64_t start_time;       /* first time it's scheduled (sim time) */
    uint64_t end_time;         /* finish time (sim time) */
    uint64_t first_response;   /* first time on CPU (sim time) */
    int      responded;        /* 0 if not responded yet, 1 if yes */

    int      mlfq_level;       /* which queue level for MLFQ */
    int      times_owning_core;/* how many times scheduled so far */
} process_t;

/* Initialize a process with the given burst, priority, arrival_time. */
void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival);

#endif
#include <pthread.h>
#include <stdlib.h>
#include <string.h>
#include "ready_queue.h"
#include "os.h"

/* Implementation of a multi-level structure for MLFQ, or a single queue, etc. */

#define MLFQ_MAX_QUEUES 10

typedef struct node_s {
    process_t*     proc;
    struct node_s* next;
} node_t;

static struct {
    node_t sentinel;
    size_t size;
    pthread_mutex_t m;
    pthread_cond_t  c;
    scheduler_alg_t alg;
    node_t ml_queues[MLFQ_MAX_QUEUES]; /* for MLFQ usage */
} gQ;

static pthread_mutex_t* pm(void){ return &gQ.m; }
static pthread_cond_t*  pc(void){ return &gQ.c; }

/* For non-MLFQ, we store all in sentinel -> next chain. */

static process_t* pop_head(void){
    while(!gQ.sentinel.next){
        pthread_cond_wait(pc(), pm());
    }
    node_t* n=gQ.sentinel.next;
    gQ.sentinel.next=n->next;
    gQ.size--;
    process_t* r=n->proc;
    free(n);
    return r;
}

/* Insert at tail for FIFO, RR, BFS, etc. */
static void push_tail(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;

    node_t* c=&gQ.sentinel;
    while(c->next) c=c->next;
    c->next=n;
    gQ.size++;
}

/* Insert by priority (smaller priority => schedule first). */
static void push_prio(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;

    node_t* c=&gQ.sentinel;
    while(c->next && (p->priority >= c->next->proc->priority)){
        c=c->next;
    }
    n->next=c->next;
    c->next=n;
    gQ.size++;
}

/* Insert by vruntime ascending. */
static void push_cfs(process_t* p){
    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;
    node_t* c=&gQ.sentinel;
    while(c->next && (p->vruntime >= c->next->proc->vruntime)){
        c=c->next;
    }
    n->next=c->next;
    c->next=n;
    gQ.size++;
}

/* Insert by burst_time ascending => SJF. */
static void push_sjf(process_t* p){
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;
    node_t* c = &gQ.sentinel;
    while(c->next && (p->burst_time >= c->next->proc->burst_time)){
        c=c->next;
    }
    n->next=c->next;
    c->next=n;
    gQ.size++;
}

/* Weighted ratio => HRRN => we approximate using (wait+remain)/remain. We'll do the push in descending order. */
static uint64_t hrrn_val(process_t* p, uint64_t current_sim_time){
    uint64_t wait = (current_sim_time > p->arrival_time)
                    ? (current_sim_time - p->arrival_time)
                    : 0ULL;
    uint64_t r = (p->remaining_time>0 ? p->remaining_time : 1);
    /* ratio = (wait + r)/r => we store scaled ratio in integer. */
    return (wait + r);
}

static void push_hrrn(process_t* p){
    /* We'll place p in the queue so that if p has bigger ratio => earlier in the list. */
    extern uint64_t get_global_sim_time(void);
    uint64_t now = get_global_sim_time();
    uint64_t new_val = hrrn_val(p, now);

    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;

    node_t* c=&gQ.sentinel;
    while(c->next){
        uint64_t cv = hrrn_val(c->next->proc, now);
        if(new_val > cv){
            /* bigger ratio => insert here. */
            break;
        }
        c=c->next;
    }
    n->next=c->next;
    c->next=n;
    gQ.size++;
}

/* MLFQ => pop from the highest priority queue that has something. */
static process_t* pop_mlfq(void){
    for(int i=0;i<MLFQ_MAX_QUEUES;i++){
        if(gQ.ml_queues[i].next){
            /* pop head from queue i */
            node_t* n = gQ.ml_queues[i].next;
            gQ.ml_queues[i].next = n->next;
            gQ.size--;
            process_t* r = n->proc;
            free(n);
            return r;
        }
    }
    return NULL;
}

/* push to MLFQ queue based on p->mlfq_level. */
static void push_mlfq(process_t* p){
    if(!p) return;
    int lev = p->mlfq_level;
    if(lev < 0) lev=0;
    if(lev >= MLFQ_MAX_QUEUES) lev=MLFQ_MAX_QUEUES-1;

    node_t* n=(node_t*)malloc(sizeof(node_t));
    n->proc=p;
    n->next=NULL;

    node_t* c=&gQ.ml_queues[lev];
    while(c->next) c=c->next;
    c->next=n;
    gQ.size++;
}

/* We'll keep function pointers based on the chosen alg. */
static process_t* (*f_pop)(void)=NULL;
static void       (*f_push)(process_t*)=NULL;

void ready_queue_init_policy(scheduler_alg_t alg){
    memset(&gQ, 0, sizeof(gQ));
    pthread_mutex_init(pm(), NULL);
    pthread_cond_init(pc(), NULL);
    gQ.alg = alg;

    switch(alg){
    case ALG_FIFO:
    case ALG_RR:
    case ALG_BFS:
        f_push = push_tail;
        f_pop  = pop_head;
        break;
    case ALG_PRIORITY:
        f_push = push_prio;
        f_pop  = pop_head;
        break;
    case ALG_CFS:
    case ALG_CFS_SRTF:
        f_push = push_cfs;
        f_pop  = pop_head;
        break;
    case ALG_SJF:
    case ALG_STRF:
        f_push = push_sjf;
        f_pop  = pop_head;
        break;
    case ALG_HRRN:
    case ALG_HRRN_RT:
        f_push = push_hrrn;
        f_pop  = pop_head;
        break;
    case ALG_MLFQ:
        f_push = push_mlfq;
        f_pop  = pop_mlfq;
        break;
    default:
        f_push = push_tail;
        f_pop  = pop_head;
        break;
    }
}

void ready_queue_destroy(void){
    pthread_cond_destroy(pc());
    pthread_mutex_destroy(pm());
    memset(&gQ, 0, sizeof(gQ));
}

void ready_queue_push(process_t* p){
    pthread_mutex_lock(pm());
    f_push(p);
    pthread_cond_signal(pc());
    pthread_mutex_unlock(pm());
}

process_t* ready_queue_pop(void){
    pthread_mutex_lock(pm());
    process_t* r=f_pop();
    while(!r){
        pthread_cond_wait(pc(), pm());
        r=f_pop();
    }
    pthread_mutex_unlock(pm());
    return r;
}

size_t ready_queue_size(void){
    pthread_mutex_lock(pm());
    size_t s=gQ.size;
    pthread_mutex_unlock(pm());
    return s;
}
#ifndef READY_QUEUE_H
#define READY_QUEUE_H

#include <stddef.h>
#include "process.h"
#include "scheduler.h"

/*
  Our "ready queue" data structure, with a policy determined by the chosen scheduler algorithm.
  It's thread-safe with mutex + cond.
*/

void       ready_queue_init_policy(scheduler_alg_t alg);
void       ready_queue_destroy(void);
void       ready_queue_push(process_t* proc);
process_t* ready_queue_pop(void);
size_t     ready_queue_size(void);

#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <errno.h>
#include <sys/ptrace.h>
#include "runner.h"
#include "scoreboard.h"
#include "os.h"
#include "scheduler.h"
#include "worker.h"
#include "../test/basic-test.h"
#include "../test/normal-test.h"
#include "../test/modes-test.h"
#include "../test/edge-test.h"
#include "../test/hidden-test.h"
#include "../test/external-test.h"
#include <pthread.h>
#include "safe_calls_library.h"

/* Global unlocked flags. */
extern int unlocked_basic, unlocked_normal, unlocked_modes,
           unlocked_edge, unlocked_hidden, unlocked_external;

/* run_all_levels():
   Calls each test suite if unlocked. */
void run_all_levels(void){
    if(!unlocked_basic){
        printf("BASIC locked.\n");
        return;
    }
    {
        int t=0,p=0;
        run_basic_tests(&t,&p);
        scoreboard_update_basic(t,p);
        scoreboard_save();
    }

    if(!unlocked_normal){
        printf("NORMAL locked.\n");
        return;
    }
    {
        int t=0,p=0;
        run_normal_tests(&t,&p);
        scoreboard_update_normal(t,p);
        scoreboard_save();
    }

    if(!unlocked_modes){
        printf("MODES locked.\n");
        return;
    }
    {
        int t=0,p=0;
        run_modes_tests(&t,&p);
        scoreboard_update_modes(t,p);
        scoreboard_save();
    }

    if(!unlocked_edge){
        printf("EDGE locked.\n");
        return;
    }
    {
        int t=0,p=0;
        run_edge_tests(&t,&p);
        scoreboard_update_edge(t,p);
        scoreboard_save();
    }

    if(!unlocked_hidden){
        printf("HIDDEN locked.\n");
        return;
    }
    {
        int t=0,p=0;
        run_hidden_tests(&t,&p);
        scoreboard_update_hidden(t,p);
        scoreboard_save();
    }
}

/* From external-test.c */
void run_external_tests_menu(void){
    if(!unlocked_external) return;
    run_external_tests();
}

/* Example advanced child tracing with ptrace. */
static void advanced_debug_child(pid_t pid){
    if(ptrace(PTRACE_ATTACH, pid, NULL, NULL)==-1){
        fprintf(stderr,"[Runner] ptrace attach fail (pid=%d): %s\n",
                pid, strerror(errno));
        return;
    }
    waitpid(pid,NULL,0);
    ptrace(PTRACE_DETACH, pid, NULL, NULL);
}

typedef struct {
    pid_t pid;
    char* cmd;
    int   core;
    uint64_t start_ms;
    uint64_t end_ms;
    int   p_out[2];
    int   p_err[2];
    int   p_in[2];
} child_t;

/* All possible modes: 12 total. */
static scheduler_alg_t modes_arr[]={
    ALG_FIFO, ALG_RR, ALG_CFS, ALG_CFS_SRTF, ALG_BFS,
    ALG_SJF, ALG_STRF, ALG_HRRN, ALG_HRRN_RT, ALG_PRIORITY,
    ALG_HPC_OVERSHADOW, ALG_MLFQ
};

static const char* modeNames[]={
    "FIFO","RR","CFS","CFS-SRTF","BFS",
    "SJF","STRF","HRRN","HRRN-RT","PRIORITY",
    "HPC-OVER","MLFQ"
};

static pid_t spawn_child(const char* cmd, child_t* ch, int core){
    pipe(ch->p_out);
    pipe(ch->p_err);
    pipe(ch->p_in);

    pid_t c=fork();
    if(c<0){
        fprintf(stderr,"fork() error\n");
        return -1;
    }
    else if(c==0){
        /* Child side */
        close(ch->p_out[0]);
        close(ch->p_err[0]);
        close(ch->p_in[0]);
        dup2(ch->p_out[1],STDOUT_FILENO);
        dup2(ch->p_err[1],STDERR_FILENO);
        dup2(ch->p_in[1],STDIN_FILENO);
        close(ch->p_out[1]);
        close(ch->p_err[1]);
        close(ch->p_in[1]);

        execl("./shell-tp1-implementation", "shell-tp1-implementation", (char*)NULL);
        _exit(127);
    }
    else {
        /* Parent side */
        ch->pid=c;
        ch->cmd=(cmd?strdup(cmd):NULL);
        ch->core=core;
        ch->start_ms=os_time();
        close(ch->p_out[1]);
        close(ch->p_err[1]);
        close(ch->p_in[0]);

        /* Send the command plus an exit */
        dprintf(ch->p_in[1], "%s\nexit\n", cmd?cmd:"");
        close(ch->p_in[1]);

        /* Attach ptrace => advanced debugging example. (Optional) */
        advanced_debug_child(c);
    }
    return c;
}

/*
  run_shell_commands_concurrently():
    - If (mode<0 & allModes=1) => test all known sched modes.
    - Else => test chosen mode.
    - Each child => runs "shell-tp1-implementation" with "sleep" command.
    - We show concurrency lines with ASCII-art block.
*/
void run_shell_commands_concurrently(int count, char** lines, int coreCount,
                                     int mode, int allModes)
{
    if(count<=0 || !lines) return;
    if(access("./shell-tp1-implementation", X_OK)!=0){
        printf("No shell-tp1-implementation found (expected to be in CWD).\n");
        return;
    }

    int from=0;
    int to=(int)(sizeof(modes_arr)/sizeof(modes_arr[0]))-1;
    if(!allModes){
        if(mode<0 || mode>to){
            printf("Invalid scheduling mode.\n");
            return;
        }
        from=mode;
        to=mode;
    }

    for(int m=from; m<=to; m++){
        printf("\n\033[95m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
        printf("SCHEDULE BLOCK START => %s\n", modeNames[m]);
        printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
        usleep(300000);

        child_t* ch=(child_t*)calloc(count, sizeof(child_t));
        if(!ch) return;

        uint64_t global_start=os_time();
        int next_core=0;

        /* Spawn children. */
        for(int i=0; i<count; i++){
            spawn_child(lines[i], &ch[i], next_core);
            printf("\033[92m[time=%llu ms] container=1 core=%d => Launch child#%d cmd=\"%s\"\033[0m\n",
                   (unsigned long long)os_time(),
                   next_core, i+1, lines[i]?lines[i]:"(none)");
            /* small delay to see them launching */
            usleep(300000);
            next_core=(next_core+1) % coreCount;
        }

        /* Wait for each child to finish. */
        for(int i=0; i<count; i++){
            if(!ch[i].pid) continue;
            waitpid(ch[i].pid, NULL, 0);
            ch[i].end_ms=os_time();
            printf("\033[93m[time=%llu ms] container=1 core=%d => Child#%d ended => cmd=\"%s\" total_duration=%llums\033[0m\n",
                   (unsigned long long)os_time(),
                   ch[i].core, i+1, ch[i].cmd?ch[i].cmd:"",
                   (unsigned long long)(ch[i].end_ms - ch[i].start_ms));
            usleep(300000);
        }

        uint64_t global_end=os_time();
        uint64_t total_time=(global_end>global_start?(global_end - global_start):0ULL);

        /* Drain leftover output, close pipes. */
        for(int i=0; i<count; i++){
            if(!ch[i].pid) continue;
            char outb[256]={0}, errb[256]={0};
            read(ch[i].p_out[0], outb, sizeof(outb)-1);
            read(ch[i].p_err[0], errb, sizeof(errb)-1);
            close(ch[i].p_out[0]);
            close(ch[i].p_err[0]);
            if(ch[i].cmd) free(ch[i].cmd);
        }
        free(ch);

        printf("\033[96m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
        printf("SCHEDULE BLOCK END => %s, total_time=%llums\n",
               modeNames[m], (unsigned long long)total_time);
        printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
        usleep(400000);
    }
}
#ifndef RUNNER_H
#define RUNNER_H

/*
  runner.h => code to run test suites, or concurrency shell commands
  with chosen scheduling modes.
*/

void run_all_levels(void);
void run_external_tests_menu(void);

void run_shell_commands_concurrently(int count,
                                     char** lines,
                                     int coreCount,
                                     int mode,
                                     int allModes);

#endif
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <string.h>
#include "safe_calls_library.h"

int parse_int_strtol(const char* in, int fb){
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    long v=strtol(in,&e,10);
    if(e==in || errno==ERANGE || v<INT_MIN || v>INT_MAX) return fb;
    return (int)v;
}

long parse_long_strtol(const char* in, long fb){
    if(!in || !*in) return fb;
    errno=0;
    char* e=NULL;
    long v=strtol(in,&e,10);
    if(e==in||errno==ERANGE) return fb;
    return v;
}

float parse_float_strtof(const char* in, float fb){
    if(!in||!*in) return fb;
    errno=0;
    char* e=NULL;
    float v=strtof(in,&e);
    if(e==in||errno==ERANGE) return fb;
    return v;
}

double parse_double_strtod(const char* in, double fb){
    if(!in||!*in) return fb;
    errno=0;
    char* e=NULL;
    double v=strtod(in,&e);
    if(e==in||errno==ERANGE) return fb;
    return v;
}

int safe_pthread_create(void*(*f)(void*), void* arg){
    pthread_t t;
    int r=pthread_create(&t,NULL,f,arg);
    if(r){
        fprintf(stderr,"pthread_create fail: %s\n", strerror(r));
        return -1;
    }
    pthread_detach(t);
    return 0;
}#ifndef SAFE_CALLS_LIBRARY_H
#define SAFE_CALLS_LIBRARY_H

int    safe_pthread_create(void*(*f)(void*), void* arg);
int    parse_int_strtol(const char* input, int fallback);
long   parse_long_strtol(const char* input, long fallback);
float  parse_float_strtof(const char* input, float fallback);
double parse_double_strtod(const char* input, double fallback);

#endif
#include "scheduler.h"
#include "ready_queue.h"
#include "os.h"
#include "worker.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

/* We allow up to some max cores. */
#ifndef MAX_CORES
#define MAX_CORES 4
#endif

static scheduler_alg_t current_alg=ALG_CFS;

/* We'll maintain a global simulated_time, incremented by slices. */
static uint64_t g_sim_time=0;

/* Because we do concurrency, we need a lock to safely read/update g_sim_time. */
static pthread_mutex_t sim_time_lock = PTHREAD_MUTEX_INITIALIZER;

/* Accessor for the ready_queue to see the "now" for HRRN, etc. */
uint64_t get_global_sim_time(void){
    pthread_mutex_lock(&sim_time_lock);
    uint64_t t = g_sim_time;
    pthread_mutex_unlock(&sim_time_lock);
    return t;
}

typedef struct {
    double avg_wait;
    double avg_turnaround;
    double avg_response;
    unsigned long long preemptions;
    unsigned long long total_procs;
    uint64_t total_wait;
    int total_processes;
    uint64_t total_response;
    int total_turnaround;
} sched_stats_accum_t;

static sched_stats_accum_t gStats;
static double gAvgWait=0.0, gAvgTAT=0.0, gAvgResp=0.0;
static unsigned long long gPreemptions=0, gProcs=0;
static int HPC_over_mode=0;

/* Track whether we are done scheduling or not. If no processes remain, we end. */
static int g_running=0;
static int g_num_cores=1;

static void reset_accumulators(void){
    memset(&gStats, 0, sizeof(gStats));
    gAvgWait=0; gAvgTAT=0; gAvgResp=0;
    gPreemptions=0; gProcs=0;
    HPC_over_mode=0;
    g_sim_time=0;
}

/* Worker thread for each core => pop from ready queue, run partial or full. */
static void* scheduling_core_thread(void* arg){
    long core_id = (long)arg;
    int quantum=2; /* for RR-like partial or BFS, etc. */

    while(g_running){
        process_t* p = ready_queue_pop(); /* block until available or done */

        /* Check if we should exit because the queue was destroyed. */
        if(!g_running || !p) break;

        /* Print line for scheduling (real time for user, but we also have sim_time inside). */
        uint64_t real_t = os_time(); /* for user display only */
        printf("\033[93m[time=%llu ms] => container=1 core=%ld => scheduling processPtr=%p\n"
               "   => burst_time=%lu, prio=%d, vruntime=%llu, remain=%llu, timesScheduled=%d\033[0m\n",
               (unsigned long long)real_t,
               core_id, (void*)p,
               (unsigned long)p->burst_time,
               p->priority,
               (unsigned long long)p->vruntime,
               (unsigned long long)p->remaining_time,
               p->times_owning_core);
        usleep(300000);

        /* Mark first response time if not responded yet. */
        if(!p->responded){
            p->responded=1;
            p->first_response = get_global_sim_time();
        }
        p->times_owning_core++;

        /* Decide how many ms to run (in simulated time). */
        unsigned long slice = 0;
        int preemptive = 0;

        switch(current_alg){
        case ALG_RR:
        case ALG_BFS:
        case ALG_CFS_SRTF:
        case ALG_STRF:
        case ALG_HRRN_RT:
        case ALG_MLFQ:
            preemptive = 1; /* partial preemption possible */
            break;
        default:
            preemptive = 0; /* run entire burst with no preemption */
            break;
        }

        if(preemptive){
            if(p->remaining_time > (unsigned long)quantum){
                slice = quantum;
            } else {
                slice = p->remaining_time;
            }
        } else {
            slice = p->remaining_time;
        }

        /* Actually "run" the slice in simulated time. */
        simulate_process_partial(p, slice); /* real-time sleep for user */
        /* Then increment sim_time. */
        pthread_mutex_lock(&sim_time_lock);
        g_sim_time += slice;
        pthread_mutex_unlock(&sim_time_lock);

        /* Update stats in p. */
        p->remaining_time -= slice;
        if(current_alg==ALG_CFS_SRTF){
            p->vruntime += slice;
        }

        if(preemptive && p->remaining_time>0){
            /* we preempt => put back in queue => increment preemptions. */
            __sync_fetch_and_add(&gStats.preemptions, 1ULL);

            printf("\033[94m   => PREEMPT => processPtr=%p => new remain=%llu => preemptions=%llu\033[0m\n",
                   (void*)p,
                   (unsigned long long)p->remaining_time,
                   (unsigned long long)gStats.preemptions);
            usleep(300000);

            /* If MLFQ, we move it to next queue. */
            if(current_alg==ALG_MLFQ){
                p->mlfq_level++;
            }
            ready_queue_push(p);
        } else {
            /* finished. */
            p->end_time = get_global_sim_time();

            printf("\033[92m   => FINISH => processPtr=%p => total CPU used=%lu ms => time=%llu ms\033[0m\n",
                   (void*)p,
                   (unsigned long)slice,
                   (unsigned long long)os_time());
            usleep(300000);
        }
    }
    return NULL;
}

/* We'll store process array globally for stats finalize. */
static process_t* g_list=NULL;
static int        g_count=0;

static void finalize(void){
    if(g_count<=0 || HPC_over_mode){
        return;
    }
    /* compute wait, TAT, response for each process. */
    for(int i=0; i<g_count; i++){
        process_t* P = &g_list[i];
        uint64_t at  = P->arrival_time;
        uint64_t st  = P->first_response;
        uint64_t et  = P->end_time;
        uint64_t bt  = P->burst_time; /* for reference */

        /* Wait = (start - arrival). */
        uint64_t wait = (st > at) ? (st - at) : 0ULL;
        /* TAT = end - arrival. */
        uint64_t tat  = (et > at) ? (et - at) : 0ULL;
        /* Resp = (first_response - arrival). */
        uint64_t resp = wait; /* same as wait here. */

        gStats.total_wait       += wait;
        gStats.total_turnaround += tat;
        gStats.total_response   += resp;
    }
    unsigned long long n = gStats.total_processes;
    if(n>0){
        gAvgWait = (double)gStats.total_wait/(double)n;
        gAvgTAT  = (double)gStats.total_turnaround/(double)n;
        gAvgResp = (double)gStats.total_response/(double)n;
    }
    gPreemptions = gStats.preemptions;
    gProcs       = n;
}

void scheduler_select_algorithm(scheduler_alg_t a){
    current_alg=a;
}

void scheduler_run(process_t* list,int count){
    reset_accumulators();
    if(!list || count<=0){
        return;
    }

    /* Special HPC overshadow mode => no normal stats. */
    if(current_alg==ALG_HPC_OVERSHADOW){
        HPC_over_mode=1;
        printf("\n\033[95m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
        printf("SCHEDULE NAME => HPC-OVERSHADOW\n");
        printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
        usleep(300000);

        os_run_hpc_overshadow();

        printf("\033[96m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
        printf("SCHEDULE END => HPC-OVERSHADOW => no normal stats.\n");
        printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
        usleep(300000);
        return;
    }

    /* else normal scheduling. Print big block start. */
    printf("\n\033[95m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
    printf("SCHEDULE NAME => %d (enum)\n", current_alg);
    printf("Number of processes=%d\n", count);
    printf("Time start=%llu ms\n", (unsigned long long)os_time());
    printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
    usleep(300000);

    ready_queue_init_policy(current_alg);
    g_list = list;
    g_count= count;

    /* We default to 1 core in most tests. If you want multi-core in tests, you can set it. */
    g_num_cores = 1;
    if(current_alg==ALG_BFS){
        /* BFS is interesting with multiple cores. Let's do 2 just for demonstration. */
        g_num_cores = 2;
    }

    g_running=1;
    /* Initialize each process arrival => push to queue. */
    for(int i=0;i<count;i++){
        ready_queue_push(&list[i]);
        gStats.total_processes++;
    }

    /* Start core threads. */
    pthread_t tid[MAX_CORES];
    int n = (g_num_cores>MAX_CORES?MAX_CORES:g_num_cores);
    for(int i=0;i<n;i++){
        pthread_create(&tid[i],NULL,scheduling_core_thread,(void*)(long)i);
    }

    /* Wait until queue empties => we watch size periodically. */
    while( ready_queue_size()>0 ){
        usleep(200000);
    }
    /* Then stop the scheduling threads. */
    g_running=0;
    /* So they unblock from pop => we do cond_signal multiple times. */
    for(int k=0;k<n;k++){
        /* push a dummy? or just signal broadcast. */
        ready_queue_push(NULL);
    }
    for(int i=0;i<n;i++){
        pthread_join(tid[i],NULL);
    }

    ready_queue_destroy();
    finalize();

    /* End ASCII block. */
    uint64_t total_time = get_global_sim_time();
    printf("\033[96m$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");
    printf("SCHEDULE END => alg=%d => totalTime=%llums\n", current_alg,
           (unsigned long long)total_time);
    printf("Stats: preemptions=%llu, totalProcs=%llu\n",
           (unsigned long long)gPreemptions,
           (unsigned long long)gProcs);
    printf("AvgWait=%.2f, AvgTAT=%.2f, AvgResp=%.2f\n",
           gAvgWait, gAvgTAT, gAvgResp);
    printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\033[0m\n");
    usleep(300000);

    /* Cleanup references. */
    g_list=NULL;
    g_count=0;
}

void scheduler_fetch_report(sched_report_t* out){
    if(!out) return;
    if(HPC_over_mode){
        out->avg_wait=0.0;
        out->avg_turnaround=0.0;
        out->avg_response=0.0;
        out->preemptions=0ULL;
        out->total_procs=0ULL;
    } else {
        out->avg_wait       = gAvgWait;
        out->avg_turnaround = gAvgTAT;
        out->avg_response   = gAvgResp;
        out->preemptions    = gPreemptions;
        out->total_procs    = gProcs;
    }
}
#ifndef SCHEDULER_H
#define SCHEDULER_H

#include "process.h"

#ifdef __cplusplus
extern "C" {
#endif

    /*
      List of supported algorithms.
    */
    typedef enum {
        ALG_CFS,
        ALG_CFS_SRTF,
        ALG_FIFO,
        ALG_RR,
        ALG_SJF,
        ALG_STRF,
        ALG_HRRN,
        ALG_HRRN_RT,
        ALG_BFS,
        ALG_PRIORITY,
        ALG_HPC_OVERSHADOW,
        ALG_MLFQ
    } scheduler_alg_t;

    typedef struct {
        double avg_wait;
        double avg_turnaround;
        double avg_response;
        unsigned long long preemptions;
        unsigned long long total_procs;
    } sched_report_t;

    /* global accessors. */
    void scheduler_select_algorithm(scheduler_alg_t a);
    void scheduler_run(process_t* list, int count);
    void scheduler_fetch_report(sched_report_t* out);

    /* Called by ready_queue so it can do HRRN ratio. */
    uint64_t get_global_sim_time(void);

#ifdef __cplusplus
}
#endif

#endif
#include "scoreboard.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>

int unlocked_basic=1;
int unlocked_normal=0;
int unlocked_external=0;
int unlocked_modes=0;
int unlocked_edge=0;
int unlocked_hidden=0;

static scoreboard_t gSB={
    0,0,0,0,0,0, /* test totals & passes */
    0,0,0,0,0,0, /* scheduling mastery flags */
    0.0,0.0,0.0,0.0,0.0,0.0, /* percentages for each test category */
    60.0 /* pass_threshold */
};

static void update_unlocks(void){
    gSB.basic_percent=(gSB.basic_total>0)?
        ((gSB.basic_pass*100.0)/gSB.basic_total):0.0;
    gSB.normal_percent=(gSB.normal_total>0)?
        ((gSB.normal_pass*100.0)/gSB.normal_total):0.0;
    gSB.external_percent=(gSB.external_total>0)?
        ((gSB.external_pass*100.0)/gSB.external_total):0.0;
    gSB.modes_percent=(gSB.modes_total>0)?
        ((gSB.modes_pass*100.0)/gSB.modes_total):0.0;
    gSB.edge_percent=(gSB.edge_total>0)?
        ((gSB.edge_pass*100.0)/gSB.edge_total):0.0;
    gSB.hidden_percent=(gSB.hidden_total>0)?
        ((gSB.hidden_pass*100.0)/gSB.hidden_total):0.0;

    double T=gSB.pass_threshold;
    if(gSB.basic_percent>=T){
        unlocked_normal=1;
        unlocked_external=1;
    }
    if(gSB.normal_percent>=T){
        unlocked_modes=1;
    }
    if(gSB.modes_percent>=T){
        unlocked_edge=1;
    }
    if(gSB.edge_percent>=T){
        unlocked_hidden=1;
    }
}

/* read entire file. */
static char* read_file_all(const char* path){
    FILE* f=fopen(path,"rb");
    if(!f) return NULL;
    fseek(f,0,SEEK_END);
    long size=ftell(f);
    if(size<0){fclose(f);return NULL;}
    fseek(f,0,SEEK_SET);
    char* buf=(char*)malloc(size+1);
    if(!buf){fclose(f);return NULL;}
    if(fread(buf,1,size,f)!=(size_t)size){
        fclose(f); free(buf); return NULL;
    }
    buf[size]='\0';
    fclose(f);
    return buf;
}

static int parse_json_int(const char* json,const char* key,int def){
    if(!json||!key) return def;
    char pattern[128];
    snprintf(pattern,sizeof(pattern),"\"%s\"",key);
    char* found=strstr(json,pattern);
    if(!found) return def;
    char* colon=strstr(found,":");
    if(!colon) return def;
    colon++;
    while(*colon && (*colon==' '||*colon=='\t')) colon++;
    int val=def;
    sscanf(colon,"%d",&val);
    return val;
}

static double parse_json_double(const char* json,const char* key,double def){
    if(!json||!key) return def;
    char pattern[128];
    snprintf(pattern,sizeof(pattern),"\"%s\"",key);
    char* found=strstr(json,pattern);
    if(!found) return def;
    char* colon=strstr(found,":");
    if(!colon) return def;
    colon++;
    while(*colon && (*colon==' '||*colon=='\t')) colon++;
    double val=def;
    sscanf(colon,"%lf",&val);
    return val;
}

/* Save scoreboard to scoreboard.json. */
static void write_scoreboard_json(const scoreboard_t* sb){
    FILE* f=fopen("scoreboard.json","w");
    if(!f) return;
    fprintf(f,"{\n");
    fprintf(f,"  \"basic_total\": %d,\n",   sb->basic_total);
    fprintf(f,"  \"basic_pass\": %d,\n",    sb->basic_pass);
    fprintf(f,"  \"normal_total\": %d,\n",  sb->normal_total);
    fprintf(f,"  \"normal_pass\": %d,\n",   sb->normal_pass);
    fprintf(f,"  \"external_total\": %d,\n",sb->external_total);
    fprintf(f,"  \"external_pass\": %d,\n", sb->external_pass);
    fprintf(f,"  \"modes_total\": %d,\n",   sb->modes_total);
    fprintf(f,"  \"modes_pass\": %d,\n",    sb->modes_pass);
    fprintf(f,"  \"edge_total\": %d,\n",    sb->edge_total);
    fprintf(f,"  \"edge_pass\": %d,\n",     sb->edge_pass);
    fprintf(f,"  \"hidden_total\": %d,\n",  sb->hidden_total);
    fprintf(f,"  \"hidden_pass\": %d,\n",   sb->hidden_pass);

    fprintf(f,"  \"sc_fifo\": %d,\n",       sb->sc_fifo);
    fprintf(f,"  \"sc_rr\": %d,\n",         sb->sc_rr);
    fprintf(f,"  \"sc_cfs\": %d,\n",        sb->sc_cfs);
    fprintf(f,"  \"sc_cfs_srtf\": %d,\n",   sb->sc_cfs_srtf);
    fprintf(f,"  \"sc_bfs\": %d,\n",        sb->sc_bfs);
    fprintf(f,"  \"sc_sjf\": %d,\n",        sb->sc_sjf);
    fprintf(f,"  \"sc_strf\": %d,\n",       sb->sc_strf);
    fprintf(f,"  \"sc_hrrn\": %d,\n",       sb->sc_hrrn);
    fprintf(f,"  \"sc_hrrn_rt\": %d,\n",    sb->sc_hrrn_rt);
    fprintf(f,"  \"sc_priority\": %d,\n",   sb->sc_priority);
    fprintf(f,"  \"sc_hpc_over\": %d,\n",   sb->sc_hpc_over);
    fprintf(f,"  \"sc_mlfq\": %d,\n",       sb->sc_mlfq);

    fprintf(f,"  \"basic_percent\": %.3f,\n",    sb->basic_percent);
    fprintf(f,"  \"normal_percent\": %.3f,\n",   sb->normal_percent);
    fprintf(f,"  \"external_percent\": %.3f,\n", sb->external_percent);
    fprintf(f,"  \"modes_percent\": %.3f,\n",    sb->modes_percent);
    fprintf(f,"  \"edge_percent\": %.3f,\n",     sb->edge_percent);
    fprintf(f,"  \"hidden_percent\": %.3f,\n",   sb->hidden_percent);

    fprintf(f,"  \"pass_threshold\": %.1f\n",     sb->pass_threshold);
    fprintf(f,"}\n");
    fclose(f);
}

void scoreboard_init(void){ }
void scoreboard_close(void){ }

void scoreboard_load(void){
    char* json=read_file_all("scoreboard.json");
    if(!json){
        update_unlocks();
        return;
    }
    gSB.basic_total    = parse_json_int(json,"basic_total",    gSB.basic_total);
    gSB.basic_pass     = parse_json_int(json,"basic_pass",     gSB.basic_pass);
    gSB.normal_total   = parse_json_int(json,"normal_total",   gSB.normal_total);
    gSB.normal_pass    = parse_json_int(json,"normal_pass",    gSB.normal_pass);
    gSB.external_total = parse_json_int(json,"external_total", gSB.external_total);
    gSB.external_pass  = parse_json_int(json,"external_pass",  gSB.external_pass);
    gSB.modes_total    = parse_json_int(json,"modes_total",    gSB.modes_total);
    gSB.modes_pass     = parse_json_int(json,"modes_pass",     gSB.modes_pass);
    gSB.edge_total     = parse_json_int(json,"edge_total",     gSB.edge_total);
    gSB.edge_pass      = parse_json_int(json,"edge_pass",      gSB.edge_pass);
    gSB.hidden_total   = parse_json_int(json,"hidden_total",   gSB.hidden_total);
    gSB.hidden_pass    = parse_json_int(json,"hidden_pass",    gSB.hidden_pass);

    gSB.sc_fifo        = parse_json_int(json,"sc_fifo",        gSB.sc_fifo);
    gSB.sc_rr          = parse_json_int(json,"sc_rr",          gSB.sc_rr);
    gSB.sc_cfs         = parse_json_int(json,"sc_cfs",         gSB.sc_cfs);
    gSB.sc_cfs_srtf    = parse_json_int(json,"sc_cfs_srtf",    gSB.sc_cfs_srtf);
    gSB.sc_bfs         = parse_json_int(json,"sc_bfs",         gSB.sc_bfs);
    gSB.sc_sjf         = parse_json_int(json,"sc_sjf",         gSB.sc_sjf);
    gSB.sc_strf        = parse_json_int(json,"sc_strf",        gSB.sc_strf);
    gSB.sc_hrrn        = parse_json_int(json,"sc_hrrn",        gSB.sc_hrrn);
    gSB.sc_hrrn_rt     = parse_json_int(json,"sc_hrrn_rt",     gSB.sc_hrrn_rt);
    gSB.sc_priority    = parse_json_int(json,"sc_priority",    gSB.sc_priority);
    gSB.sc_hpc_over    = parse_json_int(json,"sc_hpc_over",    gSB.sc_hpc_over);
    gSB.sc_mlfq        = parse_json_int(json,"sc_mlfq",        gSB.sc_mlfq);

    gSB.basic_percent   = parse_json_double(json,"basic_percent",    gSB.basic_percent);
    gSB.normal_percent  = parse_json_double(json,"normal_percent",   gSB.normal_percent);
    gSB.external_percent= parse_json_double(json,"external_percent", gSB.external_percent);
    gSB.modes_percent   = parse_json_double(json,"modes_percent",    gSB.modes_percent);
    gSB.edge_percent    = parse_json_double(json,"edge_percent",     gSB.edge_percent);
    gSB.hidden_percent  = parse_json_double(json,"hidden_percent",   gSB.hidden_percent);
    gSB.pass_threshold  = parse_json_double(json,"pass_threshold",   gSB.pass_threshold);

    free(json);
    update_unlocks();
}

void scoreboard_save(void){
    update_unlocks();
    write_scoreboard_json(&gSB);
}

static int get_scheduler_points(void){
    /* BFS=2, HPC=2, MLFQ=2, others=1 => up to 15 total */
    int points=0;
    if(gSB.sc_fifo)      points+=1;
    if(gSB.sc_rr)        points+=1;
    if(gSB.sc_cfs)       points+=1;
    if(gSB.sc_cfs_srtf)  points+=1;
    if(gSB.sc_bfs)       points+=2;
    if(gSB.sc_sjf)       points+=1;
    if(gSB.sc_strf)      points+=1;
    if(gSB.sc_hrrn)      points+=1;
    if(gSB.sc_hrrn_rt)   points+=1;
    if(gSB.sc_priority)  points+=1;
    if(gSB.sc_hpc_over)  points+=2;
    if(gSB.sc_mlfq)      points+=2;
    return points;
}

int scoreboard_get_final_score(void){
    update_unlocks();
    double b = gSB.basic_percent     * 0.32;
    double n = gSB.normal_percent    * 0.20;
    double e = gSB.external_percent  * 0.10;
    double m = gSB.modes_percent     * 0.10;
    double ed= gSB.edge_percent      * 0.10;
    double h = gSB.hidden_percent    * 0.08;

    int sched_points = get_scheduler_points();
    double sched_percent = (sched_points / 15.0)*100.0;
    double s = sched_percent * 0.10; /* 10% block for scheduling */

    double total = b + n + e + m + ed + h + s;
    if(total>100.0) total=100.0;
    if(total<0.0)   total=0.0;
    return (int)(total + 0.5);
}

void scoreboard_clear(void){
    memset(&gSB, 0, sizeof(gSB));
    gSB.pass_threshold=60.0;
    unlocked_basic=1;
    unlocked_normal=0;
    unlocked_external=0;
    unlocked_modes=0;
    unlocked_edge=0;
    unlocked_hidden=0;
    scoreboard_save();
}

void get_scoreboard(scoreboard_t* out){
    if(out) *out=gSB;
}

void scoreboard_set_sc_mastered(scheduler_alg_t alg){
    switch(alg){
    case ALG_FIFO:          gSB.sc_fifo=1;        break;
    case ALG_RR:            gSB.sc_rr=1;          break;
    case ALG_CFS:           gSB.sc_cfs=1;         break;
    case ALG_CFS_SRTF:      gSB.sc_cfs_srtf=1;    break;
    case ALG_BFS:           gSB.sc_bfs=1;         break;
    case ALG_SJF:           gSB.sc_sjf=1;         break;
    case ALG_STRF:          gSB.sc_strf=1;        break;
    case ALG_HRRN:          gSB.sc_hrrn=1;        break;
    case ALG_HRRN_RT:       gSB.sc_hrrn_rt=1;     break;
    case ALG_PRIORITY:      gSB.sc_priority=1;    break;
    case ALG_HPC_OVERSHADOW:gSB.sc_hpc_over=1;    break;
    case ALG_MLFQ:          gSB.sc_mlfq=1;        break;
    default: break;
    }
}

void scoreboard_update_basic(int total,int pass){
    gSB.basic_total += total;
    gSB.basic_pass  += pass;
}
void scoreboard_update_normal(int total,int pass){
    gSB.normal_total += total;
    gSB.normal_pass  += pass;
}
void scoreboard_update_external(int total,int pass){
    gSB.external_total += total;
    gSB.external_pass  += pass;
}
void scoreboard_update_modes(int total,int pass){
    gSB.modes_total += total;
    gSB.modes_pass  += pass;
}
void scoreboard_update_edge(int total,int pass){
    gSB.edge_total += total;
    gSB.edge_pass  += pass;
}
void scoreboard_update_hidden(int total,int pass){
    gSB.hidden_total += total;
    gSB.hidden_pass  += pass;
}
#ifndef SCOREBOARD_H
#define SCOREBOARD_H

#include "scheduler.h"

typedef struct {
    int basic_total,    basic_pass;
    int normal_total,   normal_pass;
    int external_total, external_pass;
    int modes_total,    modes_pass;
    int edge_total,     edge_pass;
    int hidden_total,   hidden_pass;

    int sc_fifo, sc_rr, sc_cfs, sc_cfs_srtf, sc_bfs;
    int sc_sjf, sc_strf, sc_hrrn, sc_hrrn_rt;
    int sc_priority, sc_hpc_over, sc_mlfq;

    double basic_percent;
    double normal_percent;
    double external_percent;
    double modes_percent;
    double edge_percent;
    double hidden_percent;

    double pass_threshold;
} scoreboard_t;

extern int unlocked_basic;
extern int unlocked_normal;
extern int unlocked_external;
extern int unlocked_modes;
extern int unlocked_edge;
extern int unlocked_hidden;

void scoreboard_init(void);
void scoreboard_close(void);
void scoreboard_load(void);
void scoreboard_save(void);
void scoreboard_clear(void);
void get_scoreboard(scoreboard_t* out);
int  scoreboard_get_final_score(void);

void scoreboard_set_sc_mastered(scheduler_alg_t alg);

void scoreboard_update_basic(int total,int pass);
void scoreboard_update_normal(int total,int pass);
void scoreboard_update_external(int total,int pass);
void scoreboard_update_modes(int total,int pass);
void scoreboard_update_edge(int total,int pass);
void scoreboard_update_hidden(int total,int pass);

#endif
#include "worker.h"
#include <stdio.h>
#include <unistd.h>

/* The original full-run is rarely used, but let's keep it. */
void simulate_process(process_t* p){
    if(!p) return;
    printf("[Worker] Full run => priority=%d, burst=%lu ms\n",
           p->priority,(unsigned long)p->burst_time);
    /* We do real-time sleep just for user experience. */
    usleep(p->burst_time * 1000U);
}

/*
  simulate_process_partial(p, slice):
   - Sleep for 'slice' ms in real time, purely for demonstration.
*/
void simulate_process_partial(process_t* p, unsigned long slice_ms){
    if(!p || !slice_ms) return;
    printf("[Worker] Partial => priority=%d, slice=%lu ms\n",
           p->priority, slice_ms);
    usleep(slice_ms * 1000U);
}
#ifndef WORKER_H
#define WORKER_H

#include "process.h"

/*
  Functions that "simulate" the process running, using usleep to show
  the user some concurrency. Stats are updated in the scheduler's sim_time domain.
*/
void simulate_process(process_t* p);
void simulate_process_partial(process_t* p, unsigned long slice_ms);

#endif
#include "basic-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;

static int almost_equal(double a, double b, double eps){
    return fabs(a - b) < eps;
}
static bool check_stats(const sched_report_t* rep,
                        double exp_wait, double exp_tat,
                        double exp_resp, unsigned long long exp_preempt,
                        double eps)
{
    if(!almost_equal(rep->avg_wait,       exp_wait, eps)) return false;
    if(!almost_equal(rep->avg_turnaround, exp_tat,  eps)) return false;
    if(!almost_equal(rep->avg_response,   exp_resp, eps)) return false;
    if(rep->preemptions != exp_preempt)                  return false;
    return true;
}

extern char g_test_fail_reason[256];

/* FIFO test => 2 procs => p0=3, p1=5 => arrival=0 =>
   wait p0=0,tat=3 => p1=3,8 => avg wait=1.5, tat=5.5 => resp=1.5 => preempt=0 */
static bool test_fifo_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 1, 0);
    init_process(&p[1], 5, 1, 0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    return check_stats(&rep, 1.5, 5.5, 1.5, 0ULL, 0.001);
}
TEST(test_fifo){
    if(!test_fifo_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_fifo => FIFO stats mismatch (expected W=1.5,T=5.5,R=1.5,pre=0)");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_FIFO);
    return true;
}

/* RR => p0=2, p1=2 => quantum=2 => each runs once =>
   p0 wait=0, tat=2 => p1 wait=2, tat=4 =>
   avg wait=1, tat=3 => resp=0 for p0, 2 for p1 => average=1 => preempt=0 (since each finishes in its timeslice).
*/
static bool test_rr_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 2, 1, 0);
    init_process(&p[1], 2, 1, 0);

    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* We expect wait=1, tat=3, resp=1, preempt=0. */
    return check_stats(&rep, 1.0, 3.0, 1.0, 0ULL, 0.001);
}
TEST(test_rr){
    if(!test_rr_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_rr => RR stats mismatch (expected W=1,T=3,R=1,pre=0)");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_RR);
    return true;
}

/* CFS => 2 procs => p0=3, p1=4 => no preemption =>
   p0 wait=0,tat=3 => p1 wait=3,tat=7 =>
   avg wait=1.5, tat=5.0, resp=1.5 => preempt=0 */
static bool test_cfs_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 0, 0);
    init_process(&p[1], 4, 0, 0);

    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    return check_stats(&rep, 1.5, 5.0, 1.5, 0ULL, 0.001);
}
TEST(test_cfs){
    if(!test_cfs_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_cfs => mismatch (expected W=1.5,T=5.0,R=1.5,pre=0)");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS);
    return true;
}

/* BFS => 3 procs => partial => quantum=2 => we expect preempt>0, total_procs=3.
   We won't do exact wait/tat check, just a minimal assertion. */
static bool test_bfs_impl(void){
    os_init();
    process_t p[3];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    init_process(&p[2],4,1,0);

    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=3) return false;
    if(rep.preemptions<1)  return false;
    return true;
}
TEST(test_bfs){
    if(!test_bfs_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_bfs => BFS mismatch => expected preempt>0, procs=3");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_BFS);
    return true;
}

/* pipeline => no scheduling => pass if no crash. */
static bool test_pipeline_impl(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}
TEST(test_pipeline){
    if(!test_pipeline_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_pipeline => unexpected fail");
        return false;
    }
    return true;
}

/* distributed => pass if no crash. */
static bool test_distributed_impl(void){
    os_init();
    os_run_distributed_example();
    os_cleanup();
    return true;
}
TEST(test_distributed){
    if(!test_distributed_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_distributed => unexpected fail");
        return false;
    }
    return true;
}

/* FIFO strict => 2 procs => p0=3, p1=4 => same as above => W=1.5, T=5.0, R=1.5, pre=0. */
static bool test_fifo_strict_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],3,10,0);
    init_process(&p[1],4,20,0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    return check_stats(&rep, 1.5, 5.0, 1.5, 0ULL, 0.001);
}
TEST(test_fifo_strict){
    if(!test_fifo_strict_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_fifo_strict => mismatch => W=1.5,T=5.0,R=1.5,pre=0");
        return false;
    }
    return true;
}

void run_basic_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_fifo);
    RUN_TEST(test_rr);
    RUN_TEST(test_cfs);
    RUN_TEST(test_bfs);
    RUN_TEST(test_pipeline);
    RUN_TEST(test_distributed);
    RUN_TEST(test_fifo_strict);

    *total = tests_run;
    *passed= tests_run - tests_failed;
}
/* basic-test.h */
#ifndef BASIC_TEST_H
#define BASIC_TEST_H
void run_basic_tests(int* total,int* passed);
#endif
#include "edge-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;
extern char g_test_fail_reason[256];

static bool test_extreme_long_impl(void){
    os_init();
    process_t p[1];
    init_process(&p[0], 50, 2, 0);

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* single proc => wait=0, tat=50, resp=0, pre=0 */
    if(rep.total_procs!=1) return false;
    if(rep.preemptions!=0) return false;
    if(fabs(rep.avg_wait - 0.0)>0.001) return false;
    if(fabs(rep.avg_turnaround - 50.0)>0.1) return false;
    if(fabs(rep.avg_response - 0.0)>0.001) return false;
    return true;
}
TEST(test_extreme_long){
    if(!test_extreme_long_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_extreme_long => mismatch => expected wait=0, tat=50, resp=0");
        return false;
    }
    return true;
}

static bool test_extreme_short_impl(void){
    os_init();
    process_t p[1];
    init_process(&p[0],1,2,0);

    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    /* single => wait=0, tat=1, resp=0 => pre=0 */
    if(rep.total_procs!=1) return false;
    if(rep.preemptions!=0) return false;
    if(fabs(rep.avg_wait - 0.0)>0.001) return false;
    if(fabs(rep.avg_turnaround -1.0)>0.001) return false;
    return true;
}
TEST(test_extreme_short){
    if(!test_extreme_short_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_extreme_short => mismatch => expected wait=0, tat=1, resp=0");
        return false;
    }
    return true;
}

static bool test_high_load_impl(void){
    os_init();
    process_t arr[10];
    for(int i=0;i<10;i++){
        init_process(&arr[i], 3+(i%3), 1, 0);
    }
    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(arr,10);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=10) return false;
    return true;
}
TEST(test_high_load){
    if(!test_high_load_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_high_load => mismatch => expected total_procs=10");
        return false;
    }
    return true;
}

static bool test_hpc_under_load_impl(void){
    os_init();
    os_run_hpc_overshadow();
    os_cleanup();
    return true;
}
TEST(test_hpc_under_load){
    if(!test_hpc_under_load_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_hpc_under_load => fail ???");
        return false;
    }
    return true;
}

static bool test_container_spam_impl(void){
    os_init();
    for(int i=0;i<3;i++){
        os_create_ephemeral_container();
    }
    for(int i=0;i<3;i++){
        os_remove_ephemeral_container();
    }
    os_cleanup();
    return true;
}
TEST(test_container_spam){
    if(!test_container_spam_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_container_spam => fail ???");
        return false;
    }
    return true;
}

static bool test_pipeline_edge_impl(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}
TEST(test_pipeline_edge){
    if(!test_pipeline_edge_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_pipeline_edge => fail ???");
        return false;
    }
    return true;
}

static bool test_multi_distrib_impl(void){
    os_init();
    for(int i=0;i<3;i++){
        os_run_distributed_example();
    }
    os_cleanup();
    return true;
}
TEST(test_multi_distrib){
    if(!test_multi_distrib_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_multi_distrib => fail ???");
        return false;
    }
    return true;
}

void run_edge_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_extreme_long);
    RUN_TEST(test_extreme_short);
    RUN_TEST(test_high_load);
    RUN_TEST(test_hpc_under_load);
    RUN_TEST(test_container_spam);
    RUN_TEST(test_pipeline_edge);
    RUN_TEST(test_multi_distrib);

    *total=tests_run;
    *passed=tests_run - tests_failed;
}
#ifndef EDGE_TEST_H
#define EDGE_TEST_H

/*
  run_edge_tests():
    Various edge cases: extreme long/short bursts, HPC under load,
    container spam, pipeline edge, multi-distributed runs, etc.
*/
void run_edge_tests(int* total,int* passed);

#endif
#include "external-test.h"
#include "test_common.h"
#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/scoreboard.h"
#include "../src/runner.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static int tests_run=0;
static int tests_failed=0;
extern char g_test_fail_reason[256];

/* HPC overshadow => expect 0 stats. */
bool test_external_hpc(void)
{
    os_init();
    process_t dummy[1];
    init_process(&dummy[0], 0, 0, 0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=0){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_external_hpc => expected total_procs=0, got %llu",
                 (unsigned long long)rep.total_procs);
        return false;
    }
    return true;
}

/* BFS => partial => expect at least 1 preemption for 2 short procs. */
bool test_external_bfs(void)
{
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=2 || rep.preemptions<1){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_external_bfs => mismatch => procs=%llu, preempt=%llu",
                 (unsigned long long)rep.total_procs,
                 (unsigned long long)rep.preemptions);
        return false;
    }
    return true;
}

/* run shell concurrency => pass if no crash */
bool test_run_shell_concurrency(void)
{
    int count=2;
    char* lines[2];
    lines[0] = "sleep 2";
    lines[1] = "sleep 3";

    /* single core, FIFO mode */
    run_shell_commands_concurrently(count, lines, 1, ALG_FIFO, 0);
    return true;
}

void run_external_tests(void)
{
    printf("[External] => Starting external tests.\n");
    {
        tests_run++;
        bool ok=test_external_hpc();
        if(!ok){
            tests_failed++;
            printf("  FAIL: test_external_hpc => %s\n", g_test_fail_reason);
        } else {
            printf("  PASS: test_external_hpc\n");
        }
    }

    {
        tests_run++;
        bool ok=test_external_bfs();
        if(!ok){
            tests_failed++;
            printf("  FAIL: test_external_bfs => %s\n", g_test_fail_reason);
        } else {
            printf("  PASS: test_external_bfs\n");
        }
    }

    {
        tests_run++;
        bool ok=test_run_shell_concurrency();
        if(!ok){
            tests_failed++;
            printf("  FAIL: test_run_shell_concurrency => %s\n", g_test_fail_reason);
        } else {
            printf("  PASS: test_run_shell_concurrency\n");
        }
    }

    scoreboard_update_external(tests_run, tests_run - tests_failed);
    scoreboard_save();
    printf("[External] => %d total, %d passed.\n", tests_run, (tests_run - tests_failed));
}
#ifndef EXTERNAL_TEST_H
#define EXTERNAL_TEST_H

#include <stdbool.h>

bool test_external_hpc(void);
bool test_external_bfs(void);
bool test_run_shell_concurrency(void);

void run_external_tests(void);

#endif
#include "hidden-test.h"
#include "test_common.h"
#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;
extern char g_test_fail_reason[256];

/* distribute heavily => no scheduling => pass if no crash */
static bool test_distrib_heavy_impl(void){
    os_init();
    for(int i=0;i<4;i++){
        os_run_distributed_example();
    }
    os_cleanup();
    return true;
}
TEST(test_distrib_heavy){
    if(!test_distrib_heavy_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_distrib_heavy => fail ???");
        return false;
    }
    return true;
}

/* HPC overshadow heavy => multiple times => stats=0 each time */
static bool test_hpc_heavy_impl(void){
    os_init();
    process_t dummy[1];
    init_process(&dummy[0],0,0,0);

    for(int i=0;i<2;i++){
        scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
        scheduler_run(dummy,1);
        sched_report_t rep;
        scheduler_fetch_report(&rep);
        if(rep.total_procs!=0) {
            os_cleanup();
            return false;
        }
    }
    os_cleanup();
    return true;
}
TEST(test_hpc_heavy){
    if(!test_hpc_heavy_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_hpc_heavy => overshadow => expected total_procs=0");
        return false;
    }
    return true;
}

/* container + HPC overshadow => pass if no crash */
static bool test_container_combo_impl(void){
    os_init();
    os_create_ephemeral_container();
    os_run_distributed_example();
    os_run_hpc_overshadow();
    os_remove_ephemeral_container();
    os_cleanup();
    return true;
}
TEST(test_container_combo){
    if(!test_container_combo_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_container_combo => fail ???");
        return false;
    }
    return true;
}

/* scheduling variety => run SJF then Priority => partial checks */
static bool test_scheduling_variety_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,0);
    init_process(&p[1],6,2,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs!=2 || r1.preemptions!=0){
        os_cleanup();
        return false;
    }

    init_process(&p[0],2,3,0);
    init_process(&p[1],6,1,0);
    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,2);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    os_cleanup();

    if(r2.total_procs!=2 || r2.preemptions!=0) return false;
    return true;
}
TEST(test_scheduling_variety){
    if(!test_scheduling_variety_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_scheduling_variety => mismatch => expected total=2, pre=0 in both runs.");
        return false;
    }
    return true;
}

/* auto logic => just pass */
static bool test_auto_logic_impl(void){
    printf("Auto mode selection tested.\n");
    return true;
}
TEST(test_auto_logic){
    if(!test_auto_logic_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_auto_logic => ???");
        return false;
    }
    return true;
}

/* final synergy => HPC + container + pipeline + distributed => pass if no crash */
static bool test_final_integration_impl(void){
    os_init();
    os_log("Final synergy HPC + container + pipeline + distributed");
    os_create_ephemeral_container();
    os_run_hpc_overshadow();
    os_run_distributed_example();
    os_pipeline_example();
    os_remove_ephemeral_container();
    os_cleanup();
    return true;
}
TEST(test_final_integration){
    if(!test_final_integration_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_final_integration => fail ???");
        return false;
    }
    return true;
}

/* multi-stage => distributed + HPC overshadow => overshadow stats=0 each time */
static bool test_multi_stage_distrib_impl(void){
    os_init();

    os_run_distributed_example();
    process_t dummy[1];
    init_process(&dummy[0],0,0,0);
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs!=0){
        os_cleanup();
        return false;
    }

    os_run_distributed_example();
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    os_cleanup();

    if(r2.total_procs!=0) return false;
    return true;
}
TEST(test_multi_stage_distributed){
    if(!test_multi_stage_distrib_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_multi_stage_distrib => overshadow => expected total_procs=0");
        return false;
    }
    return true;
}

void run_hidden_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_distrib_heavy);
    RUN_TEST(test_hpc_heavy);
    RUN_TEST(test_container_combo);
    RUN_TEST(test_scheduling_variety);
    RUN_TEST(test_auto_logic);
    RUN_TEST(test_final_integration);
    RUN_TEST(test_multi_stage_distributed);

    *total=tests_run;
    *passed=tests_run - tests_failed;
}
#ifndef HIDDEN_TEST_H
#define HIDDEN_TEST_H

/*
  run_hidden_tests():
    Additional hidden or advanced synergy tests.
*/
void run_hidden_tests(int* total,int* passed);

#endif
#include "modes-test.h"
#include "test_common.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;
extern char g_test_fail_reason[256];

static bool test_hpc_over_impl(void){
    os_init();
    process_t dummy[1];
    init_process(&dummy[0],0,0,0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=0) return false;
    if(rep.preemptions!=0) return false;
    if(rep.avg_wait!=0.0) return false;
    return true;
}
TEST(test_hpc_over){
    if(!test_hpc_over_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_hpc_over => HPC overshadow => expected 0 stats");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HPC_OVERSHADOW);
    return true;
}

static bool test_multi_containers_impl(void){
    os_init();
    for(int i=0;i<2;i++) os_create_ephemeral_container();
    for(int i=0;i<2;i++) os_remove_ephemeral_container();
    os_cleanup();
    return true;
}
TEST(test_multi_containers){
    if(!test_multi_containers_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_multi_containers => fail ???");
        return false;
    }
    return true;
}

static bool test_multi_distrib_impl(void){
    os_init();
    os_run_distributed_example();
    os_run_distributed_example();
    os_cleanup();
    return true;
}
TEST(test_multi_distrib){
    if(!test_multi_distrib_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_multi_distrib => fail ???");
        return false;
    }
    return true;
}

static bool test_pipeline_modes_impl(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
    return true;
}
TEST(test_pipeline_modes){
    if(!test_pipeline_modes_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_pipeline_modes => fail ???");
        return false;
    }
    return true;
}

static bool test_mix_algos_impl(void){
    os_init();
    /* first FIFO => 2 procs => no preempt => total=2, preempt=0 */
    process_t p[2];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs!=2 || r1.preemptions!=0){
        os_cleanup();
        return false;
    }

    /* BFS => reinit => partial => expect preempt>0. */
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,2);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    os_cleanup();

    if(r2.total_procs!=2 || r2.preemptions<1) return false;
    return true;
}
TEST(test_mix_algos){
    if(!test_mix_algos_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_mix_algos => mismatch in FIFO or BFS portion");
        return false;
    }
    return true;
}

static bool test_double_hpc_impl(void){
    os_init();
    process_t dummy[1];
    init_process(&dummy[0],0,0,0);

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r1;
    scheduler_fetch_report(&r1);
    if(r1.total_procs!=0) {os_cleanup();return false;}

    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    scheduler_run(dummy,1);
    sched_report_t r2;
    scheduler_fetch_report(&r2);
    os_cleanup();

    if(r2.total_procs!=0) return false;
    return true;
}
TEST(test_double_hpc){
    if(!test_double_hpc_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_double_hpc => overshadow => expected 0 stats each time");
        return false;
    }
    return true;
}

static bool test_mlfq_check_impl(void){
    os_init();
    process_t p[3];
    init_process(&p[0],2,10,0);
    init_process(&p[1],3,20,0);
    init_process(&p[2],4,30,0);

    scheduler_select_algorithm(ALG_MLFQ);
    scheduler_run(p,3);

    sched_report_t r;
    scheduler_fetch_report(&r);
    os_cleanup();

    /* we just check total=3, preempt>0 */
    if(r.total_procs!=3) return false;
    if(r.preemptions<1)  return false;
    scoreboard_set_sc_mastered(ALG_MLFQ);
    return true;
}
TEST(test_mlfq_check){
    if(!test_mlfq_check_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_mlfq_check => mismatch => expected total=3, preempt>0");
        return false;
    }
    return true;
}

void run_modes_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_hpc_over);
    RUN_TEST(test_multi_containers);
    RUN_TEST(test_multi_distrib);
    RUN_TEST(test_pipeline_modes);
    RUN_TEST(test_mix_algos);
    RUN_TEST(test_double_hpc);
    RUN_TEST(test_mlfq_check);

    *total=tests_run;
    *passed=tests_run - tests_failed;
}
#ifndef MODES_TEST_H
#define MODES_TEST_H

/*
  run_modes_tests():
    Tests HPC overshadow, multi containers, BFS, MLFQ, and previous.
*/
void run_modes_tests(int* total,int* passed);

#endif
#include "normal-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

static int tests_run=0, tests_failed=0;
extern char g_test_fail_reason[256];

static int almost_equal(double a,double b,double eps){
    return fabs(a-b)<eps;
}
static bool check_stats(const sched_report_t* r,
                        double w, double t, double resp,
                        unsigned long long pre,
                        double eps)
{
    if(!almost_equal(r->avg_wait, w, eps)) return false;
    if(!almost_equal(r->avg_turnaround, t, eps)) return false;
    if(!almost_equal(r->avg_response, resp, eps)) return false;
    if(r->preemptions != pre) return false;
    return true;
}

/* SJF => 3 procs => p0=1, p1=5, p2=2 =>
   order => p0->p2->p1 =>
   p0: wait=0, tat=1,
   p2: wait=1, tat=3,
   p1: wait=3, tat=8,
   avgWait= (0+1+3)/3=1.333..., TAT= (1+3+8)/3=4, resp= same as wait =>1.333..., preempt=0
*/
static bool test_sjf_impl(void){
    os_init();
    process_t p[3];
    init_process(&p[0],1,1,0);
    init_process(&p[1],5,1,0);
    init_process(&p[2],2,1,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    return check_stats(&rep, 1.3333, 4.0, 1.3333, 0ULL, 0.01);
}
TEST(test_sjf){
    if(!test_sjf_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_sjf => mismatch => expected W~1.33, T=4, R~1.33, pre=0");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_SJF);
    return true;
}

/* STRF => partial => 2 procs => p0=4, p1=3 =>
   We expect at least 1 preemption if quantum=2.
   We'll just check total_procs=2, preemptions>0.
*/
static bool test_strf_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],4,1,0);
    init_process(&p[1],3,1,0);

    scheduler_select_algorithm(ALG_STRF);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=2) return false;
    if(rep.preemptions<1) return false;
    return true;
}
TEST(test_strf){
    if(!test_strf_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_strf => mismatch => expect total=2, preempt>0");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_STRF);
    return true;
}

/* HRRN => 3 procs => p0=2, p1=3, p2=4 => no preempt =>
   total_procs=3, preempt=0
*/
static bool test_hrrn_impl(void){
    os_init();
    process_t p[3];
    init_process(&p[0],2,1,0);
    init_process(&p[1],3,1,0);
    init_process(&p[2],4,1,0);

    scheduler_select_algorithm(ALG_HRRN);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=3) return false;
    if(rep.preemptions!=0) return false;
    return true;
}
TEST(test_hrrn){
    if(!test_hrrn_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_hrrn => mismatch => expect procs=3, preempt=0");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN);
    return true;
}

/* HRRN-RT => partial preempt => 2 procs => p0=3, p1=4 => preempt>0. */
static bool test_hrrn_rt_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,0);
    init_process(&p[1],4,1,0);

    scheduler_select_algorithm(ALG_HRRN_RT);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=2) return false;
    if(rep.preemptions<1)  return false;
    return true;
}
TEST(test_hrrn_rt){
    if(!test_hrrn_rt_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_hrrn_rt => mismatch => expect procs=2, preempt>0");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN_RT);
    return true;
}

/* PRIORITY => 3 procs => p0=2,prio=3, p1=2,prio=1, p2=2,prio=2 =>
   order => p1->p2->p0 =>
   p1: wait=0,tat=2
   p2: wait=2,tat=4
   p0: wait=4,tat=6
   avgWait=2, avgTat=4, avgResp=2, pre=0
*/
static bool test_prio_impl(void){
    os_init();
    process_t p[3];
    init_process(&p[0],2,3,0);
    init_process(&p[1],2,1,0);
    init_process(&p[2],2,2,0);

    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    return check_stats(&rep,2.0,4.0,2.0,0ULL,0.001);
}
TEST(test_prio){
    if(!test_prio_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_prio => mismatch => expected W=2,T=4,R=2, pre=0");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_PRIORITY);
    return true;
}

/* CFS-SRTF => 3 procs => partial => we expect preempt>0, total=3. */
static bool test_cfs_srtf_impl(void){
    os_init();
    process_t p[3];
    init_process(&p[0],2,1,0);
    init_process(&p[1],4,1,0);
    init_process(&p[2],6,1,0);

    scheduler_select_algorithm(ALG_CFS_SRTF);
    scheduler_run(p,3);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    if(rep.total_procs!=3) return false;
    if(rep.preemptions<1) return false;
    return true;
}
TEST(test_cfs_srtf){
    if(!test_cfs_srtf_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_cfs_srtf => mismatch => expect procs=3, preempt>0");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS_SRTF);
    return true;
}

/* SJF strict => 2 procs => p0=2, p1=5 =>
   wait p0=0,tat=2 => p1=2,tat=7 =>
   avg wait=1, tat=4.5 => resp=1 => pre=0
*/
static bool test_sjf_strict_impl(void){
    os_init();
    process_t p[2];
    init_process(&p[0],2,10,0);
    init_process(&p[1],5,20,0);

    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p,2);

    sched_report_t rep;
    scheduler_fetch_report(&rep);
    os_cleanup();

    return check_stats(&rep,1.0,4.5,1.0,0ULL,0.001);
}
TEST(test_sjf_strict){
    if(!test_sjf_strict_impl()){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "test_sjf_strict => mismatch => W=1,T=4.5,R=1, pre=0");
        return false;
    }
    return true;
}

void run_normal_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_sjf);
    RUN_TEST(test_strf);
    RUN_TEST(test_hrrn);
    RUN_TEST(test_hrrn_rt);
    RUN_TEST(test_prio);
    RUN_TEST(test_cfs_srtf);
    RUN_TEST(test_sjf_strict);

    *total=tests_run;
    *passed=tests_run - tests_failed;
}
#ifndef NORMAL_TEST_H
#define NORMAL_TEST_H

/*
  run_normal_tests():
    Runs the "normal" test suite: SJF, STRF, HRRN, HRRN-RT,
    PRIORITY, CFS-SRTF, etc.
*/
void run_normal_tests(int* total,int* passed);

#endif
#include "test_common.h"
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <errno.h>

char g_test_fail_reason[256]={0};

/*
  read_all():
    Reads from fd until EOF, storing in buf up to cap-1 bytes.
*/
static ssize_t read_all(int fd, char* buf, size_t cap){
    size_t used=0;
    while(used + 1 < cap){
        ssize_t r=read(fd, buf+used, cap-1-used);
        if(r<0 && errno==EINTR) continue;
        if(r<=0) break;
        used+=(size_t)r;
    }
    buf[used] = '\0';
    return (ssize_t)used;
}

/*
  run_function_capture_output():
   - create pipes
   - fork => child => redirect => run fn
   - read from pipes => store in out
   - wait child => return status
*/
int run_function_capture_output(void(*fn)(void), struct captured_output* out){
    if(!fn || !out) return -1;
    int p_out[2], p_err[2];
    if(pipe(p_out)==-1 || pipe(p_err)==-1) return -1;
    int save_out=dup(STDOUT_FILENO);
    int save_err=dup(STDERR_FILENO);
    if(save_out<0||save_err<0) return -1;

    pid_t c=fork();
    if(c<0){
        return -1;
    }
    if(c==0){
        /* child */
        close(p_out[0]);
        close(p_err[0]);
        dup2(p_out[1],STDOUT_FILENO);
        dup2(p_err[1],STDERR_FILENO);
        close(p_out[1]);
        close(p_err[1]);

        fn();
        _exit(0);
    }
    /* parent */
    close(p_out[1]);
    close(p_err[1]);
    read_all(p_out[0], out->stdout_buf, sizeof(out->stdout_buf));
    read_all(p_err[0], out->stderr_buf, sizeof(out->stderr_buf));
    close(p_out[0]);
    close(p_err[0]);

    dup2(save_out, STDOUT_FILENO);
    dup2(save_err, STDERR_FILENO);
    close(save_out);
    close(save_err);

    int st=0;
    waitpid(c,&st,0);
    return st;
}
#ifndef TEST_COMMON_H
#define TEST_COMMON_H

#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "../src/safe_calls_library.h"

extern char g_test_fail_reason[256];

struct captured_output {
  char stdout_buf[8192];
  char stderr_buf[8192];
};

int run_function_capture_output(void(*fn)(void), struct captured_output* out);

/* Macro for defining a test function. */
#define TEST(name) static bool test_##name(void)

/* Macro for running a test. */
#define RUN_TEST(name) do { \
bool ok=test_##name(); \
tests_run++; \
if(!ok){ \
tests_failed++; \
printf("  FAIL: %s => %s\n", #name, \
g_test_fail_reason[0]?g_test_fail_reason:"???"); \
} else { \
printf("  PASS: %s\n", #name); \
} \
} while(0)

#endif
