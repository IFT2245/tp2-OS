
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include "runner.h"
#include "os.h"
#include "safe_calls_library.h"
#include "scoreboard.h"

#define CLR_RESET   "\033[0m"
#define CLR_BOLD    "\033[1m"
#define CLR_MAGENTA "\033[95m"
#define CLR_RED     "\033[91m"
#define CLR_GRAY    "\033[90m"
#define CLR_GREEN   "\033[92m"
#define CLR_YELLOW  "\033[93m"
#define CLR_CYAN    "\033[96m"

static void cleanup_and_exit(int code);
static void handle_signal(int signum);

static void clear_screen(void){
#if defined(_WIN32) || defined(_WIN64)
    system("cls");
#else
    system("clear");
#endif
}

static void pause_enter(void){
    printf("\nPress ENTER...");
    fflush(stdout);
    int c;
    while((c = getchar()) != '\n' && c != EOF){}
}

static int read_line(char *buf, size_t sz){
    if(!fgets(buf, sz, stdin)) return 0;
    buf[strcspn(buf, "\n")] = '\0';
    return 1;
}

static void menu_show_scoreboard(void){
    scoreboard_t sb;
    get_scoreboard(&sb);
    clear_screen();
    printf(CLR_BOLD CLR_MAGENTA "╔════════════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_MAGENTA "║           ★ SCOREBOARD ★          ║\n" CLR_RESET);
    printf("║ BASIC       => %.1f/100 => %s\n",
           sb.basic_percent,
           unlocked_basic ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);
    printf("║ NORMAL      => %.1f/100 => %s\n",
           sb.normal_percent,
           unlocked_normal ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);
    printf("║ EXTERNAL    => %.1f/100 => %s\n",
           sb.external_percent,
           unlocked_external ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);
    printf("║ MODES       => %.1f/100 => %s\n",
           sb.modes_percent,
           unlocked_modes ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);
    printf("║ EDGE        => %.1f/100 => %s\n",
           sb.edge_percent,
           unlocked_edge ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);
    printf("║ HIDDEN      => %.1f/100 => %s\n",
           sb.hidden_percent,
           unlocked_hidden ? CLR_GREEN"UNLOCKED"CLR_RESET : CLR_RED"LOCKED"CLR_RESET);
    printf("║\n");
    printf("║ Schedulers:\n");
    printf("║  FIFO:%s RR:%s CFS:%s CFS-SRTF:%s BFS:%s\n",
           sb.sc_fifo? "✔":"✘",
           sb.sc_rr? "✔":"✘",
           sb.sc_cfs? "✔":"✘",
           sb.sc_cfs_srtf? "✔":"✘",
           sb.sc_bfs? "✔":"✘");
    printf("║  SJF:%s STRF:%s HRRN:%s HRRN-RT:%s PRIORITY:%s\n",
           sb.sc_sjf? "✔":"✘",
           sb.sc_strf? "✔":"✘",
           sb.sc_hrrn? "✔":"✘",
           sb.sc_hrrn_rt? "✔":"✘",
           sb.sc_priority? "✔":"✘");
    printf("║  HPC-OVER:%s MLFQ:%s\n",
           sb.sc_hpc_over? "✔":"✘",
           sb.sc_mlfq? "✔":"✘");
    int final_score = scoreboard_get_final_score();
    printf("║\n");
    printf("╚═ Overall Score => %d/100\n", final_score);
    pause_enter();
}

static void menu_clear_scoreboard(void){
    scoreboard_clear();
    printf("\nScoreboard cleared.\n");
    pause_enter();
}

static void cleanup_and_exit(int code){
    os_cleanup();
    scoreboard_save();
    scoreboard_close();
    exit(code);
}

static void handle_signal(int signum){
    if(signum == SIGINT){
        printf("\nCaught SIGINT! Saving scoreboard...\n");
        int fs = scoreboard_get_final_score();
        cleanup_and_exit(fs);
    }
}

/* Additional sub-prompt to choose concurrency test type for single scheduling. */
static int menu_choose_concurrency_level(void){
    printf("\nChoose concurrency test type for deeper customization:\n");
    printf(" 1) Short test (commands like 'sleep 2')\n");
    printf(" 2) Medium test (commands like 'sleep 5', 'sleep 6')\n");
    printf(" 3) Stress test (commands like 'sleep 10', 'sleep 12', etc.)\n");
    printf("Choice: ");
    char buf[256];
    if(!read_line(buf,sizeof(buf))) return 1;
    int x=parse_int_strtol(buf,1);
    if(x<1||x>3) x=1;
    return x;
}

static void menu_submenu_external_concurrency(void){
    printf(CLR_BOLD CLR_CYAN "\n╔══════════════════════════════╗\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "║ External Shell Concurrency   ║\n" CLR_RESET);
    printf(CLR_BOLD CLR_CYAN   "╚══════════════════════════════╝\n" CLR_RESET);

    printf("1) Run concurrency with a SINGLE scheduling mode\n");
    printf("2) Run concurrency with ALL scheduling modes\n");
    printf("\nChoice: ");
    char buf[256];
    if(!read_line(buf, sizeof(buf))) return;
    int sub = parse_int_strtol(buf, -1);
    if(sub < 1 || sub > 2){
        printf("Invalid.\n");
        pause_enter();
        return;
    }

    printf("How many concurrent shells? ");
    if(!read_line(buf, sizeof(buf))) return;
    int n = parse_int_strtol(buf, 0);
    if(n < 1){
        printf("Invalid number.\n");
        pause_enter();
        return;
    }

    printf("How many CPU cores? ");
    if(!read_line(buf, sizeof(buf))) return;
    int c = parse_int_strtol(buf, 2);
    if(c < 1) c = 2;

    char** lines = (char**)calloc(n, sizeof(char*));
    if(sub==1){
        /* SINGLE scheduling => also ask for concurrency style. */
        int style=menu_choose_concurrency_level();
        // fill lines based on style
        if(style==1){
            // short test
            for(int i=0;i<n;i++){
                char tmp[64];
                snprintf(tmp,sizeof(tmp),"sleep %d", (i+1)*2);
                lines[i]=strdup(tmp);
            }
        } else if(style==2){
            // medium
            for(int i=0;i<n;i++){
                char tmp[64];
                snprintf(tmp,sizeof(tmp),"sleep %d", (i+1)*3 + 2);
                lines[i]=strdup(tmp);
            }
        } else {
            // stress
            for(int i=0;i<n;i++){
                char tmp[64];
                snprintf(tmp,sizeof(tmp),"sleep %d", (i+1)*5);
                lines[i]=strdup(tmp);
            }
        }
    } else {
        // ALL modes => just do something like 'sleep 2', 'sleep 3', etc.
        for(int i=0;i<n;i++){
            char tmp[64];
            snprintf(tmp,sizeof(tmp),"sleep %d",(i+1)*2);
            lines[i]=strdup(tmp);
        }
    }

    if(sub == 1){
        // single scheduling choice
        printf("\nSelect scheduling mode:\n");
        printf(" 0=FIFO,1=RR,2=CFS,3=CFS-SRTF,4=BFS,5=SJF,6=STRF,7=HRRN,8=HRRN-RT,\n");
        printf(" 9=PRIORITY,10=HPC-OVER,11=MLFQ\n");
        printf("Choice: ");
        if(!read_line(buf, sizeof(buf))){
            pause_enter();
            return;
        }
        int mode = parse_int_strtol(buf, -1);
        if(mode < 0 || mode > 11){
            printf("Invalid.\n");
            pause_enter();
        } else {
            run_shell_commands_concurrently(n, lines, c, mode, 0);
        }
    } else {
        // all scheduling modes
        run_shell_commands_concurrently(n, lines, c, -1, 1);
    }

    for(int i=0;i<n;i++){
        free(lines[i]);
    }
    free(lines);
    pause_enter();
}

int main(int argc, char** argv){
    (void)argc; (void)argv;
    signal(SIGINT, handle_signal);
    scoreboard_init();
    scoreboard_load();
    os_init();

    while(1){
        clear_screen();
        printf(CLR_BOLD CLR_YELLOW "┌─── MAIN MENU ────────────────────┐\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 1) Run All Unlocked              │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 2) Exit                          │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 3) External Shell Concurrency    │\n" CLR_RESET);
        if(unlocked_external){
            printf(CLR_BOLD CLR_YELLOW "│ 4) External Tests                │\n" CLR_RESET);
        } else {
            printf(CLR_BOLD CLR_YELLOW "│ 4) External Tests " CLR_GRAY "(locked)" CLR_RESET "\n");
        }
        printf(CLR_BOLD CLR_YELLOW "│ 5) Show Scoreboard               │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "│ 6) Clear Scoreboard              │\n" CLR_RESET);
        printf(CLR_BOLD CLR_YELLOW "└───────────────────────────────────┘\n\n" CLR_RESET);
        printf("Choice: ");

        char input[256];
        if(!read_line(input, sizeof(input))){
            printf("Exiting (EOF or read error).\n");
            int fs = scoreboard_get_final_score();
            cleanup_and_exit(fs);
        }
        int choice = parse_int_strtol(input, -1);

        switch(choice){
        case 1:
            printf(CLR_CYAN "\nRunning all unlocked...\n" CLR_RESET);
            run_all_levels();
            scoreboard_save();
            pause_enter();
            break;
        case 2:{
            int fs = scoreboard_get_final_score();
            printf("\nExiting with final score = %d.\n", fs);
            cleanup_and_exit(fs);
            break;
        }
        case 3:
            if(!unlocked_external){
                printf("External locked.\n");
                pause_enter();
            } else {
                menu_submenu_external_concurrency();
            }
            break;
        case 4:
            if(!unlocked_external){
                printf("Locked.\n");
                pause_enter();
            } else {
                printf("\nRunning external tests...\n");
                run_external_tests_menu();
                scoreboard_save();
                pause_enter();
            }
            break;
        case 5:
            menu_show_scoreboard();
            break;
        case 6:
            menu_clear_scoreboard();
            break;
        default:
            printf("Invalid.\n");
            pause_enter();
            break;
        }
    }
    return 0;
}
#include "os.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/wait.h>
#include <sys/stat.h>

#define MAX_CONTAINERS 32

static uint64_t start_ms = 0;
static char container_paths[MAX_CONTAINERS][256];
static int container_count = 0;

static uint64_t now_ms(void){
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec*1000ULL + (ts.tv_nsec/1000000ULL);
}

void os_init(void){
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
    start_ms = now_ms();
    memset(container_paths, 0, sizeof(container_paths));
    container_count = 0;
    printf("\033[94mInit\033[0m\n");
}

void os_cleanup(void){
    while(container_count > 0){
        os_remove_ephemeral_container();
    }
    printf("\033[96mCleanup\033[0m\n");
}

uint64_t os_time(void){
    return now_ms() - start_ms;
}

void os_log(const char* msg){
    if(msg) printf("%s\n", msg);
}

void os_create_ephemeral_container(void){
    if(container_count >= MAX_CONTAINERS) return;
    char tmpl[] = "/tmp/os_cont_XXXXXX";
    if(mkdtemp(tmpl)){
        strncpy(container_paths[container_count], tmpl, 255);
        container_count++;
        printf("Container created: %s\n", tmpl);
    }
}

void os_remove_ephemeral_container(void){
    if(container_count <= 0) return;
    container_count--;
    const char* path = container_paths[container_count];
    if(path[0]){
        rmdir(path);
        memset(container_paths[container_count], 0, sizeof(container_paths[container_count]));
        printf("Container removed: %s\n", path);
    }
}

static void* overshadow_thread(void* arg){
    long* r = (long*)arg;
    long s = 0;
    for(long i=0; i<1000000; i++){
        s += (i % 17) + (i % 11);
    }
    *r = s;
    return NULL;
}

void os_run_hpc_overshadow(void){
    printf("HPC overshadow start\n");
    int n = 4;
    long* vals = (long*)calloc(n, sizeof(long));
    pthread_t* th = (pthread_t*)malloc(n*sizeof(pthread_t));
    for(int i=0; i<n; i++){
        pthread_create(&th[i], NULL, overshadow_thread, &vals[i]);
    }
    for(int i=0; i<n; i++){
        pthread_join(th[i], NULL);
    }
    free(th);
    free(vals);
    printf("HPC overshadow done\n");
}

void os_pipeline_example(void){
    printf("Pipeline start\n");
    pid_t c = fork();
    if(c == 0){
        usleep(50000);
        _exit(0);
    }
    waitpid(c, NULL, 0);
    printf("Pipeline end\n");
}

void os_run_distributed_example(void){
    printf("Distributed example: fork\n");
    pid_t c = fork();
    if(c == 0){
        printf("Child HPC overshadow\n");
        os_run_hpc_overshadow();
        _exit(0);
    } else {
        waitpid(c, NULL, 0);
    }
}
#ifndef OS_H
#define OS_H

#include <stdint.h>

void os_init(void);
void os_cleanup(void);
uint64_t os_time(void);
void os_log(const char* msg);
void os_create_ephemeral_container(void);
void os_remove_ephemeral_container(void);
void os_run_hpc_overshadow(void);
void os_pipeline_example(void);
void os_run_distributed_example(void);

#endif
#include "process.h"
#include <string.h>

void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival){
    if(!p) return;
    memset(p, 0, sizeof(*p));
    p->burst_time     = burst;
    p->remaining_time = burst;
    p->priority       = priority;
    p->arrival_time   = arrival;
}
#ifndef PROCESS_H
#define PROCESS_H

#include <stdint.h>

typedef struct process_s {
    uint64_t burst_time;
    int      priority;
    uint64_t vruntime;
    uint64_t arrival_time;
    uint64_t remaining_time;
    uint64_t last_exec;
    int      mlfq_level;
} process_t;

void init_process(process_t* p, uint64_t burst, int priority, uint64_t arrival);

#endif
#include "ready_queue.h"
#include <pthread.h>
#include <stdlib.h>
#include <string.h>
#include "os.h"

#define MLFQ_MAX_QUEUES 10

typedef struct node_s {
    process_t*     proc;
    struct node_s* next;
} node_t;

static struct {
    node_t         sentinel;
    size_t         size;
    pthread_mutex_t m;
    pthread_cond_t  c;
    scheduler_alg_t alg;
    node_t         ml_queues[MLFQ_MAX_QUEUES];
} gQ;

static pthread_mutex_t* pm(void){ return &gQ.m; }
static pthread_cond_t*  pc(void){ return &gQ.c; }

static process_t* pop_head(void){
    while(!gQ.sentinel.next){
        pthread_cond_wait(pc(), pm());
    }
    node_t* n = gQ.sentinel.next;
    gQ.sentinel.next = n->next;
    gQ.size--;
    process_t* r = n->proc;
    free(n);
    return r;
}

static void push_tail(process_t* p){
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;
    node_t* c = &gQ.sentinel;
    while(c->next) c = c->next;
    c->next = n;
    gQ.size++;
}

static void push_prio(process_t* p){
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;
    node_t* c = &gQ.sentinel;
    while(c->next && p->priority <= c->next->proc->priority){
        c = c->next;
    }
    n->next = c->next;
    c->next = n;
    gQ.size++;
}

static void push_cfs(process_t* p){
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;
    node_t* c = &gQ.sentinel;
    while(c->next && p->vruntime >= c->next->proc->vruntime){
        c = c->next;
    }
    n->next = c->next;
    c->next = n;
    gQ.size++;
}

static void push_sjf(process_t* p){
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;
    node_t* c = &gQ.sentinel;
    while(c->next && p->burst_time >= c->next->proc->burst_time){
        c = c->next;
    }
    n->next = c->next;
    c->next = n;
    gQ.size++;
}

static uint64_t hrrn_val(process_t* p, uint64_t now){
    if(!p->burst_time) return 999999;
    uint64_t w = (now > p->arrival_time)?(now - p->arrival_time):0;
    uint64_t r = (p->remaining_time>0? p->remaining_time:1);
    return (w + r)/r;
}

static void push_hrrn(process_t* p){
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;
    uint64_t now = os_time();
    node_t* c = &gQ.sentinel;
    while(c->next){
        uint64_t cv = hrrn_val(c->next->proc, now);
        uint64_t pv = hrrn_val(p, now);
        if(pv > cv) break;
        c = c->next;
    }
    n->next = c->next;
    c->next = n;
    gQ.size++;
}

static process_t* pop_mlfq(void){
    for(int i=0; i<MLFQ_MAX_QUEUES; i++){
        if(gQ.ml_queues[i].next){
            node_t* n = gQ.ml_queues[i].next;
            gQ.ml_queues[i].next = n->next;
            gQ.size--;
            process_t* r = n->proc;
            free(n);
            return r;
        }
    }
    return NULL;
}

static void push_mlfq(process_t* p){
    if(!p) return;
    int lev = p->mlfq_level;
    if(lev < 0) lev=0;
    if(lev >= MLFQ_MAX_QUEUES) lev = MLFQ_MAX_QUEUES-1;
    node_t* n = (node_t*)malloc(sizeof(node_t));
    n->proc = p;
    n->next = NULL;
    node_t* c = &gQ.ml_queues[lev];
    while(c->next) c = c->next;
    c->next = n;
    gQ.size++;
}

static process_t* (*f_pop)(void)        = NULL;
static void       (*f_push)(process_t*) = NULL;

void ready_queue_init_policy(scheduler_alg_t alg){
    memset(&gQ, 0, sizeof(gQ));
    pthread_mutex_init(pm(), NULL);
    pthread_cond_init(pc(), NULL);
    gQ.alg = alg;
    switch(alg){
    case ALG_FIFO:
    case ALG_RR:
    case ALG_BFS:
        f_push = push_tail;
        f_pop  = pop_head;
        break;
    case ALG_PRIORITY:
        f_push = push_prio;
        f_pop  = pop_head;
        break;
    case ALG_CFS:
    case ALG_CFS_SRTF:
        f_push = push_cfs;
        f_pop  = pop_head;
        break;
    case ALG_SJF:
    case ALG_STRF:
        f_push = push_sjf;
        f_pop  = pop_head;
        break;
    case ALG_HRRN:
    case ALG_HRRN_RT:
        f_push = push_hrrn;
        f_pop  = pop_head;
        break;
    case ALG_MLFQ:
        f_push = push_mlfq;
        f_pop  = pop_mlfq;
        break;
    default:
        f_push = push_tail;
        f_pop  = pop_head;
        break;
    }
}

void ready_queue_destroy(void){
    pthread_cond_destroy(pc());
    pthread_mutex_destroy(pm());
    memset(&gQ, 0, sizeof(gQ));
}

void ready_queue_push(process_t* p){
    pthread_mutex_lock(pm());
    f_push(p);
    pthread_cond_signal(pc());
    pthread_mutex_unlock(pm());
}

process_t* ready_queue_pop(void){
    pthread_mutex_lock(pm());
    process_t* r = f_pop();
    while(!r){
        pthread_cond_wait(pc(), pm());
        r = f_pop();
    }
    pthread_mutex_unlock(pm());
    return r;
}

size_t ready_queue_size(void){
    pthread_mutex_lock(pm());
    size_t s = gQ.size;
    pthread_mutex_unlock(pm());
    return s;
}
#ifndef READY_QUEUE_H
#define READY_QUEUE_H

#include <stddef.h>
#include "process.h"
#include "scheduler.h"

void ready_queue_init_policy(scheduler_alg_t alg);
void ready_queue_destroy(void);
void ready_queue_push(process_t* proc);
process_t* ready_queue_pop(void);
size_t ready_queue_size(void);

#endif
#include "runner.h"
#include "scoreboard.h"
#include "os.h"
#include "../test/basic-test.h"
#include "../test/normal-test.h"
#include "../test/modes-test.h"
#include "../test/edge-test.h"
#include "../test/hidden-test.h"
#include "../test/external-test.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

/* Unlock logic updated as soon as each test set finishes. */

void run_all_levels(void){
    extern int unlocked_basic, unlocked_normal, unlocked_modes,
                unlocked_edge, unlocked_hidden;
    if(!unlocked_basic){
        printf("BASIC locked.\n");
        return;
    }
    {
        int t=0,p=0; run_basic_tests(&t,&p);
        scoreboard_update_basic(t,p);
        scoreboard_save();
    }

    if(!unlocked_normal){
        printf("NORMAL locked.\n");
        return;
    }
    {
        int t=0,p=0; run_normal_tests(&t,&p);
        scoreboard_update_normal(t,p);
        scoreboard_save();
    }

    /* external in final weighting => but 'unlock external' is triggered after basic >= threshold. */

    if(!unlocked_modes){
        printf("MODES locked.\n");
        return;
    }
    {
        int t=0,p=0; run_modes_tests(&t,&p);
        scoreboard_update_modes(t,p);
        scoreboard_save();
    }

    if(!unlocked_edge){
        printf("EDGE locked.\n");
        return;
    }
    {
        int t=0,p=0; run_edge_tests(&t,&p);
        scoreboard_update_edge(t,p);
        scoreboard_save();
    }

    if(!unlocked_hidden){
        printf("HIDDEN locked.\n");
        return;
    }
    {
        int t=0,p=0; run_hidden_tests(&t,&p);
        scoreboard_update_hidden(t,p);
        scoreboard_save();
    }
}

void run_external_tests_menu(void){
    extern int unlocked_external;
    if(!unlocked_external) return;
    run_external_tests();
}

static int cmp_events(const void* a,const void* b){
    /* Used for concurrency calculation, sorting by timestamp. */
    uint64_t x=((uint64_t*)a)[0];
    uint64_t y=((uint64_t*)b)[0];
    if(x<y)return -1; if(x>y)return 1; return 0;
}

/*
  If mode < 0 && allModes=1 => run for all modes
  Otherwise run only the chosen 'mode'.
*/
void run_shell_commands_concurrently(int count, char** lines,int coreCount,
                                     int mode, int allModes)
{
    if(count<=0||!lines) return;

    typedef struct {
        int   p_out[2], p_err[2], p_in[2];
        pid_t pid;
        char* cmd;
        uint64_t start_ms;
        uint64_t end_ms;
        int core;
    } child_t;
    scheduler_alg_t test_modes[] = {
        ALG_FIFO, ALG_RR, ALG_BFS, ALG_PRIORITY,
        ALG_CFS, ALG_CFS_SRTF, ALG_SJF, ALG_STRF,
        ALG_HRRN, ALG_HRRN_RT, ALG_HPC_OVERSHADOW, ALG_MLFQ
    };
    const char* modeNames[]={
        "FIFO","RR","BFS","PRIORITY",
        "CFS","CFS-SRTF","SJF","STRF",
        "HRRN","HRRN-RT","HPC-OVER","MLFQ"
    };
    int mode_count=(int)(sizeof(test_modes)/sizeof(test_modes[0]));

    int from=0,to=mode_count-1;
    if(!allModes){
        if(mode<0||mode>=mode_count){
            printf("Invalid scheduling mode.\n");
            return;
        }
        from=to=mode;
    }

    for(int m=from;m<=to;m++){
        printf("\n\033[95m=== Concurrency with %s ===\033[0m\n", modeNames[m]);

        child_t* ch=(child_t*)calloc(count,sizeof(child_t));
        if(!ch) return;

        if(access("./shell-tp1-implementation",X_OK)!=0){
            printf("No shell-tp1-implementation found.\n");
            free(ch);
            return;
        }
        uint64_t global_start=os_time();
        int next_core=0;

        /* fork each child process running shell-tp1-implementation */
        for(int i=0;i<count;i++){
            if(!lines[i]||!*lines[i]) continue;
            pipe(ch[i].p_out);
            pipe(ch[i].p_err);
            pipe(ch[i].p_in);

            pid_t c=fork();
            if(c<0){
                fprintf(stderr,"fork() fail\n");
            } else if(c==0){
                close(ch[i].p_out[0]);
                close(ch[i].p_err[0]);
                close(ch[i].p_in[0]);
                dup2(ch[i].p_out[1],STDOUT_FILENO);
                dup2(ch[i].p_err[1],STDERR_FILENO);
                dup2(ch[i].p_in[1],STDIN_FILENO);
                close(ch[i].p_out[1]);
                close(ch[i].p_err[1]);
                close(ch[i].p_in[1]);

                execl("./shell-tp1-implementation","shell-tp1-implementation",(char*)NULL);
                _exit(127);
            } else {
                ch[i].pid      = c;
                ch[i].cmd      = lines[i];
                ch[i].start_ms = os_time();
                ch[i].core     = next_core;
                close(ch[i].p_out[1]);
                close(ch[i].p_err[1]);
                close(ch[i].p_in[0]);

                /* send the actual command + 'exit' */
                dprintf(ch[i].p_in[1],"%s\nexit\n",lines[i]);
                close(ch[i].p_in[1]);

                /* round-robin assignment of cores for demonstration */
                next_core=(next_core+1)%coreCount;
            }
        }

        /* wait for them */
        for(int i=0;i<count;i++){
            if(!ch[i].pid) continue;
            waitpid(ch[i].pid,NULL,0);
            ch[i].end_ms=os_time();
        }
        uint64_t global_end=os_time();

        /* read leftover data from pipes (optional) */
        for(int i=0;i<count;i++){
            if(!ch[i].pid) continue;
            char outb[256]={0},errb[256]={0};
            read(ch[i].p_out[0], outb,sizeof(outb)-1);
            read(ch[i].p_err[0], errb,sizeof(errb)-1);
            close(ch[i].p_out[0]);
            close(ch[i].p_err[0]);
        }

        printf("\n\033[93m[Concurrency Timeline => %s]\033[0m\n", modeNames[m]);

        /* find min/max times */
        uint64_t min_start=(uint64_t)-1,max_end=0;
        for(int i=0;i<count;i++){
            if(ch[i].pid){
                if(ch[i].start_ms<min_start) min_start=ch[i].start_ms;
                if(ch[i].end_ms>max_end)     max_end=ch[i].end_ms;
            }
        }
        if(min_start==(uint64_t)-1) min_start=0;
        if(max_end<min_start) max_end=min_start;

        /* timeline columns */
        const int COLS=30;
        static const char* colors[]={
            "\033[91m","\033[92m","\033[93m","\033[94m",
            "\033[95m","\033[96m","\033[97m","\033[90m"
        };
        int num_colors=(int)(sizeof(colors)/sizeof(colors[0]));
        uint64_t total_range=(max_end>min_start?(max_end-min_start):1ULL);

        /* Show each process as a single line, color-coded block. */
        for(int i=0;i<count;i++){
            if(!ch[i].pid) continue;
            const char* color=colors[i%num_colors];
            char row[COLS+1]; memset(row,' ',sizeof(row)); row[COLS]='\0';
            for(int c=0;c<COLS;c++){
                uint64_t step_time=min_start+(c*total_range/COLS);
                if(step_time>=ch[i].start_ms && step_time<ch[i].end_ms){
                    row[c] = '█'; /* Overlap region */
                }
            }
            uint64_t dur=(ch[i].end_ms>ch[i].start_ms)?
                          (ch[i].end_ms-ch[i].start_ms):0ULL;
            /* minimal spacing, one-liner */
            printf("%sP%d(c%d)\033[0m:[%s] st=%llu end=%llu dur=%llums cmd=\"%s\"\n",
                   color,
                   i+1,
                   ch[i].core,
                   row,
                   (unsigned long long)ch[i].start_ms,
                   (unsigned long long)ch[i].end_ms,
                   (unsigned long long)dur,
                   ch[i].cmd?ch[i].cmd:"");
        }

        /* concurrency calculations */
        uint64_t(*events)[2]=calloc(count*2,sizeof(uint64_t[2]));
        int eidx=0;
        for(int i=0;i<count;i++){
            if(!ch[i].pid) continue;
            events[eidx][0] = ch[i].start_ms; events[eidx][1]=1; eidx++;
            events[eidx][0] = ch[i].end_ms;   events[eidx][1]=(uint64_t)-1; eidx++;
        }
        qsort(events,eidx,sizeof(events[0]),cmp_events);
        int concurrency=0,peak=0;
        double sum=0.0; uint64_t last_t=min_start;
        for(int i=0;i<eidx;i++){
            uint64_t t=events[i][0];
            if(t<last_t) t=last_t; /* no negative time intervals */
            uint64_t dt=(t>last_t?(t-last_t):0);
            sum += concurrency*dt;
            if(events[i][1]==(uint64_t)-1) concurrency--;
            else concurrency++;
            if(concurrency>peak) peak=concurrency;
            last_t=t;
        }
        free(events);
        uint64_t length=(max_end>min_start?(max_end-min_start):1ULL);
        double avg=(length>0)?(sum/(double)length):0.0;

        printf("\033[96mPeak concurrency=%d, Average concurrency=%.2f\033[0m\n",peak,avg);

        uint64_t total_concurrency=(global_end>global_start)?
                                    (global_end-global_start):0ULL;
        printf("\033[92mTotal concurrency time=%llums\033[0m\n\n",
               (unsigned long long)total_concurrency);

        free(ch);
    }
}
#ifndef RUNNER_H
#define RUNNER_H

void run_all_levels(void);
void run_external_tests_menu(void);

/* run_shell_commands_concurrently():
   mode<0 && allModes=1 => run all known scheduling modes
   else => run only 'mode'
*/
void run_shell_commands_concurrently(int count,char** lines,int coreCount,
                                     int mode,int allModes);

#endif
#include "safe_calls_library.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

int parse_int_strtol(const char* in, int fb){
    if(!in||!*in) return fb;
    errno=0; char* e=NULL;
    long v=strtol(in,&e,10);
    if(e==in||errno==ERANGE||v<INT_MIN||v>INT_MAX) return fb;
    return (int)v;
}

long parse_long_strtol(const char* in, long fb){
    if(!in||!*in) return fb;
    errno=0; char* e=NULL;
    long v=strtol(in,&e,10);
    if(e==in||errno==ERANGE) return fb;
    return v;
}

float parse_float_strtof(const char* in, float fb){
    if(!in||!*in) return fb;
    errno=0; char* e=NULL;
    float v=strtof(in,&e);
    if(e==in||errno==ERANGE) return fb;
    return v;
}

double parse_double_strtod(const char* in, double fb){
    if(!in||!*in) return fb;
    errno=0; char* e=NULL;
    double v=strtod(in,&e);
    if(e==in||errno==ERANGE) return fb;
    return v;
}

int safe_pthread_create(void*(*f)(void*), void* arg){
    pthread_t t;
    int r = pthread_create(&t,NULL,f,arg);
    if(r){
        fprintf(stderr,"pthread_create fail\n");
        return -1;
    }
    pthread_detach(t);
    return 0;
}
#ifndef SAFE_CALLS_LIBRARY_H
#define SAFE_CALLS_LIBRARY_H

int  safe_pthread_create(void*(*f)(void*), void* arg);
int   parse_int_strtol(const char* input, int fallback);
long  parse_long_strtol(const char* input, long fallback);
float parse_float_strtof(const char* input, float fallback);
double parse_double_strtod(const char* input, double fallback);

#endif
#include "scheduler.h"
#include "ready_queue.h"
#include "os.h"
#include "worker.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static scheduler_alg_t current_alg=ALG_CFS;
static int gCount=0;

typedef struct {
    unsigned long long preemptions;
    unsigned long long total_processes;
    unsigned long long total_wait;
    unsigned long long total_turnaround;
    unsigned long long total_response;
} sched_stats_t;
static sched_stats_t gStats;

typedef struct {
    uint64_t arrival;
    uint64_t start;
    uint64_t end;
    uint64_t cpu;
    int      started;
} track_t;
static track_t* gTrack=NULL;

static void rec_arrival(int i){
    if(gTrack && gTrack[i].arrival==0){
        gTrack[i].arrival=os_time();
    }
}
static void rec_start(int i){
    if(gTrack && !gTrack[i].started){
        gTrack[i].start=os_time();
        gTrack[i].started=1;
    }
}
static void rec_cpu(int i,unsigned long s){
    if(gTrack) gTrack[i].cpu += s;
}
static void rec_end(int i){
    if(gTrack && gTrack[i].end==0){
        gTrack[i].end=os_time();
    }
}
static void finalize(void){
    for(int i=0;i<gCount;i++){
        uint64_t at=gTrack[i].arrival;
        uint64_t st=gTrack[i].start;
        uint64_t et=gTrack[i].end;
        uint64_t cpu=gTrack[i].cpu;
        uint64_t turn=(et>at?(et-at):0);
        uint64_t resp=(st>at?(st-at):0);
        uint64_t wait=(turn>cpu?(turn-cpu):0);
        gStats.total_turnaround += turn;
        gStats.total_response   += resp;
        gStats.total_wait       += wait;
    }
}

static const char* alg2str(scheduler_alg_t x){
    switch(x){
    case ALG_FIFO:return "FIFO";
    case ALG_RR: return "RR";
    case ALG_CFS: return "CFS";
    case ALG_CFS_SRTF:return "CFS-SRTF";
    case ALG_BFS: return "BFS";
    case ALG_SJF: return "SJF";
    case ALG_STRF:return "STRF";
    case ALG_HRRN:return "HRRN";
    case ALG_HRRN_RT:return "HRRN-RT";
    case ALG_PRIORITY:return "PRIORITY";
    case ALG_HPC_OVERSHADOW:return "HPC-OVER";
    case ALG_MLFQ:return "MLFQ";
    default:return "???";
    }
}

void scheduler_select_algorithm(scheduler_alg_t a){
    current_alg=a;
}

static void enqueue_all(process_t* arr,int n){
    for(int i=0;i<n;i++){
        ready_queue_push(&arr[i]);
        gStats.total_processes++;
        rec_arrival(i);
    }
}

void scheduler_run(process_t* list,int count){
    if(!list||count<=0) return;
    gCount=count;
    gTrack=(track_t*)calloc(count,sizeof(track_t));
    memset(&gStats,0,sizeof(gStats));
    if(current_alg==ALG_HPC_OVERSHADOW){
        os_run_hpc_overshadow();
        free(gTrack);gTrack=NULL;
        return;
    }
    ready_queue_init_policy(current_alg);
    enqueue_all(list,count);

    uint64_t t0=os_time();
    int quantum=2;
    while(ready_queue_size()>0){
        process_t* p=ready_queue_pop();
        if(!p) break;
        int idx=(int)(p-list);
        rec_start(idx);
        if(current_alg==ALG_MLFQ||current_alg==ALG_BFS||current_alg==ALG_RR||
           current_alg==ALG_CFS_SRTF||current_alg==ALG_STRF||current_alg==ALG_HRRN_RT){
            if(p->remaining_time>(unsigned long)quantum){
                simulate_process_partial(p,quantum);
                rec_cpu(idx,quantum);
                p->remaining_time-=quantum;
                if(current_alg==ALG_CFS_SRTF) p->vruntime+=quantum;
                gStats.preemptions++;
                if(current_alg==ALG_MLFQ) p->mlfq_level++;
                ready_queue_push(p);
            } else {
                simulate_process_partial(p,p->remaining_time);
                rec_cpu(idx,p->remaining_time);
                p->remaining_time=0;
                rec_end(idx);
            }
        } else {
            simulate_process(p);
            rec_cpu(idx,p->remaining_time);
            p->remaining_time=0;
            rec_end(idx);
        }
    }
    ready_queue_destroy();
    uint64_t tot=os_time()-t0;
    finalize();
    printf("\033[92mStats for %s => time=%llu\n\033[0m",alg2str(current_alg),(unsigned long long)tot);
    printf("procs=%llu preempt=%llu\n",gStats.total_processes,gStats.preemptions);
    if(gStats.total_processes>0){
        double n=(double)gStats.total_processes;
        double aW=gStats.total_wait/n;
        double aT=gStats.total_turnaround/n;
        double aR=gStats.total_response/n;
        printf("Wait=%.2f TAT=%.2f RESP=%.2f\n",aW,aT,aR);
    }
    free(gTrack);gTrack=NULL;gCount=0;
}
#ifndef SCHEDULER_H
#define SCHEDULER_H

#include "process.h"

typedef enum {
    ALG_CFS,
    ALG_CFS_SRTF,
    ALG_FIFO,
    ALG_RR,
    ALG_SJF,
    ALG_STRF,
    ALG_HRRN,
    ALG_HRRN_RT,
    ALG_BFS,
    ALG_PRIORITY,
    ALG_HPC_OVERSHADOW,
    ALG_MLFQ
} scheduler_alg_t;

void scheduler_select_algorithm(scheduler_alg_t a);
void scheduler_run(process_t* list, int count);

#endif
#include "scoreboard.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>

int unlocked_basic=1;
int unlocked_normal=0;
int unlocked_external=0;
int unlocked_modes=0;
int unlocked_edge=0;
int unlocked_hidden=0;

static scoreboard_t gSB={
    0,0,0,0,0,0,0,0,0,0,0,0, // basic..hidden
    0,0,0,0,0,0, // sc_fifo..sc_mlfq
    0.0,0.0,0.0,0.0,0.0,0.0, // basic%, normal%, external%, modes%, edge%, hidden%
    60.0
};

static void update_unlocks(void){
    gSB.basic_percent=(gSB.basic_total>0)?
        ((gSB.basic_pass*100.0)/gSB.basic_total):0.0;
    gSB.normal_percent=(gSB.normal_total>0)?
        ((gSB.normal_pass*100.0)/gSB.normal_total):0.0;
    gSB.external_percent=(gSB.external_total>0)?
        ((gSB.external_pass*100.0)/gSB.external_total):0.0;
    gSB.modes_percent=(gSB.modes_total>0)?
        ((gSB.modes_pass*100.0)/gSB.modes_total):0.0;
    gSB.edge_percent=(gSB.edge_total>0)?
        ((gSB.edge_pass*100.0)/gSB.edge_total):0.0;
    gSB.hidden_percent=(gSB.hidden_total>0)?
        ((gSB.hidden_pass*100.0)/gSB.hidden_total):0.0;

    double T=gSB.pass_threshold;
    if(gSB.basic_percent>=T){
        unlocked_normal=1;
        unlocked_external=1; /* external unlocked after basic pass threshold */
    }
    if(gSB.normal_percent>=T){
        unlocked_modes=1;
    }
    if(gSB.modes_percent>=T){
        unlocked_edge=1;
    }
    if(gSB.edge_percent>=T){
        unlocked_hidden=1;
    }
}

static char* read_file_all(const char* path){
    FILE* f=fopen(path,"rb");
    if(!f) return NULL;
    fseek(f,0,SEEK_END);
    long size=ftell(f);
    if(size<0){fclose(f);return NULL;}
    fseek(f,0,SEEK_SET);
    char* buf=(char*)malloc(size+1);
    if(!buf){fclose(f);return NULL;}
    if(fread(buf,1,size,f)!=(size_t)size){
        fclose(f); free(buf); return NULL;
    }
    buf[size]='\0';
    fclose(f);
    return buf;
}
static int parse_json_int(const char* json,const char* key,int def){
    if(!json||!key) return def;
    char pattern[128]; snprintf(pattern,sizeof(pattern),"\"%s\"",key);
    char* found=strstr(json,pattern);
    if(!found) return def;
    char* colon=strstr(found,":");
    if(!colon) return def;
    colon++;
    while(*colon&&(*colon==' '||*colon=='\t')) colon++;
    int val=def; sscanf(colon,"%d",&val);
    return val;
}
static double parse_json_double(const char* json,const char* key,double def){
    if(!json||!key) return def;
    char pattern[128]; snprintf(pattern,sizeof(pattern),"\"%s\"",key);
    char* found=strstr(json,pattern);
    if(!found) return def;
    char* colon=strstr(found,":");
    if(!colon) return def;
    colon++;
    while(*colon&&(*colon==' '||*colon=='\t')) colon++;
    double val=def; sscanf(colon,"%lf",&val);
    return val;
}

static void write_scoreboard_json(const scoreboard_t* sb){
    FILE* f=fopen("scoreboard.json","w");
    if(!f) return;
    fprintf(f,"{\n");
    fprintf(f,"  \"basic_total\": %d,\n",   sb->basic_total);
    fprintf(f,"  \"basic_pass\": %d,\n",    sb->basic_pass);
    fprintf(f,"  \"normal_total\": %d,\n",  sb->normal_total);
    fprintf(f,"  \"normal_pass\": %d,\n",   sb->normal_pass);
    fprintf(f,"  \"external_total\": %d,\n",sb->external_total);
    fprintf(f,"  \"external_pass\": %d,\n", sb->external_pass);
    fprintf(f,"  \"modes_total\": %d,\n",   sb->modes_total);
    fprintf(f,"  \"modes_pass\": %d,\n",    sb->modes_pass);
    fprintf(f,"  \"edge_total\": %d,\n",    sb->edge_total);
    fprintf(f,"  \"edge_pass\": %d,\n",     sb->edge_pass);
    fprintf(f,"  \"hidden_total\": %d,\n",  sb->hidden_total);
    fprintf(f,"  \"hidden_pass\": %d,\n",   sb->hidden_pass);

    fprintf(f,"  \"sc_fifo\": %d,\n",       sb->sc_fifo);
    fprintf(f,"  \"sc_rr\": %d,\n",         sb->sc_rr);
    fprintf(f,"  \"sc_cfs\": %d,\n",        sb->sc_cfs);
    fprintf(f,"  \"sc_cfs_srtf\": %d,\n",   sb->sc_cfs_srtf);
    fprintf(f,"  \"sc_bfs\": %d,\n",        sb->sc_bfs);
    fprintf(f,"  \"sc_sjf\": %d,\n",        sb->sc_sjf);
    fprintf(f,"  \"sc_strf\": %d,\n",       sb->sc_strf);
    fprintf(f,"  \"sc_hrrn\": %d,\n",       sb->sc_hrrn);
    fprintf(f,"  \"sc_hrrn_rt\": %d,\n",    sb->sc_hrrn_rt);
    fprintf(f,"  \"sc_priority\": %d,\n",   sb->sc_priority);
    fprintf(f,"  \"sc_hpc_over\": %d,\n",   sb->sc_hpc_over);
    fprintf(f,"  \"sc_mlfq\": %d,\n",       sb->sc_mlfq);

    fprintf(f,"  \"basic_percent\": %.3f,\n",   sb->basic_percent);
    fprintf(f,"  \"normal_percent\": %.3f,\n",  sb->normal_percent);
    fprintf(f,"  \"external_percent\": %.3f,\n",sb->external_percent);
    fprintf(f,"  \"modes_percent\": %.3f,\n",   sb->modes_percent);
    fprintf(f,"  \"edge_percent\": %.3f,\n",    sb->edge_percent);
    fprintf(f,"  \"hidden_percent\": %.3f,\n",  sb->hidden_percent);

    fprintf(f,"  \"pass_threshold\": %.1f\n",   sb->pass_threshold);
    fprintf(f,"}\n");
    fclose(f);
}

void scoreboard_init(void){}
void scoreboard_close(void){}

void scoreboard_load(void){
    char* json=read_file_all("scoreboard.json");
    if(!json){update_unlocks();return;}

    gSB.basic_total   =parse_json_int(json,"basic_total",   gSB.basic_total);
    gSB.basic_pass    =parse_json_int(json,"basic_pass",    gSB.basic_pass);
    gSB.normal_total  =parse_json_int(json,"normal_total",  gSB.normal_total);
    gSB.normal_pass   =parse_json_int(json,"normal_pass",   gSB.normal_pass);
    gSB.external_total=parse_json_int(json,"external_total",gSB.external_total);
    gSB.external_pass =parse_json_int(json,"external_pass", gSB.external_pass);
    gSB.modes_total   =parse_json_int(json,"modes_total",   gSB.modes_total);
    gSB.modes_pass    =parse_json_int(json,"modes_pass",    gSB.modes_pass);
    gSB.edge_total    =parse_json_int(json,"edge_total",    gSB.edge_total);
    gSB.edge_pass     =parse_json_int(json,"edge_pass",     gSB.edge_pass);
    gSB.hidden_total  =parse_json_int(json,"hidden_total",  gSB.hidden_total);
    gSB.hidden_pass   =parse_json_int(json,"hidden_pass",   gSB.hidden_pass);

    gSB.sc_fifo       =parse_json_int(json,"sc_fifo",       gSB.sc_fifo);
    gSB.sc_rr         =parse_json_int(json,"sc_rr",         gSB.sc_rr);
    gSB.sc_cfs        =parse_json_int(json,"sc_cfs",        gSB.sc_cfs);
    gSB.sc_cfs_srtf   =parse_json_int(json,"sc_cfs_srtf",   gSB.sc_cfs_srtf);
    gSB.sc_bfs        =parse_json_int(json,"sc_bfs",        gSB.sc_bfs);
    gSB.sc_sjf        =parse_json_int(json,"sc_sjf",        gSB.sc_sjf);
    gSB.sc_strf       =parse_json_int(json,"sc_strf",       gSB.sc_strf);
    gSB.sc_hrrn       =parse_json_int(json,"sc_hrrn",       gSB.sc_hrrn);
    gSB.sc_hrrn_rt    =parse_json_int(json,"sc_hrrn_rt",    gSB.sc_hrrn_rt);
    gSB.sc_priority   =parse_json_int(json,"sc_priority",   gSB.sc_priority);
    gSB.sc_hpc_over   =parse_json_int(json,"sc_hpc_over",   gSB.sc_hpc_over);
    gSB.sc_mlfq       =parse_json_int(json,"sc_mlfq",       gSB.sc_mlfq);

    gSB.basic_percent   =parse_json_double(json,"basic_percent",   gSB.basic_percent);
    gSB.normal_percent  =parse_json_double(json,"normal_percent",  gSB.normal_percent);
    gSB.external_percent=parse_json_double(json,"external_percent",gSB.external_percent);
    gSB.modes_percent   =parse_json_double(json,"modes_percent",   gSB.modes_percent);
    gSB.edge_percent    =parse_json_double(json,"edge_percent",    gSB.edge_percent);
    gSB.hidden_percent  =parse_json_double(json,"hidden_percent",  gSB.hidden_percent);

    gSB.pass_threshold  =parse_json_double(json,"pass_threshold",  gSB.pass_threshold);

    free(json);
    update_unlocks();
}

void scoreboard_save(void){
    update_unlocks();
    write_scoreboard_json(&gSB);
}

int scoreboard_get_final_score(void){
    update_unlocks();
    /* Weighted:
       BASIC=20, NORMAL=20, EXTERNAL=20,
       MODES=10, EDGE=15, HIDDEN=15 => 100% total */
    double w_basic=0.20;
    double w_normal=0.20;
    double w_ext=0.20;
    double w_modes=0.10;
    double w_edge=0.15;
    double w_hidden=0.15;

    double fs=(gSB.basic_percent*w_basic)+
              (gSB.normal_percent*w_normal)+
              (gSB.external_percent*w_ext)+
              (gSB.modes_percent*w_modes)+
              (gSB.edge_percent*w_edge)+
              (gSB.hidden_percent*w_hidden);

    if(fs<0.0) fs=0.0;
    if(fs>100.) fs=100.0;

    int final_i=(int)(fs+0.5);
    if(final_i>100) final_i=100;
    if(final_i<0)   final_i=0;
    return final_i;
}

void scoreboard_clear(void){
    memset(&gSB,0,sizeof(gSB));
    gSB.pass_threshold=60.0;
    unlocked_basic=1;
    unlocked_normal=0;
    unlocked_external=0;
    unlocked_modes=0;
    unlocked_edge=0;
    unlocked_hidden=0;
    scoreboard_save();
}

void get_scoreboard(scoreboard_t* out){
    if(out) *out=gSB;
}

void scoreboard_set_sc_mastered(scheduler_alg_t alg){
    switch(alg){
    case ALG_FIFO:          gSB.sc_fifo=1; break;
    case ALG_RR:            gSB.sc_rr=1; break;
    case ALG_CFS:           gSB.sc_cfs=1; break;
    case ALG_CFS_SRTF:      gSB.sc_cfs_srtf=1; break;
    case ALG_BFS:           gSB.sc_bfs=1; break;
    case ALG_SJF:           gSB.sc_sjf=1; break;
    case ALG_STRF:          gSB.sc_strf=1; break;
    case ALG_HRRN:          gSB.sc_hrrn=1; break;
    case ALG_HRRN_RT:       gSB.sc_hrrn_rt=1; break;
    case ALG_PRIORITY:      gSB.sc_priority=1; break;
    case ALG_HPC_OVERSHADOW:gSB.sc_hpc_over=1; break;
    case ALG_MLFQ:          gSB.sc_mlfq=1; break;
    default: break;
    }
}

void scoreboard_update_basic(int total,int pass){
    gSB.basic_total+=total;
    gSB.basic_pass+=pass;
}
void scoreboard_update_normal(int total,int pass){
    gSB.normal_total+=total;
    gSB.normal_pass+=pass;
}
void scoreboard_update_external(int total,int pass){
    gSB.external_total+=total;
    gSB.external_pass+=pass;
}
void scoreboard_update_modes(int total,int pass){
    gSB.modes_total+=total;
    gSB.modes_pass+=pass;
}
void scoreboard_update_edge(int total,int pass){
    gSB.edge_total+=total;
    gSB.edge_pass+=pass;
}
void scoreboard_update_hidden(int total,int pass){
    gSB.hidden_total+=total;
    gSB.hidden_pass+=pass;
}
#ifndef SCOREBOARD_H
#define SCOREBOARD_H

#include "scheduler.h"

typedef struct {
    int basic_total,basic_pass;
    int normal_total,normal_pass;
    int external_total, external_pass;
    int modes_total,modes_pass;
    int edge_total,edge_pass;
    int hidden_total,hidden_pass;

    int sc_fifo,sc_rr,sc_cfs,sc_cfs_srtf,sc_bfs;
    int sc_sjf,sc_strf,sc_hrrn,sc_hrrn_rt;
    int sc_priority,sc_hpc_over,sc_mlfq;

    double basic_percent;
    double normal_percent;
    double external_percent;
    double modes_percent;
    double edge_percent;
    double hidden_percent;

    double pass_threshold;
} scoreboard_t;

extern int unlocked_basic;
extern int unlocked_normal;
extern int unlocked_external;
extern int unlocked_modes;
extern int unlocked_edge;
extern int unlocked_hidden;

void scoreboard_init(void);
void scoreboard_close(void);
void scoreboard_load(void);
void scoreboard_save(void);
void scoreboard_clear(void);
void get_scoreboard(scoreboard_t* out);
int  scoreboard_get_final_score(void);

void scoreboard_set_sc_mastered(scheduler_alg_t alg);

void scoreboard_update_basic(int total,int pass);
void scoreboard_update_normal(int total,int pass);
void scoreboard_update_external(int total,int pass);
void scoreboard_update_modes(int total,int pass);
void scoreboard_update_edge(int total,int pass);
void scoreboard_update_hidden(int total,int pass);

#endif
#include "worker.h"
#include <stdio.h>
#include <unistd.h>

void simulate_process(process_t* p){
    if(!p) return;
    printf("[Worker] Full run => priority=%d, burst=%lu\n",
           p->priority,(unsigned long)p->burst_time);
    usleep(p->burst_time*1000U);
}

void simulate_process_partial(process_t* p,unsigned long slice){
    if(!p||!slice) return;
    printf("[Worker] Partial => priority=%d, slice=%lu\n",
           p->priority,slice);
    usleep(slice*1000U);
}
#ifndef WORKER_H
#define WORKER_H

#include "process.h"

void simulate_process(process_t* p);
void simulate_process_partial(process_t* p, unsigned long slice_ms);

#endif
#include "basic-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>

static int tests_run=0, tests_failed=0;

static void sc_fifo_run(void){
    os_init();
    process_t p[2];
    init_process(&p[0],3,1,os_time());
    init_process(&p[1],5,1,os_time());
    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);
    os_cleanup();
}
TEST(test_fifo){
    struct captured_output cap;
    int st=run_function_capture_output(sc_fifo_run,&cap);
    bool pass=(st==0&&strstr(cap.stdout_buf,"Init")&&
               strstr(cap.stdout_buf,"Stats for FIFO")&&
               strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "FIFO logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_FIFO);
    return true;
}

static void sc_rr_run(void){
    os_init();
    process_t p[2];
    init_process(&p[0],2,1,os_time());
    init_process(&p[1],2,1,os_time());
    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p,2);
    os_cleanup();
}
TEST(test_rr){
    struct captured_output cap;
    int st=run_function_capture_output(sc_rr_run,&cap);
    bool pass=(st==0&&strstr(cap.stdout_buf,"Init")&&
               strstr(cap.stdout_buf,"Stats for RR")&&
               strstr(cap.stdout_buf,"Cleanup"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "RR logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_RR);
    return true;
}

static void sc_cfs_run(void){
    os_init();
    process_t p[2];
    init_process(&p[0],3,0,os_time());
    init_process(&p[1],4,0,os_time());
    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(p,2);
    os_cleanup();
}
TEST(test_cfs){
    struct captured_output cap;
    int st=run_function_capture_output(sc_cfs_run,&cap);
    bool pass=(st==0&&strstr(cap.stdout_buf,"Stats for CFS"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "CFS logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS);
    return true;
}

static void sc_bfs_run(void){
    os_init();
    process_t p[3];
    for(int i=0;i<3;i++){
        init_process(&p[i],2+i,1,os_time());
    }
    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p,3);
    os_cleanup();
}
TEST(test_bfs){
    struct captured_output cap;
    int st=run_function_capture_output(sc_bfs_run,&cap);
    bool pass=(st==0&&strstr(cap.stdout_buf,"Stats for BFS"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "BFS logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_BFS);
    return true;
}

static void sc_pipeline_run(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
}
TEST(test_pipeline){
    struct captured_output cap;
    int st=run_function_capture_output(sc_pipeline_run,&cap);
    bool pass=(st==0&&strstr(cap.stdout_buf,"Pipeline start")&&
               strstr(cap.stdout_buf,"Pipeline end"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "Pipeline logs missing or incomplete.");
        return false;
    }
    return true;
}

static void sc_distributed_run(void){
    os_init();
    os_run_distributed_example();
    os_cleanup();
}
TEST(test_distributed){
    struct captured_output cap;
    int st=run_function_capture_output(sc_distributed_run,&cap);
    bool pass=(st==0&&strstr(cap.stdout_buf,"Distributed example: fork"));
    if(!pass){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "Distributed logs missing or incomplete.");
        return false;
    }
    return true;
}

static void sc_fifo_strict(void){
    os_init();
    process_t p[2];
    init_process(&p[0],3,10,os_time());
    init_process(&p[1],4,20,os_time());
    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p,2);
    os_cleanup();
}
TEST(test_fifo_strict){
    struct captured_output cap;
    int st=run_function_capture_output(sc_fifo_strict,&cap);
    if(st!=0){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "FIFO strict test aborted unexpectedly.");
        return false;
    }
    bool p20_saw=false, violate=false;
    char* line=strtok(cap.stdout_buf,"\n");
    while(line){
        if(strstr(line,"[Worker]")&&strstr(line,"priority=")){
            int prio=parse_int_strtol(strstr(line,"priority=")+9,100);
            if(prio==20) p20_saw=true;
            if(prio==10&&p20_saw) violate=true;
        }
        line=strtok(NULL,"\n");
    }
    if(violate){
        snprintf(g_test_fail_reason,sizeof(g_test_fail_reason),
                 "FIFO strict ordering violated.");
        return false;
    }
    return true;
}

void run_basic_tests(int* total,int* passed){
    tests_run=0;tests_failed=0;
    RUN_TEST(test_fifo);
    RUN_TEST(test_rr);
    RUN_TEST(test_cfs);
    RUN_TEST(test_bfs);
    RUN_TEST(test_pipeline);
    RUN_TEST(test_distributed);
    RUN_TEST(test_fifo_strict);

    *total=tests_run; *passed=tests_run-tests_failed;
}
#ifndef BASIC_TEST_H
#define BASIC_TEST_H
void run_basic_tests(int*,int*);
#endif
#include "edge-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include <string.h>
#include <stdio.h>

static int tests_run = 0, tests_failed = 0;

static void extreme_long(void){
    os_init();
    process_t p[1];
    init_process(&p[0], 50, 2, os_time());
    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p, 1);
    os_cleanup();
}
TEST(test_extreme_long){
    struct captured_output cap;
    int st = run_function_capture_output(extreme_long, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Stats for FIFO"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Long burst logs missing or incomplete.");
        return false;
    }
    return true;
}

static void extreme_short(void){
    os_init();
    process_t p[1];
    init_process(&p[0], 1, 2, os_time());
    scheduler_select_algorithm(ALG_RR);
    scheduler_run(p, 1);
    os_cleanup();
}
TEST(test_extreme_short){
    struct captured_output cap;
    int st = run_function_capture_output(extreme_short, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Stats for RR"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Short burst logs missing or incomplete.");
        return false;
    }
    return true;
}

static void high_load(void){
    os_init();
    process_t arr[10];
    for(int i=0; i<10; i++){
        init_process(&arr[i], 3+(i%3), 1, os_time());
    }
    scheduler_select_algorithm(ALG_CFS);
    scheduler_run(arr, 10);
    os_cleanup();
}
TEST(test_high_load){
    struct captured_output cap;
    int st = run_function_capture_output(high_load, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Stats for CFS"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "High load logs missing or incomplete.");
        return false;
    }
    return true;
}

static void hpc_under_load(void){
    os_init();
    os_run_hpc_overshadow();
    os_cleanup();
}
TEST(test_hpc_under_load){
    struct captured_output cap;
    int st = run_function_capture_output(hpc_under_load, &cap);
    bool pass = (st==0 &&
                 strstr(cap.stdout_buf, "HPC overshadow start") &&
                 strstr(cap.stdout_buf, "HPC overshadow done"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "HPC overshadow logs missing or incomplete.");
        return false;
    }
    return true;
}

static void container_spam(void){
    os_init();
    for(int i=0; i<3; i++){
        os_create_ephemeral_container();
    }
    for(int i=0; i<3; i++){
        os_remove_ephemeral_container();
    }
    os_cleanup();
}
TEST(test_container_spam){
    struct captured_output cap;
    int st = run_function_capture_output(container_spam, &cap);
    bool pass = (st==0 &&
                 strstr(cap.stdout_buf, "Container created") &&
                 strstr(cap.stdout_buf, "Container removed"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Container spam logs missing or incomplete.");
        return false;
    }
    return true;
}

static void pipeline_edge(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
}
TEST(test_pipeline_edge){
    struct captured_output cap;
    int st = run_function_capture_output(pipeline_edge, &cap);
    bool pass = (st==0 &&
                 strstr(cap.stdout_buf, "Pipeline start") &&
                 strstr(cap.stdout_buf, "Pipeline end"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Pipeline logs missing or incomplete.");
        return false;
    }
    return true;
}

static void multi_distrib(void){
    os_init();
    for(int i=0; i<3; i++){
        os_run_distributed_example();
    }
    os_cleanup();
}
TEST(test_multi_distrib){
    struct captured_output cap;
    int st = run_function_capture_output(multi_distrib, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Distributed example: fork"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Multi distributed logs missing or incomplete.");
        return false;
    }
    return true;
}

void run_edge_tests(int* total,int* passed){
    tests_run = 0;
    tests_failed = 0;

    RUN_TEST(test_extreme_long);
    RUN_TEST(test_extreme_short);
    RUN_TEST(test_high_load);
    RUN_TEST(test_hpc_under_load);
    RUN_TEST(test_container_spam);
    RUN_TEST(test_pipeline_edge);
    RUN_TEST(test_multi_distrib);

    *total = tests_run;
    *passed = tests_run - tests_failed;
}
/* edge-test.h */
#ifndef EDGE_TEST_H
#define EDGE_TEST_H
void run_edge_tests(int* total,int* passed);
#endif
#include "external-test.h"
#include "test_common.h"
#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/runner.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

static scheduler_alg_t test_modes[]={
    ALG_FIFO, ALG_RR, ALG_BFS, ALG_PRIORITY,
    ALG_CFS, ALG_CFS_SRTF, ALG_SJF, ALG_STRF,
    ALG_HRRN, ALG_HRRN_RT, ALG_HPC_OVERSHADOW, ALG_MLFQ
};

static const char* modeName(scheduler_alg_t m){
    switch(m){
    case ALG_FIFO:return "FIFO";
    case ALG_RR:return "RR";
    case ALG_BFS:return "BFS";
    case ALG_PRIORITY:return "PRIORITY";
    case ALG_CFS:return "CFS";
    case ALG_CFS_SRTF:return "CFS-SRTF";
    case ALG_SJF:return "SJF";
    case ALG_STRF:return "STRF";
    case ALG_HRRN:return "HRRN";
    case ALG_HRRN_RT:return "HRRN-RT";
    case ALG_HPC_OVERSHADOW:return "HPC-OVER";
    case ALG_MLFQ:return "MLFQ";
    default:return "???";
    }
}

void run_external_tests(void){
    printf("[External] Testing each scheduling mode individually.\n");
    int total=0, passed=0;
    int mc=(int)(sizeof(test_modes)/sizeof(test_modes[0]));

    for(int i=0;i<mc;i++){
        total++;
        printf("  Testing %s... ", modeName(test_modes[i]));
        fflush(stdout);

        os_init();
        /* trivial internal test for each mode: run a short HPC overshadow or short process. */
        process_t d[1];
        init_process(&d[0], 2, 1, os_time());
        scheduler_select_algorithm(test_modes[i]);
        scheduler_run(d,1);

        /* concurrency with a single short command. e.g. 'sleep 2' */
        char* lines[1];
        lines[0]= "sleep 2";
        run_shell_commands_concurrently(1, lines, 1, test_modes[i],0);

        /* assume pass if no major errors occurred. */
        scoreboard_set_sc_mastered(test_modes[i]);
        passed++;
        printf("PASS\n");
        os_cleanup();
    }
    printf("\n[External] => %d total, %d passed.\n", total, passed);
    scoreboard_update_external(total, passed);
    scoreboard_save();
}
/* external-test.h */
#ifndef EXTERNAL_TEST_H
#define EXTERNAL_TEST_H

void run_external_tests(void);

#endif
#include "hidden-test.h"
#include "test_common.h"
#include "../src/os.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include <string.h>
#include <stdio.h>

static int tests_run=0, tests_failed=0;

static void distrib_heavy(void){
    os_init();
    for(int i=0; i<4; i++){
        os_run_distributed_example();
    }
    os_cleanup();
}
TEST(test_distrib_heavy){
    struct captured_output cap;
    int st = run_function_capture_output(distrib_heavy, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Distributed example: fork"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Distrib heavy logs missing or incomplete.");
        return false;
    }
    return true;
}

static void hpc_heavy(void){
    // No init/cleanup to let parent handle around it
    os_run_hpc_overshadow();
    os_run_hpc_overshadow();
}
TEST(test_hpc_heavy){
    struct captured_output cap;
    int st = run_function_capture_output(hpc_heavy, &cap);
    int c=0;
    char* s = cap.stdout_buf;
    while((s = strstr(s, "HPC overshadow start"))){
        c++;
        s++;
    }
    bool pass = (st==0 && c >= 2);
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Expected HPC overshadow >=2 times, found %d.", c);
        return false;
    }
    return true;
}

static void container_combo(void){
    os_init();
    os_create_ephemeral_container();
    os_run_distributed_example();
    os_run_hpc_overshadow();
    os_remove_ephemeral_container();
    os_cleanup();
}
TEST(test_container_combo){
    struct captured_output cap;
    int st = run_function_capture_output(container_combo, &cap);
    bool pass = (st==0 &&
                 strstr(cap.stdout_buf, "Container created") &&
                 strstr(cap.stdout_buf, "Container removed") &&
                 strstr(cap.stdout_buf, "Distributed example: fork") &&
                 strstr(cap.stdout_buf, "HPC overshadow done"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "container combo logs missing or incomplete.");
        return false;
    }
    return true;
}

static void scheduling_var(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 2, 1, os_time());
    init_process(&p[1], 6, 2, os_time());
    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p, 2);
    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p, 2);
    os_cleanup();
}
TEST(test_scheduling_variety){
    struct captured_output cap;
    int st = run_function_capture_output(scheduling_var, &cap);
    bool pass = (st==0 &&
                 strstr(cap.stdout_buf, "Stats for SJF") &&
                 strstr(cap.stdout_buf, "Stats for PRIORITY"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "SJF/PRIORITY logs missing or incomplete.");
        return false;
    }
    return true;
}

static void auto_logic(void){
    // Just a stub to illustrate something
    printf("Auto mode selection tested.\n");
}
TEST(test_auto_logic){
    struct captured_output cap;
    int st = run_function_capture_output(auto_logic, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Auto mode selection tested."));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Missing auto mode selection line.");
        return false;
    }
    return true;
}

static void final_integration(void){
    os_init();
    os_log("Final synergy HPC + container + pipeline + distributed");
    os_create_ephemeral_container();
    os_run_hpc_overshadow();
    os_run_distributed_example();
    os_pipeline_example();
    os_remove_ephemeral_container();
    os_cleanup();
}
TEST(test_final_integration){
    struct captured_output cap;
    int st = run_function_capture_output(final_integration, &cap);
    bool pass = (st==0 &&
                 strstr(cap.stdout_buf, "Final synergy HPC + container + pipeline + distributed") &&
                 strstr(cap.stdout_buf, "Pipeline end"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Missing synergy logs in final integration.");
        return false;
    }
    return true;
}

static void multi_stage_distrib(void){
    for(int i=0; i<2; i++){
        os_run_distributed_example();
        os_run_hpc_overshadow();
    }
}
TEST(test_multi_stage_distributed){
    struct captured_output cap;
    int st = run_function_capture_output(multi_stage_distrib, &cap);
    int c=0;
    char* s = cap.stdout_buf;
    while((s = strstr(s, "HPC overshadow start"))){
        c++;
        s++;
    }
    bool pass = (st==0 && c>=2);
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Multi overshadow logs missing or <2.");
        return false;
    }
    return true;
}

void run_hidden_tests(int* total,int* passed){
    tests_run=0;
    tests_failed=0;

    RUN_TEST(test_distrib_heavy);
    RUN_TEST(test_hpc_heavy);
    RUN_TEST(test_container_combo);
    RUN_TEST(test_scheduling_variety);
    RUN_TEST(test_auto_logic);
    RUN_TEST(test_final_integration);
    RUN_TEST(test_multi_stage_distributed);

    *total=tests_run;
    *passed=tests_run-tests_failed;
}
/* hidden-test.h */
#ifndef HIDDEN_TEST_H
#define HIDDEN_TEST_H
void run_hidden_tests(int* total,int* passed);
#endif
#include "modes-test.h"
#include "test_common.h"
#include "../src/scheduler.h"
#include "../src/process.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>

static int tests_run = 0, tests_failed = 0;

static void hpc_over(void){
    os_init();
    scheduler_select_algorithm(ALG_HPC_OVERSHADOW);
    process_t d[1];
    init_process(&d[0], 0, 0, os_time());
    scheduler_run(d,1);
    os_cleanup();
}
TEST(test_hpc_over){
    struct captured_output cap;
    int st = run_function_capture_output(hpc_over, &cap);
    bool pass = (st==0 &&
                 strstr(cap.stdout_buf, "HPC overshadow start") &&
                 strstr(cap.stdout_buf, "HPC overshadow done"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "HPC overshadow logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HPC_OVERSHADOW);
    return true;
}

static void multi_containers(void){
    os_init();
    for(int i=0; i<2; i++){
        os_create_ephemeral_container();
    }
    for(int i=0; i<2; i++){
        os_remove_ephemeral_container();
    }
    os_cleanup();
}
TEST(test_multi_containers){
    struct captured_output cap;
    int st = run_function_capture_output(multi_containers, &cap);
    bool pass = (st==0 &&
                 strstr(cap.stdout_buf, "Container created") &&
                 strstr(cap.stdout_buf, "Container removed"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Containers logs missing or incomplete.");
        return false;
    }
    return true;
}

static void multi_distrib(void){
    os_init();
    for(int i=0; i<2; i++){
        os_run_distributed_example();
    }
    os_cleanup();
}
TEST(test_multi_distrib){
    struct captured_output cap;
    int st = run_function_capture_output(multi_distrib, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Distributed example: fork"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Multi distrib logs missing or incomplete.");
        return false;
    }
    return true;
}

static void pipeline_modes(void){
    os_init();
    os_pipeline_example();
    os_cleanup();
}
TEST(test_pipeline_modes){
    struct captured_output cap;
    int st = run_function_capture_output(pipeline_modes, &cap);
    bool pass = (st==0 &&
                 strstr(cap.stdout_buf, "Pipeline start") &&
                 strstr(cap.stdout_buf, "Pipeline end"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Pipeline logs missing or incomplete.");
        return false;
    }
    return true;
}

static void mix_algos(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 2, 1, os_time());
    init_process(&p[1], 3, 1, os_time());

    scheduler_select_algorithm(ALG_FIFO);
    scheduler_run(p, 2);

    scheduler_select_algorithm(ALG_BFS);
    scheduler_run(p, 2);

    os_cleanup();
}
TEST(test_mix_algos){
    struct captured_output cap;
    int st = run_function_capture_output(mix_algos, &cap);
    bool pass = (st==0 &&
                 strstr(cap.stdout_buf, "Stats for FIFO") &&
                 strstr(cap.stdout_buf, "Stats for BFS"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Mix algos logs missing or incomplete.");
        return false;
    }
    return true;
}

static void double_hpc(void){
    os_init();
    os_run_hpc_overshadow();
    os_run_hpc_overshadow();
    os_cleanup();
}
TEST(test_double_hpc){
    struct captured_output cap;
    int st = run_function_capture_output(double_hpc, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "HPC overshadow start"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "Double HPC overshadow logs missing or incomplete.");
        return false;
    }
    return true;
}

static void mlfq_check(void){
    os_init();
    process_t p[3];
    for(int i=0; i<3; i++){
        init_process(&p[i], 3+i, (i+1)*10, os_time());
    }
    scheduler_select_algorithm(ALG_MLFQ);
    scheduler_run(p, 3);
    os_cleanup();
}
TEST(test_mlfq_check){
    struct captured_output cap;
    int st = run_function_capture_output(mlfq_check, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Stats for MLFQ"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "MLFQ logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_MLFQ);
    return true;
}

void run_modes_tests(int* total,int* passed){
    tests_run = 0;
    tests_failed = 0;

    RUN_TEST(test_hpc_over);
    RUN_TEST(test_multi_containers);
    RUN_TEST(test_multi_distrib);
    RUN_TEST(test_pipeline_modes);
    RUN_TEST(test_mix_algos);
    RUN_TEST(test_double_hpc);
    RUN_TEST(test_mlfq_check);

    *total  = tests_run;
    *passed = tests_run - tests_failed;
}
/* modes-test.h */
#ifndef MODES_TEST_H
#define MODES_TEST_H
void run_modes_tests(int* total,int* passed);
#endif
#include "normal-test.h"
#include "test_common.h"
#include "../src/process.h"
#include "../src/scheduler.h"
#include "../src/os.h"
#include "../src/scoreboard.h"
#include <string.h>
#include <stdio.h>

static int tests_run = 0, tests_failed = 0;

static void sc_sjf_run(void){
    os_init();
    process_t p[3];
    init_process(&p[0], 1, 1, os_time());
    init_process(&p[1], 5, 1, os_time());
    init_process(&p[2], 2, 1, os_time());
    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p, 3);
    os_cleanup();
}
TEST(test_sjf){
    struct captured_output cap;
    const int st = run_function_capture_output(sc_sjf_run, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Stats for SJF"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "SJF logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_SJF);
    return true;
}

static void sc_strf_run(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 4, 1, os_time());
    init_process(&p[1], 3, 1, os_time());
    scheduler_select_algorithm(ALG_STRF);
    scheduler_run(p, 2);
    os_cleanup();
}
TEST(test_strf){
    struct captured_output cap;
    const int st = run_function_capture_output(sc_strf_run, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Stats for STRF"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "STRF logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_STRF);
    return true;
}

static void sc_hrrn_run(void){
    os_init();
    process_t p[3];
    for(int i=0; i<3; i++){
        init_process(&p[i], 2 + i, 1, os_time());
    }
    scheduler_select_algorithm(ALG_HRRN);
    scheduler_run(p, 3);
    os_cleanup();
}
TEST(test_hrrn){
    struct captured_output cap;
    const int st = run_function_capture_output(sc_hrrn_run, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Stats for HRRN"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "HRRN logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN);
    return true;
}

static void sc_hrrn_rt_run(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 3, 1, os_time());
    init_process(&p[1], 4, 2, os_time());
    scheduler_select_algorithm(ALG_HRRN_RT);
    scheduler_run(p, 2);
    os_cleanup();
}
TEST(test_hrrn_rt){
    struct captured_output cap;
    const int st = run_function_capture_output(sc_hrrn_rt_run, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Stats for HRRN-RT"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "HRRN-RT logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_HRRN_RT);
    return true;
}

static void sc_prio_run(void){
    os_init();
    process_t p[3];
    init_process(&p[0], 2, 3, os_time());
    init_process(&p[1], 2, 1, os_time());
    init_process(&p[2], 2, 2, os_time());
    scheduler_select_algorithm(ALG_PRIORITY);
    scheduler_run(p, 3);
    os_cleanup();
}
TEST(test_prio){
    struct captured_output cap;
    int st = run_function_capture_output(sc_prio_run, &cap);
    bool pass = (st==0 && strstr(cap.stdout_buf, "Stats for PRIORITY"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "PRIORITY logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_PRIORITY);
    return true;
}

static void sc_cfs_srtf_run(void){
    os_init();
    process_t p[3];
    for(int i=0; i<3; i++){
        init_process(&p[i], 2 + (i*2), 1, os_time());
    }
    scheduler_select_algorithm(ALG_CFS_SRTF);
    scheduler_run(p, 3);
    os_cleanup();
}
TEST(test_cfs_srtf){
    struct captured_output cap;
    const int st = run_function_capture_output(sc_cfs_srtf_run, &cap);
    bool pass = (st == 0 && strstr(cap.stdout_buf, "Stats for CFS-SRTF"));
    if(!pass){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "CFS-SRTF logs missing or incomplete.");
        return false;
    }
    scoreboard_set_sc_mastered(ALG_CFS_SRTF);
    return true;
}

/*
  Ensure short job runs first with SJF:
  p[0] => burst=2, p[1] => burst=5 => p[0] runs fully before p[1].
*/
static void sc_sjf_strict(void){
    os_init();
    process_t p[2];
    init_process(&p[0], 2, 10, os_time());
    init_process(&p[1], 5, 20, os_time());
    scheduler_select_algorithm(ALG_SJF);
    scheduler_run(p, 2);
    os_cleanup();
}
TEST(test_sjf_strict){
    struct captured_output cap;
    int st = run_function_capture_output(sc_sjf_strict, &cap);
    if(st != 0){
        snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                 "SJF strict run error.");
        return false;
    }
    bool p10done = false, p20 = false;
    const char* line = strtok(cap.stdout_buf, "\n");
    while(line){
        if(strstr(line, "[Worker] Partial") || strstr(line, "[Worker] Full")){
            int prio = 0;
            const char* c = strstr(line, "priority=");
            if(c) prio = parse_int_strtol((c+9), 101);
            if(prio == 20 && !p10done){
                snprintf(g_test_fail_reason, sizeof(g_test_fail_reason),
                         "SJF order fail: prio=20 before prio=10 finished.");
                return false;
            }
            if(prio == 10 && strstr(line, "burst=2")){
                p10done = true;
            }
        }
        line = strtok(NULL, "\n");
    }
    return true;
}

void run_normal_tests(int* total,int* passed){
    tests_run = 0;
    tests_failed = 0;

    RUN_TEST(test_sjf);
    RUN_TEST(test_strf);
    RUN_TEST(test_hrrn);
    RUN_TEST(test_hrrn_rt);
    RUN_TEST(test_prio);
    RUN_TEST(test_cfs_srtf);
    RUN_TEST(test_sjf_strict);

    *total  = tests_run;
    *passed = tests_run - tests_failed;
}
#ifndef NORMAL_TEST_H
#define NORMAL_TEST_H
void run_normal_tests(int*,int*);
#endif
#include "test_common.h"
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <errno.h>

char g_test_fail_reason[256] = {0};

/*
  read_all() tries to read from a file descriptor until EOF,
  storing data into 'buf' up to 'cap - 1' bytes, ensuring a null terminator.
*/
static ssize_t read_all(int fd, char* buf, size_t cap){
    size_t used = 0;
    while(used + 1 < cap){
        ssize_t r = read(fd, buf + used, cap - 1 - used);
        if(r < 0 && errno == EINTR) {
            continue; // interrupted => retry
        }
        if(r <= 0) {
            break; // EOF or error
        }
        used += (size_t)r;
    }
    buf[used] = '\0';
    return (ssize_t)used;
}

int run_function_capture_output(void(*fn)(void), struct captured_output* out){
    if(!fn || !out) {
        return -1; // invalid usage
    }

    int p_out[2], p_err[2];
    if(pipe(p_out) == -1 || pipe(p_err) == -1) {
        return -1; // can't create pipes
    }

    // Save current stdout/stderr
    int save_out = dup(STDOUT_FILENO);
    int save_err = dup(STDERR_FILENO);
    if(save_out < 0 || save_err < 0) {
        return -1;
    }

    pid_t c = fork();
    if(c < 0) {
        return -1; // fork fail
    }

    if(c == 0) {
        // child
        close(p_out[0]);
        close(p_err[0]);

        // redirect child's stdout/stderr to the pipes
        dup2(p_out[1], STDOUT_FILENO);
        dup2(p_err[1], STDERR_FILENO);

        // close pipe write-ends
        close(p_out[1]);
        close(p_err[1]);

        // run the test function
        fn();
        _exit(0);
    }

    // parent
    close(p_out[1]);
    close(p_err[1]);

    // read child's stdout/stderr
    read_all(p_out[0], out->stdout_buf, sizeof(out->stdout_buf));
    read_all(p_err[0], out->stderr_buf, sizeof(out->stderr_buf));
    close(p_out[0]);
    close(p_err[0]);

    // restore parent's stdout/stderr
    dup2(save_out, STDOUT_FILENO);
    dup2(save_err, STDERR_FILENO);
    close(save_out);
    close(save_err);

    int st = 0;
    waitpid(c, &st, 0);
    return st;
}
#ifndef TEST_COMMON_H
#define TEST_COMMON_H

#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "../src/safe_calls_library.h"


/*
  g_test_fail_reason will hold any reason for test failure.
*/
extern char g_test_fail_reason[256];

/*
  A simple struct to capture stdout/stderr from a function call
  in run_function_capture_output().
*/
struct captured_output {
    char stdout_buf[8192];
    char stderr_buf[8192];
};

/*
  run_function_capture_output() forks, redirects child's stdout/stderr
  to pipes, runs the provided function, and returns the child exit code,
  while capturing the output in 'out'.
*/
int run_function_capture_output(void(*fn)(void), struct captured_output* out);

/*
  A convenient macro to define a test function:
     TEST(name){
        ... check conditions ...
        return true or false
     }
*/
#define TEST(name) static bool test_##name(void)

/*
  Another convenience macro to run a test, increment counters, and
  display PASS/FAIL.
*/
#define RUN_TEST(name) do{ \
bool ok = test_##name(); \
tests_run++; \
if(!ok){ \
tests_failed++; \
printf("  FAIL: %s => %s\n", #name, g_test_fail_reason[0] ? g_test_fail_reason : "???"); \
} else { \
printf("  PASS: %s\n", #name); \
} \
} while(0)

#endif
